<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fltk book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Home.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li class="chapter-item expanded "><a href="Setup.html"><strong aria-hidden="true">2.</strong> 配置</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Cross-Compiling.html"><strong aria-hidden="true">2.1.</strong> 交叉编译</a></li><li class="chapter-item "><a href="Fluid.html"><strong aria-hidden="true">2.2.</strong> 使用 Fluid</a></li></ol></li><li class="chapter-item expanded "><a href="The-App-struct.html"><strong aria-hidden="true">3.</strong> App 结构</a></li><li class="chapter-item expanded "><a href="Windows.html"><strong aria-hidden="true">4.</strong> 窗口 Windows</a></li><li class="chapter-item expanded "><a href="Widgets.html"><strong aria-hidden="true">5.</strong> 组件 Widgets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Buttons.html"><strong aria-hidden="true">5.1.</strong> 按钮 Buttons</a></li><li class="chapter-item "><a href="Labels.html"><strong aria-hidden="true">5.2.</strong> 标签 Labels</a></li><li class="chapter-item "><a href="Group-widgets.html"><strong aria-hidden="true">5.3.</strong> 组控件 Group widgets</a></li><li class="chapter-item "><a href="Menus.html"><strong aria-hidden="true">5.4.</strong> 菜单 Menus</a></li><li class="chapter-item "><a href="Input-&-Output.html"><strong aria-hidden="true">5.5.</strong> 输入输出 Input & Output</a></li><li class="chapter-item "><a href="Valuators.html"><strong aria-hidden="true">5.6.</strong> 估值器 Valuators</a></li><li class="chapter-item "><a href="Text.html"><strong aria-hidden="true">5.7.</strong> 文字 Text</a></li><li class="chapter-item "><a href="Browsers.html"><strong aria-hidden="true">5.8.</strong> 阅览器 Browsers</a></li><li class="chapter-item "><a href="Trees.html"><strong aria-hidden="true">5.9.</strong> 树 Trees</a></li><li class="chapter-item "><a href="Tables.html"><strong aria-hidden="true">5.10.</strong> 表格 Tables</a></li><li class="chapter-item "><a href="Custom-Widgets.html"><strong aria-hidden="true">5.11.</strong> 自定义组件 Custom widgets</a></li></ol></li><li class="chapter-item expanded "><a href="Dialogs.html"><strong aria-hidden="true">6.</strong> 对话框 Dialogs</a></li><li class="chapter-item expanded "><a href="Images.html"><strong aria-hidden="true">7.</strong> 图像 Images</a></li><li class="chapter-item expanded "><a href="Events.html"><strong aria-hidden="true">8.</strong> 事件 Events</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Drag-&-Drop.html"><strong aria-hidden="true">8.1.</strong> 拖放 Drag & Drop</a></li><li class="chapter-item "><a href="State-Management.html"><strong aria-hidden="true">8.2.</strong> 状态管理器 State Management</a></li></ol></li><li class="chapter-item expanded "><a href="Layouts.html"><strong aria-hidden="true">9.</strong> 布局 Layouts</a></li><li class="chapter-item expanded "><a href="Style.html"><strong aria-hidden="true">10.</strong> 样式 Style</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Colors.html"><strong aria-hidden="true">10.1.</strong> 颜色 Colors</a></li><li class="chapter-item "><a href="FrameTypes.html"><strong aria-hidden="true">10.2.</strong> FrameTypes</a></li><li class="chapter-item "><a href="Fonts.html"><strong aria-hidden="true">10.3.</strong> 字体 Fonts</a></li><li class="chapter-item "><a href="Drawing.html"><strong aria-hidden="true">10.4.</strong> Drawing things</a></li><li class="chapter-item "><a href="Styling.html"><strong aria-hidden="true">10.5.</strong> Styling</a></li></ol></li><li class="chapter-item expanded "><a href="Animations.html"><strong aria-hidden="true">11.</strong> 动画 Animations</a></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">12.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">fltk book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Flatigers/fltk-book-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>翻译最近更新于：2023/3/4</p>
<h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<p>欢迎来到 <a href="https://github.com/fltk-rs/fltk-rs">fltk-rs</a> 教程 !</p>
<p>这是为 <a href="https://crates.io/crates/fltk">fltk crate</a> 而写的一本说明书。 其他资源有:</p>
<ul>
<li><a href="https://docs.rs/fltk">官方文档</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs#tutorials">视频</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/discussions">讨论、社区</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/tree/master/fltk/examples">示例</a></li>
<li><a href="https://github.com/fltk-rs/demos">示范</a></li>
<li><a href="https://github.com/tdryer/7guis-fltk-rs">7guis-fltk-rs</a></li>
<li><a href="https://github.com/wyhinton/FLTK-RS-Examples">FLTK-RS-Examples</a></li>
<li>Erco's FLTK cheat <a href="http://seriss.com/people/erco/fltk/">page</a>, which is an excellent FLTK C++ reference. </li>
</ul>
<p><a href="https://github.com/fltk/fltk">FLTK</a> 是一个跨平台的轻量级 GUI库。
该库自身是使用 C++98编写的，具有高度可移植性。 fltk crate 是使用 rust 编写的，它是通过FFI来调用一个 使用C89和C++11编写的FLTK封装器 <a href="https://github.com/MoAlyousef/cfltk">cfltk</a>。</p>
<p>该库的构造极其简洁，对习惯使用面向对象GUI库的开发者比较友好。该封装本身也遵循简化文档的相同模型，因为方法的名称与C++所对应的函数是相同或类似的。这使得 FLTK C++ 的文档变得非常简单，因为这些方法基本上是相互对映的。</p>
<p>C++：</p>
<pre><code class="language-c++">int main() {
    auto wind = new Fl_Window(100, 100, 400, 300, &quot;My Window&quot;);
    wind-&gt;end();
    wind-&gt;show();
}
</code></pre>
<p>映射为Rust后：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>为什么选择 FLTK ？</p>
<ul>
<li>轻量。二进制文件简小，<code>strip</code> 后仅有大约1MB。 <a href="https://szibele.com/memory-footprint-of-gui-toolkits/">低内存占用</a>。</li>
<li>快速。安装快、构建快、启动快、运行快。</li>
<li>仅有一个运行文件。不需要配置DDL库。</li>
<li>向前兼容，支持旧架构。</li>
<li>FLTK的允许性许可证，允许闭源应用静态链接。</li>
<li>主题化 (4款默认支持的主题: Base, GTK, Plastic and Gleam)，以及 <a href="https://crates.io/crates/fltk-theme">fltk-theme</a> 中的其他主题。</li>
<li>提供了约80个可供自定义的 widget。</li>
<li>内置图像支持。</li>
</ul>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>将以下代码添加到你的 Cargo.toml 文件:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.3&quot;
</code></pre>
<p>使用捆绑库（适用于 x64 windows (msvc &amp; gnu (msys2)), x64 linux &amp; macos）:</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.3&quot;, features = [&quot;fltk-bundled&quot;] }
</code></pre>
<p>该库提供了特定平台的绑定，它会自动编译,并使用静态链接的方式链接到你的二进制文件中。</p>
<p>现在编写我们的第一个示例，导入必要的 fltk 模块：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, window::Window};
fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>运行这段示例，你会发现并没有什么反应。我们还需要使用一行代码运行事件循环（event loop），这相当于在C++中使用<code>Fl::run()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, prelude::*, window::Window};
fn main() {
    let a = app::App::default();
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>这段代码中，我们实例化了 App 结构，它会初始化运行时（runtime）和样式（styles）。在程序的末尾，我们调用 run() 函数来让程序正常工作。</p>
<h2 id="贡献本书"><a class="header" href="#贡献本书">贡献本书</a></h2>
<p>这本书是使用 <a href="https://github.com/rust-lang/mdBook">mdbook</a>，根据 <a href="https://github.com/fltk-rs/fltk-book">fltk-book</a> 仓库的内容生成的。本书的作者为 <strong>Mohammed Alyousef</strong>，由 <strong>Flatig L</strong> 翻译为中文</p>
<p>你可能需要执行 <code>cargo install mdbook</code>. 更多说明可以在fltk-book的README文件和mdbook的 <a href="https://rust-lang.github.io/mdBook/">用户指南</a> 中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<p>请确保你的电脑上配置了 Rust (version &gt; 1.45)，CMake (version &gt; 3.11)，Git， C++11 编译工具链，并设置好了PATH，这样便可以方便地构建跨平台程序。我们还提供了特定平台上fltk的捆绑库形式，可以通过启用fltk-bundle这个feature来启用（这里会用到curl来下载库，tar来解包）。如果你安装了 ninja-build 构建工具，你可以使用 &quot;use-ninja&quot; feature来启用。它可能会加快构建速度。</p>
<ul>
<li>
<p>Windows: </p>
<ul>
<li>MSVC: Windows SDK</li>
<li>Gnu: 无依赖</li>
</ul>
</li>
<li>
<p>MacOS: 无依赖</p>
</li>
<li>
<p>Linux: 需要安装 X11 and OpenGL 头文件。具有图形用户界面的Linux发行版上带有这些库。</p>
<p>基于 Debian 的Linux发行版，运行：</p>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>基于 RHEL的Linux发行版，运行：</p>
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel libstdc++-static
</code></pre>
<p>基于 Arch 的Linux发行版，运行：</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>Alpine Linux：</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
</li>
<li>
<p>Android： Android Studio，Android Sdk， Android Ndk。</p>
</li>
</ul>
<h2 id="配置细节"><a class="header" href="#配置细节">配置细节</a></h2>
<p>这一部分将假设你没有安装Rust，分几个不同的环境进行讨论：</p>
<h3 id="windows-msvc-toolchain"><a class="header" href="#windows-msvc-toolchain">Windows (MSVC toolchain)</a></h3>
<ul>
<li>访问rust语言官网的 <a href="https://www.rust-lang.org/learn/get-started">开始</a>。</li>
<li>按照 &quot;Visual Studio C++ build tools &quot;的链接，下载MSVC编译器和Windows sdk。</li>
<li>使用安装器安装：</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/37966791/116013495-2dff8800-a639-11eb-8e4c-8c6228e00abc.png" alt="image" /></p>
<p>确保选中这些：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/116013520-48d1fc80-a639-11eb-934a-fac6609135b4.png" alt="image" /></p>
<ul>
<li>你可以在其中查看有没有CMake安装选项，或者直接点这里下载 <a href="https://cmake.org/download/">Cmake</a>。</li>
<li>如果你还没有GIt，请点击下载 <a href="https://git-scm.com/downloads">Git</a>。</li>
<li>从 rust-lang.org 网站上，下载适合你的架构的正确的rustup安装程序。</li>
<li>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</li>
</ul>
<h3 id="windows-gnu-toolchain"><a class="header" href="#windows-gnu-toolchain">Windows (gnu toolchain)</a></h3>
<p>如果你没有msys2，点击这里安装 <a href="https://www.msys2.org/">msys2</a>。</p>
<ul>
<li>你可以通过pacman软件包管理器安装Rust工具链，或者通过前面所说的rustup（推荐）。注意，使用pacman安装需要显示指定你要使用gnu工具链（否则会默认安装MSVC工具链）。
你应该依据你电脑的架构安装合适的工具链。例如，64位设备应该安装x86_64-pc-windows-gnu工具链。
如果你决定通过软件包管理器安装Rust，请确保你得到的是mingw的变体，并且有正确的MINGW_PACKAGE_PREFIX（对于64位机器，这个环境变量相当于mingw-w64-x86_64）。</li>
<li>假设你通过pacman安装了东西，打开mingw shell（注意，这里不是msys2 shell，它可以在msys2安装目录下找到，或者通过<code>source shell mingw64</code>）并运行以下内容：
<pre><code>pacman -S curl tar git $MINGW_PACKAGE_PREFIX-rust $MINGW_PACKAGE_PREFIX-gcc $MINGW_PACKAGE_PREFIX-cmake $MINGW_PACKAGE_PREFIX-make --needed
</code></pre>
如果你打算使用ninja，可以用<code>$MINGW_PACKAGE_PREFIX-ninja</code>替换<code>$MINGW_PACKAGE_PREFIX-make</code>。</li>
<li>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</li>
</ul>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<ul>
<li>
<p>运行下列代码安装Xcode命令行工具（它带有C++编译器）：</p>
<pre><code> xcode-select --install
</code></pre>
<p>按照说明执行步骤。或者可以不用XCode，直接用Homebrew安装clang或gcc：</p>
</li>
<li>
<p>可以点击这里下载<a href="https://cmake.org/download/">CMake</a>。
或者，也可以跟上面一样使用Homebrew：</p>
<pre><code>brew install cmake
</code></pre>
</li>
<li>
<p>安装Rust Toolchain：</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>按照默认设置进行即可。</p>
</li>
<li>
<p>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</p>
</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>使用你的软件包管理器安装一个C++编译器，以及CMake，make，git。
以Debian/Ubuntu 为例：
<pre><code>sudo apt-get install g++ cmake git make
</code></pre>
</li>
<li>要使用FLTK的开发依赖项（dependencies-dev），你还可以使用软件包管理器。
对基于Debian的GUI发行版，运行下列代码：
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
对于基于RHEL的GUI发行版，运行下列代码：
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel
</code></pre>
对于基于Arch Linux的GUI发行版，运行下列代码：
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
对于Alpine linux：
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
</li>
<li>安装Rust Toolchain：
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
一切按默认即可。</li>
<li>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h1>
<h2 id="使用预编译包"><a class="header" href="#使用预编译包">使用预编译包</a></h2>
<p>如果你要为以下平台编译fltk程序的话，很幸运，它们已经有预编译包了：</p>
<ul>
<li>x86_64-pc-windows-gnu</li>
<li>x86_64-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
<li>aarch64-apple-darwin</li>
<li>x86_64-unknown-linux-gnu</li>
<li>aarch64-unknown-linux-gnu</li>
</ul>
<p>通过rustup设置目标平台（target），然后调用进行编译：</p>
<pre><code>rustup target add &lt;your target&gt; # 使用上列目标平台替换target
cargo build --target=&lt;your target&gt; --features=fltk-bundled
</code></pre>
<p>对于arch64-unknonw-linux-gnu，你可能需要指定链接器：</p>
<pre><code>CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu --features=fltk-bundled
</code></pre>
<p>你可以在 <code>.cargo/config.toml</code> （HOME下全局配置或在项目根目录下局部配置）中指定好链接器，这样你就不需要在命令中使用了：</p>
<pre><code># .cargo/config.toml
[target.aarch64-unknown-linux-gnu]
linker = &quot;aarch64-linux-gnu-gcc&quot;
</code></pre>
<p>之后便可以直接编译了：</p>
<pre><code>cargo build --target=aarch64-unknown-linux-gnu --features=fltk-bundled
</code></pre>
<h2 id="使用cross"><a class="header" href="#使用cross">使用cross</a></h2>
<p>如果你安装了docker，可以试试用 <a href="https://github.com/cross-rs/cross">cross</a>：</p>
<pre><code>cargo install cross
cross build --target=&lt;your target&gt;  # 使用你的target替换，cross build时Docker守护进程必须正在运行，不需要通过rustup添加target
</code></pre>
<p>如果你的target需要外部依赖项（比如在Linux上），你必须创建自定义Docker镜像，并经过如下步骤来进行交叉编译：</p>
<ol>
<li>
<p>设置<code>Cross.toml</code>文件。</p>
<p>例如，对一个有如下结构的项目来说：</p>
<pre><code>myapp
     |_src
     |    |_main.rs    
     |
     |_Cargo.toml
     |
     |_Cross.toml
     |
     |_arm64-dockerfile
</code></pre>
<p>arm64-dockerfile则是自定义的Docker镜像文件（名称并不重要，只要确保Cross.toml指向该文件）的内容：</p>
<pre><code class="language-dockerfile">FROM ghcr.io/cross-rs/aarch64-unknown-linux-gnu:edge

ENV DEBIAN_FRONTEND=noninteractive

RUN dpkg --add-architecture arm64 &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install --assume-yes --no-install-recommends \
    libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
    libxinerama-dev:arm64 libxcursor-dev:arm64 \
    libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
    libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64
</code></pre>
<p>注意库包名称后面的架构，如：libx11-dev:arm64。</p>
<p>Cross.toml的内容：</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
dockerfile = &quot;./arm64-dockerfile&quot;
</code></pre>
</li>
<li>
<p>配置<code>Cargo.toml</code>文件：</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
pre-build = [&quot;&quot;&quot; \
dpkg --add-architecture arm64 &amp;&amp; \
apt-get update &amp;&amp; \
apt-get install --assume-yes --no-install-recommends \
libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
libxinerama-dev:arm64 libxcursor-dev:arm64 \
libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64 \
&quot;&quot;&quot;]
</code></pre>
</li>
<li>
<p>运行cross：</p>
<pre><code>cross build --target=aarch64-unknown-linux-gnu
</code></pre>
<p>第一次运行可能会花较长时间</p>
</li>
</ol>
<h2 id="使用交叉编译-cc-toolchain"><a class="header" href="#使用交叉编译-cc-toolchain">使用交叉编译 C/C++ toolchain</a></h2>
<p>你需要有一个C/C++交叉编译器，还有设置好前面的方案中提到过的target，（通过<code>rustup target add</code>安装）。</p>
<p>对于Windows和MacOS，系统编译器已经可以向特定的target编译程序了。比如在MacOS上，如果你已经可以使用编译器编译fltk应用程序，你可以这样为其他平台编译（假设你有一个intel x86_64 mac）：</p>
<pre><code>rustup target add aarch64-apple-darwin
cargo build --target=arch64-apple-darwin
</code></pre>
<h3 id="linux-编译-64位windows"><a class="header" href="#linux-编译-64位windows">Linux 编译 64位Windows</a></h3>
<p>在你能够为自己的设备正确编译之后，如果你想在Linux上为64位Windows交叉编译应用程序：</p>
<ul>
<li>你需要使用下列命令添加Rust target：
<pre><code>rustup target add x86_64-pc-windows-gnu # 此时在arch上编译
</code></pre>
</li>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行部上，你可以运行：
<pre><code>apt-get install mingw-w64 # 或者 gcc-mingw-w64-x86-64
</code></pre>
在基于RHEL的发行部上：
<pre><code>dnf install mingw64-gcc
</code></pre>
在Arch上：
<pre><code>pacman -S mingw-w64-gcc
</code></pre>
在Alpine上：
<pre><code>apk add mingw-w64-gcc
</code></pre>
</li>
<li>在项目根目录添加<code>.cargo/config.toml</code> （如果你想全局设置的话，也可以修改HOME目录下的相应文件），并指定链接器和打包工具：
<pre><code class="language-toml"># .cargo/config.toml
[target.x86_64-pc-windows-gnu]
linker = &quot;x86_64-w64-mingw32-gcc&quot;
ar = &quot;x86_64-w64-mingw32-gcc-ar&quot;
</code></pre>
</li>
<li>运行build：
<pre><code>cargo build --target=x86_64-pc-windows-gnu
</code></pre>
</li>
</ul>
<h3 id="x64-linux-gnu-编译-aarch64-linux-gnu"><a class="header" href="#x64-linux-gnu-编译-aarch64-linux-gnu">x64 linux-gnu 编译 aarch64 linux-gnu</a></h3>
<p>另一个例子是，在基于x86_64 debian的发行版上为基于arm64 debian的发行版进行编译：
假设你已经安装了cmake：</p>
<ul>
<li>使用下列命令添加 rust target：
<pre><code>rustup target add aarch64-unknown-linux-gnu
</code></pre>
</li>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行版上，你可以运行：
<pre><code>apt-get install g++-aarch64-linux-gnu
</code></pre>
</li>
<li>为你的系统添加需要的架构：
<pre><code>sudo dpkg --add-architecture arm64
</code></pre>
</li>
<li>你可能需要将下列镜像添加到<code>/etc/apt/sources.list</code>以便下载：
<pre><code>sudo sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
</code></pre>
第一条命令改变当前镜像为该系统的 amd64 架构的镜像。其他命令则将 arm64 部分添加到 /etc/apt/sources.list 文件中。</li>
<li>更新程序清单：
<pre><code>sudo apt-get update
</code></pre>
</li>
<li>为目标平台安装需要的依赖：
<pre><code>sudo apt-get install libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
</code></pre>
注意，软件包名称中的<code>:arm64</code>后缀。</li>
<li>运行build：
<pre><code>CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
你可以在 <code>.cargo/config.toml</code> （HOME下全局配置或在项目根目录下局部配置）中指定好链接器，这样你就不需要在命令中使用了：
<pre><code># .cargo/config.toml
[target.aarch64-unknown-linux-gnu]
linker = &quot;aarch64-linux-gnu-gcc&quot;
</code></pre>
之后便可以运行：
<pre><code>cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
</li>
</ul>
<h2 id="使用docker"><a class="header" href="#使用docker">使用docker</a></h2>
<p>直接使用目标平台的docker镜像可以让你免去使用cross交叉编译到不同linux target的麻烦。
你需要一个Dockerfile，来拉取你需要的target，并安装Rust和C++工具链以及所需的依赖。
例如，为allpine linux构建：</p>
<pre><code class="language-dockerfile">FROM alpine:latest AS alpine_build
RUN apk add rust cargo git cmake make g++ pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
COPY . .
RUN cargo build --release

FROM scratch AS export-stage
COPY --from=alpine_build target/release/&lt;your binary name&gt; .
</code></pre>
<p>然后运行：</p>
<pre><code>DOCKER_BUILDKIT=1 docker build --file Dockerfile --output out .
</code></pre>
<p>你的二进制文件将生成在<code>./out</code>目录中。
注意在alpine上，如果你通过rustup安装Rust，你可能需要在你的dockerfile中让musl-gcc和musl-g++指向相应的工具链（运行<code>cargo build</code>之前）。</p>
<pre><code class="language-dockerfile">RUN ln -s /usr/bin/x86_64-alpine-linux-musl-gcc /usr/bin/musl-gcc
RUN ln -s /usr/bin/x86_64-alpine-linux-musl-g++ /usr/bin/musl-g++
</code></pre>
<p>由于Rust工具链的这个问题<a href="https://github.com/rust-lang/rust/issues/61328">Issue-61328</a>，你可能还在编译时需要添加<code>-C target-feature=-crt-static</code>这个环境变量。</p>
<p>另一个例子是在 amd64 linux-gnu 编译 arm64 linux-gnu 程序：</p>
<pre><code class="language-dockerfile">FROM ubuntu:20.04 AS ubuntu_build

ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update -qq
RUN	apt-get install -y --no-install-recommends lsb-release g++-aarch64-linux-gnu g++ cmake curl tar git make
RUN apt-get install -y ca-certificates &amp;&amp; update-ca-certificates --fresh &amp;&amp; export SSL_CERT_DIR=/etc/ssl/certs
RUN	dpkg --add-architecture arm64 
RUN sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN	apt-get update -qq &amp;&amp; apt-get install -y --no-install-recommends -o APT::Immediate-Configure=0 libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
RUN curl https://sh.rustup.rs -sSf | sh -s -- --default-toolchain stable --profile minimal -y

ENV PATH=&quot;/root/.cargo/bin:$PATH&quot; \
	CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ \
	CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \
    CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc \
    CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++ \
    PKG_CONFIG_PATH=&quot;/usr/lib/aarch64-linux-gnu/pkgconfig/:${PKG_CONFIG_PATH}&quot;

RUN rustup target add aarch64-unknown-linux-gnu

COPY . .

RUN  cargo build --release --target=aarch64-unknown-linux-gnu

FROM scratch AS export-stage
COPY --from=ubuntu_build target/aarch64-unknown-linux-gnu/release/&lt;your binary name&gt; .
</code></pre>
<h2 id="使用cmake文件"><a class="header" href="#使用cmake文件">使用CMake文件</a></h2>
<p>文件的路径可以传递给 CFLTK_TOOLCHAIN 环境变量：</p>
<pre><code>CFLTK_TOOLCHAIN=$(pwd)/toolchain.cmake cargo build --target=&lt;your target&gt;
</code></pre>
<p>在较新版本的 CMake（3.20 以上）中，可以直接设置 CMAKE_TOOLCHAIN_FILE 环境变量。</p>
<p>CMake 文件的内容通常是，设置 CMAKE_SYSTEM_NAME 以及交叉编译器。 在 Linux/BSD 上还需要设置 PKG_CONFIG_EXECUTABLE 和 PKG_CONFIG_PATH。一个示例：</p>
<pre><code class="language-cmake">set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm64)

set(triplet aarch64-linux-gnu)
set(CMAKE_C_COMPILER /usr/bin/${triplet}-gcc)
set(CMAKE_CXX_COMPILER /usr/bin/${triplet}-g++)
set(ENV{PKG_CONFIG_EXECUTABLE} /usr/bin/${triplet}-pkg-config)
set(ENV{PKG_CONFIG_PATH} &quot;$ENV{PKG_CONFIG_PATH}:/usr/lib/${triplet}/pkgconfig&quot;)

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

</code></pre>
<p>注意 CMAKE_SYSTEM_PROCESSOR 通常是目标平台上 uname -m 的值，其他可能的值参见<a href="https://stackoverflow.com/questions/70475665/what-are-the-possible-values-of-cmake-system-processor/70498851#70498851">Possible Values</a>。 我们将此示例中的<code>triplet</code>变量设置为 aarch64-linux-gnu，这是用于 gcc/g++ 编译器以及 pkg-config 的前缀。 这个<code>triplet</code>也等同于 Rust <code>triplet</code> aarch64-unknown-linux-gnu。 PKG_CONFIG_PATH 设置为包含我们target的 <code>.pc</code> 文件的目录，这些是 Linux/BSD 上的 cairo 和 pango 依赖项所必需的。 最后 4 个选项可以防止CMake混淆host/taregt（当前机器和交叉编译的目标机器）的include/library的路径。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluid"><a class="header" href="#fluid">Fluid</a></h1>
<p>FLTK提供了一个名为FLUID的，所见即所得的快速GUI程序开发工具，它可以方便地编写GUI程序。
目前在Youtube上有一个教你基于Rust使用它的视频教程：
<a href="https://www.youtube.com/watch?v=k_P0wG3-dNk">Use FLUID (RAD tool) with Rust</a></p>
<p>fl2rust crate将Fluid生成的.fl文件转换成Rust代码，并编译进你的程序中。
要获取更多详细信息，请查看它的官方<a href="https://github.com/MoAlyousef/fl2rust">仓库</a>。</p>
<p>你可以使用cargo install 安装 fltk-fluid 和 fl2rust crate 来使用FLUID。</p>
<pre><code>cargo install fltk-fluid
cargo install fl2rust
</code></pre>
<p>然后运行：</p>
<pre><code>fluid &amp;
</code></pre>
<p>你也可以通过使用包管理器获取Fluid，这样的话它将作为一个单独的程序或者是fltk程序的一部分安装到你的系统中。</p>
<p>目前，fl2rust并不能确保生成的Rust代码的正确性。它的使用也只限于构造方法。</p>
<h2 id="用法-1"><a class="header" href="#用法-1">用法</a></h2>
<p>为了演示用法，我们使用<code>cargo new app</code>创建一个新的Rust项目。
fl2rust将作为 <code>build-dependdencies</code> 添加到你的项目中：</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
fltk = &quot;1&quot;

[build-dependencies]
fl2rust = &quot;0.4&quot;
</code></pre>
<p>然后在编译文件build.rs（该文件会在编译Rust程序时运行）中调用它提供的方法来将<code>.fl</code>文件转换成Rust代码。</p>
<pre><pre class="playground"><code class="language-rust edition2018">// build.rs
fn main() {
    use std::path::PathBuf;
    use std::env;
    println!(&quot;cargo:rerun-if-changed=src/myuifile.fl&quot;);
    let g = fl2rust::Generator::default();
    let out_path = PathBuf::from(env::var(&quot;OUT_DIR&quot;).unwrap());
    g.in_out(&quot;src/myuifile.fl&quot;, out_path.join(&quot;myuifile.rs&quot;).to_str().unwrap()).expect(&quot;Failed to generate rust from fl file!&quot;);
}
</code></pre></pre>
<p>我们在src目录下创建一个fluid文件 <code>myuifile.fl</code>。我们通过<code>println!</code>中的指令告诉Cargo，如果文件发生改变就重新运行脚本。这里的文件名和目录是为了演示而设置的，你可以自己选择目录，以及输入和输出的文件名。这里我们将<code>myuifile.fl</code>文件转换成<code>myuifile.rs</code>，它生成在<code>OUT_DIR</code>中，因此我们不会在<code>src</code>目录下看到它。
为了可以使用转换后的文件，你需要在<code>src</code>目录创建一个与上述的输出文件同名的文件：</p>
<pre><code>touch src/myuifile.rs
</code></pre>
<p>然后使用 <code>include</code> 宏，载入生成的文件中的内容。</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/myuifile.rs
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(clippy::needless_update)]

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/myuifile.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>最后我们就可以在<code>main.rs</code>中使用这些内容了：</p>
<pre><pre class="playground"><code class="language-rust edition2018">// src/main.rs
use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>现在到了gui的编写部分，打开fluid：</p>
<pre><code class="language-bash">fltk-fluid &amp; # 如果从包管理器安装，只需要运行 fluid
</code></pre>
<p><code>&amp;</code>使终端将它作为一个独立的进程打开，所以我们仍然可以使用终端来使用cargo编译我们的代码，或者你可以打开另一个终端。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146925955-ac778726-1398-4ea2-8e46-a2f8fff89804.png" alt="image" /></p>
<p>我们看到的是一个空窗口和一个菜单栏。编写程序的第一步是创建一个类：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926284-cd9f21ce-b4b1-4009-9766-32876a08de98.png" alt="image" /></p>
<p>现在会弹出一个对话框，我们直接点击 &quot;OK &quot;让它使用默认的名称（UserInterface）。现在你会看到我们刚才创建的类出现在下面的列表中：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926505-545f26c1-ac7d-4f10-94a9-2d0c16875d4e.png" alt="image" /></p>
<p>接下来，再次点击new，为这个类添加一个构造函数：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926749-9199bd23-0346-4286-993f-bfb7588ae420.png" alt="image" /></p>
<p>同样使用它的默认名称，即<code>make_window()</code>。</p>
<p>接下来我们添加一个窗口：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926970-769ad7a1-9d03-457a-91f7-d6a18e2ba3b0.png" alt="image" /></p>
<p>现在出现了一个新的窗口，我们可以拖动边框放大它：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927099-ff014e0d-8ea0-4f90-a500-882eb7b49bb2.png" alt="image" /></p>
<p>双击窗口，这会弹出一个对话框，可以用来设置窗口的gui属性（在GUI标签下）、风格（在Style标签下）和类属性（在C++标签下）。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927520-c2ee18b1-0d17-43cd-93eb-edbf725ddf6c.png" alt="image" /></p>
<p>我们在GUI标签中给这个窗口设置<code>My Window</code>标签 ，然后在Style标签中把颜色改为白色：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932899-6a4419ae-9c91-4b48-a363-d87c85b01778.png" alt="image" /></p>
<p>在C++标签下，我们为这个窗口变量起个名字，<code>my_win</code>。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932794-7e1a2819-842d-45c7-88c8-be9fb728e805.png" alt="image" /></p>
<p>现在，可以通过<code>myuifile::UserInterface::my_win</code>访问窗口了。</p>
<p>之后，用鼠标左键点击窗口，然后添加一个Button（按钮）：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928089-ad0454de-252e-4e81-9079-db0ef5c67c8f.png" alt="image" /></p>
<p>这次我们选择Button。在C++标签下，我们为这个按钮变量起一个名字，<code>btn</code>。在style下，改变按钮的颜色和标签的颜色。然后在GUI下，把它的标签（按钮显示的文字） &quot;click me&quot;。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928419-a1a96e03-5b90-4aaa-8f70-9b17f76f9b9f.png" alt="image" /></p>
<p>可以拖动边框来调整大小，拖动按钮来改变它的位置。Fluid有一个Layout菜单，可以用它修改一组小部件（例如有很多按钮的情况），使其具有相同的布局/大小...等。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928654-43838e2a-aba8-4a24-8d70-1e25e1717c58.png" alt="image" /></p>
<p>现在点击<code>File/Save As...</code>将文件保存在src目录下，命名为<code>myuifile.fl</code>。</p>
<p>可以运行<code>cargo run</code>来看看能不能编译通过，但我们还没有调用<code>make_window()</code>方法，所以暂时还不会看到任何东西。
现在修改 src/main.rs 来让窗口可以显示出来，并为我们的按钮添加一个点击回调事件（callback）。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    let mut ui = myuifile::UserInterface::make_window();
    let mut win = ui.my_win.clone();
    ui.btn.set_callback(move |b| {
        b.set_label(&quot;clicked&quot;);
        win.set_label(&quot;Button clicked&quot;);
        println!(&quot;Works!&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-结构"><a class="header" href="#app-结构">App 结构</a></h1>
<p>Fltk crate的app模块中有一个App结构体。初始化App结构体，将会初始化所有内部样式、字体和支持的图像类型。它还会初始化程序将要在其中运行的多线程环境。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>run方法将会启动gui程序的事件循环（event loop）。
如果要对事件进行细粒度控制，可以使用wait()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default();
    while app.wait() {
        // 处理事件
    }
}
</code></pre></pre>
<p>此外，可以在App的实例上使用<code>with_scheme()</code>来设置程序的全局主题：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    app.run().unwrap();
}
</code></pre></pre>
<p>这将你的程序的主题设置为GTK。还有其他的内置主题方案，Basic、Plastic和Gleam（有一个<code>fltk-theme crate</code>提供了更多主题，你也可以自定义主题让它看起来更好看(^ο^)）。</p>
<p>还可以在App的实例上调用<code>load_system_fonts()</code>方法，让程序在启动时加载系统字体。</p>
<p>一个典型的fltk-rs程序将在创建任何组件并显示窗口之前创建App结构体。</p>
<p>任何写在调用<code>run()</code>方法后的代码，将在事件循环结束后执行（通常是关闭程序的所有窗口时，或者调用<code>quit()</code>方法时）。这包括必要时重启程序的指令等。</p>
<p>除了App结构体外，<code>app</code>模块本身还包含与你的程序的全局状态有关的结构体和自由函数。其中包括设置背景色和前景色，以及默认字体和大小等视觉效果，还有屏幕功能、剪贴板功能、全局事件处理器、程序事件、通道（发送器和接收器）和超时等。</p>
<p>其中一些将在本书的其他部分讨论。</p>
<pre><code>原文名词对照：
自由函数 - free functions
屏幕，剪切板功能 - screen functions, clipboard functions
全局事件处理器 - global handler
程序事件 - app events
通道，发送器和接收器 - channels, sender and receiver
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="窗口-windows"><a class="header" href="#窗口-windows">窗口 Windows</a></h1>
<p>FLTK在它支持的系统平台上调用原生窗口，然后基本上是自己绘制图形界面的。它会在windows上调用<code>HWND</code>，在MacOS上调用<code>NSWindow</code>，在X11系统（linux, BSD）上调用<code>XWindow</code>。</p>
<p>Window 与FLTK的其他组件具有相同的接口，<code>WidgetExt trait</code>。这将在下一节讨论。</p>
<p>让我们用到目前为止学到的东西来创建一个Window。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937363-f82ffa80-3503-11eb-8f3a-9afe34bdad59.jpg" alt="img1" /></p>
<p>调用<code>new()</code>方法需要五个参数：</p>
<ul>
<li><code>x</code> 从电脑屏幕最左侧开始计算的水平距离。</li>
<li><code>y</code> 从电脑屏幕最上侧开始计算的垂直距离。</li>
<li><code>width</code> Window的宽度。</li>
<li><code>height</code> Window的高度。</li>
<li><code>title</code> Window的标题。</li>
</ul>
<p>这里还调用了<code>end()</code>方法。<code>GroupExt Trait</code>定义了<code>begin()</code>方法和<code>end()</code>方法，Window以及其他实现了该Trait的组件，将<strong>持有</strong>任何在<code>begin()</code>和<code>end()</code>方法间创建的组件（通过<code>new()</code>创建Window时，隐式调用了<code>begin()</code>），或者成为这些组件的父组件。
调用<code>show()</code>会让Window出现在屏幕上。</p>
<p>Window可以被嵌入到其他Window内：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut my_window2 = window::Window::new(10, 10, 380, 280, &quot;&quot;);
    my_window2.set_color(Color::Black);
    my_window2.end();
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937446-139b0580-3504-11eb-8738-1e4161175d0b.jpg" alt="embed" /></p>
<p>在这里创建了第二个窗口<code>my_window2</code>，它会被嵌入到第一个窗口<code>my_window</code>里面。我们把它的颜色设为黑色，这样我们才能注意到它。注意，它的父组件是第一个Window。在父窗口外创建第2个窗口才会创建出两个独立的窗口，需要注意每个窗口都需要调用<code>show()</code>方法才会显示：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();
    let mut my_window2 = window::Window::new(10, 10, 380, 280, &quot;&quot;);
    my_window2.end();
    my_window2.show();
    app.run().unwrap();
}
</code></pre></pre>
<p>可以使用<code>my_window.set_border(false)</code>方法取消<code>my_window</code>的边框，实现无边框窗口：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937639-565cdd80-3504-11eb-8cf6-e135243c38b0.png" alt="image" /></p>
<p><code>set_border(bool)</code>方法也定义在<code>WindowExt trait</code>中，除了直线了<code>WidgetExt Trait</code>和<code>GroupExt Trait</code>的组件外（实现WindowExt需要实现GroupExt，实现GroupExt需要实现WidgetExt），FLTK中的所有窗口类型都实现了该Trait。
所有的Trait可以在fltk crate的<code>fltk::prelude</code>模块中找到：</p>
<p><a href="https://docs.rs/fltk/*/fltk/prelude/index.html">FLTK Trait文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组件-widgets"><a class="header" href="#组件-widgets">组件 Widgets</a></h1>
<p>FLTK提供了80多个组件。这些组件都实现了<code>WidgetBase</code>和<code>WidgetExt</code>组成的基本集合。 我们已经见过了我们的第一个组件，Window组件。
正如我们在Window组件中了解的，基于功能的不同，不同的组件还会各自实现其他Trait。
在我们之前写的例子中添加一个按钮：</p>
<pre><pre class="playground"><code class="language-rust edition2018">uuse fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937814-adfb4900-3504-11eb-8a6b-f42a4fb4e470.png" alt="image" /></p>
<p>注意，这个按钮的父组件是my_window，因为它是在隐式调用的<code>begin()</code>和<code>end()</code>之间创建的。
在程序中添加组件的另一种方法是，在实现了<code>GroupExt Trait</code>的Widget上调用该Trait提供的<code>add(widget)</code>方法。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();

    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.add(&amp;but);

    app.run().unwrap();
}
</code></pre></pre>
<p>需要注意一下按钮的初始化方式，它的构造方法基本上与Window相同，因为<code>new()</code>方法是定义在<code>WidgetBase trait</code>中的，而大部分组件都实现了这个Trait。注意，虽然Window的x和y坐标是相对于屏幕而言的，但按钮的x和y坐标却是相对于作为按钮父组件的的Window而言的。你可能已经注意到了这一点，这也适用于我们在上一节中提到的嵌入在另一个窗口中的窗口。</p>
<p>Button组件也实现了<code>ButtonExt trait</code>，它定义了一些有用的方法，比如设置快捷键<code>Shortcut</code>来通过其他方法触发我们的按钮。</p>
<p>也可以使用构建器模式来创建一个组件：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let but1 = Button::new(10, 10, 80, 40, &quot;Button 1&quot;);
// 下面为构建器模式
let but1 = Button::default()
    .with_pos(10, 10)
    .with_size(80, 40)
    .with_label(&quot;Button 1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>它们的效果基本是相同的。</p>
<p>目前位置，我们的程序会显示一个窗口和其中的按钮。这个按钮可以点击，但什么用都没有！但别担心，在下一节中，我们将学习为它添加一些行为（Actions）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="按钮-buttons"><a class="header" href="#按钮-buttons">按钮 Buttons</a></h1>
<p>Button组件的用处很多，它有多种形式：</p>
<ul>
<li>Button</li>
<li>RadioButton</li>
<li>ToggleButton</li>
<li>RoundButton</li>
<li>CheckButton</li>
<li>LightButton</li>
<li>RepeatButton</li>
<li>RadioLightButton</li>
<li>RadioRoundButton</li>
</ul>
<p>这些组件可以在 <code>Button mod</code> 中找到。
其中最简单的就是<code>Button</code>组件，它能在发生点击事件时执行一些行为。当然所有的按钮都可以这样：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();

}
</code></pre></pre>
<p>其他一些按钮可以带有表示自己某些属性的其他值：
例如<code>CheckButton</code>, <code>ToggleButton</code>, <code>LightButton</code> 带有表示它们当前状态（比如，是否被选中）的信息。</p>
<p>单选按钮（RadioRoundButton、RadioLightButton和RadioButton）也带有它们的一些值，但在父组件（任何实现GroupExt的组件都可以作为父组件）中只有一个可以被选中。因此说，这些组件是可以访问到同一个组合中其他相应组件的值的：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    // 用户同一时间只能选中一个按钮，选中后，另一个会被取消选中
    let btn1 = button::RadioRoundButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::RadioRoundButton::default().with_label(&quot;Option 2&quot;); 
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>可以用<code>clear_visible_focus()</code>方法来取消焦点（<code>btn1.clear_visible_focus()</code>）</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727291-8be40de6-8ec6-4e57-bb29-fa0f0ac3b251.png" alt="image" /></p>
<p>其他可选择的按钮没有这个属性。</p>
<p><code>ButtonExt::value()</code>方法会返回一个布尔值，表示一个按钮是否被选中：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn2 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><code>CheckButton</code>还提供了一个方便的方法<code>is_checked()</code>，一系列<code>RadioButton</code>提供了<code>is_toggled()</code>用来判断：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727325-7e5bb45f-674e-4bb2-81c8-27d0ee391d34.png" alt="image" /></p>
<p>默认情况下，可选择的按钮在创建时都是没有选中的，但这可以用<code>set_value()</code>，（<code>CheckButton</code>可以使用的）<code>set_checked()</code>和（RadioButton可以使用的）<code>set_toggled()</code>等方法来默认选中一个按钮：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let mut btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    btn1.set_value(true);
    // 同样可以使用 btn1.set_checked(true)
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn2 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727352-bf6dba5c-1a0c-4da4-8296-093e10470f0c.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标签-labels"><a class="header" href="#标签-labels">标签 Labels</a></h1>
<p>FLTK没有可以用来显示文字的Label组件，但很多组件都具有Label属性。如果你想显示文本的话，你可以使用一个<code>Frame</code>组件，然后为它添加Label属性。</p>
<p>所有组件都可以使用<code>::new()</code>构造函数来创建并设置Label，或者也可以用<code>with_label()</code>或<code>set_label()</code>来设置。</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::new(160, 200, 80, 30, &quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>这个按钮上带有 &quot;Click&quot; 文字。</p>
<p>我们也可以使用<code>set_label()</code>或<code>with_label()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::default().with_label(&quot;Click&quot;);
// 或者
let mut btn = button::Button::default();
btn.set_label(&quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>然而，使用<code>::new()</code>方法来添加Label属性，需要的字符串是类型<code>&amp;'static str</code>，所以下面的代码不能正确运行：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let label = String::from(&quot;Click&quot;);  // label变量不是 &amp;'static str
let mut btn = button::Button::new(160, 200, 80, 30, &amp;label);
<span class="boring">}
</span></code></pre></pre>
<p>在这种情况下，你应该使用<code>btn.set_label(&amp;label);</code>。原因是FLTK本身要求传入的字符串是类型是<code>const char *</code> ，对应于Rust中则是<code>&amp;'static str</code>。这些字符串保存在程序的二进制代码中。如果你反汇编一个程序，是可以看到这些字符串的。这些字符串具有静态生命周期，因此FLTK在创建组件Label时默认不会保存下这些字符串。而当使用<code>set_label()</code>和<code>with_label()</code>时，FLTK将调用<code>Fl_Widget::copy_label()</code>，并将字符串进行存储。</p>
<p>Label不限于文字，FLTK预定义了一些符号，在Label中可以转换成图像。</p>
<p><img src="https://www.fltk.org/doc-1.4/symbols.png" alt="symbols" /></p>
<p><code>@</code>符号除了可以用来使用这些符号图像外，还可以加上下面这些格式化字符，其顺序和规则如下：</p>
<ul>
<li>'#'表示强制进行规则的缩放，因此可以避免组件的形状被扭曲。</li>
<li>+[1-9]或-[1-9]可以改变缩放比例。</li>
<li>'$'是水平翻转符号，'%'是垂直翻转符号。</li>
<li>[0-9] - 旋转45度的倍数。是'5'和'6'时不会发生旋转，而其他数字则会使其指向数字键盘上那个键的方向。</li>
<li>'0xxxx'，0后有四个数字表示角度，会使其按该度数旋转。</li>
</ul>
<p>因此，如果要显示一个非常大的指向下方的箭头，你可以使用标签字符串&quot;@+92-&gt;&quot;。</p>
<p>符号和文本可以结合在一个Label中，但是符号必须放在文本的开头或结尾处。如果有多行文本，那么符号将被按比例放大以匹配所有行的高度：</p>
<p><img src="https://www.fltk.org/doc-1.4/symbol-examples.png" alt="ex" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组控件-group-widgets"><a class="header" href="#组控件-group-widgets">组控件 Group widgets</a></h1>
<p>组控件包括窗口类型和在<code>Group</code> mod中的其他组件，如：Group，Scroll，Pack，Tile，Flex ...等等。
它们都实现了<code>GroupExt Trait</code>，该Trait中定义了<code>end()</code>方法，这些控件必须调用<code>::end()</code>方法来表示其包含的范围结束：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>在上面的例子中，按钮 &quot;_btn&quot; 的父组件是Window。
在组控件调用<code>end()</code>后创建的其他组件将不被包含在该控件中，即会创建在这个组控件的外面。
但这些组件仍然可以使用<code>::add(&amp;other_widget)</code>或<code>::insert</code>添加进组控件中。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    let btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.add(&amp;btn);
    
    a.run().unwrap();
}
</code></pre></pre>
<p>另一个选择是重新调用组控件的<code>begin()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.begin();
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();

    a.run().unwrap();
}
</code></pre></pre>
<p>多数实现<code>GroupExt</code>的组控件需要手动布局，但还有几个控件可以自动布局。比如<code>Flex</code>组件，它会在 <a href="Layouts.html">布局 layout</a> 中介绍。<code>Pack</code>需要设置子组件的高度（height）或宽度（width）进行布局，这取决于Pack是垂直的还是水平的。</p>
<p>Pack默认是垂直的（Vertical），我们只需要设置其中子组件的高度：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(200, 300);
    let mut pack = group::Pack::default_fill();
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(0, 40).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(0, 40);
    }
    frame::Frame::default().with_size(0, 40); // 占位
    button::Button::default().with_size(0, 40).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727469-a7181ebf-a3a3-4675-af23-ec40d847a593.png" alt="image" /></p>
<p>要设置水平（horizontal）的Pack，我们需要手动设置<code>with_type()</code>，然后只需要设置其中子组件的宽度：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(300, 100);
    let mut pack = group::Pack::default_fill().with_type(group::PackType::Horizontal);
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(40, 0).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(40, 0);
    }
    frame::Frame::default().with_size(40, 0); // 占位
    button::Button::default().with_size(40, 0).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="菜单-menus"><a class="header" href="#菜单-menus">菜单 Menus</a></h1>
<p>FLTK提供了菜单组件，它们均实现了<code>MenuExt trait</code>。Menu组件有下面这几种：</p>
<ul>
<li>MenuBar</li>
<li>MenuItem</li>
<li>Choice (下拉列表)</li>
<li>SysMenuBar (在MacOS出现在屏幕顶部的menu bar)</li>
</ul>
<p>Menu主要有两方面的作用：</p>
<ol>
<li>
<p>使用<code>add_choice()</code>方法添加菜单选项，然后在设置回调处理不同选项执行的操作：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1&quot;);
    choice.add_choice(&quot;Choice 2&quot;);
    choice.add_choice(&quot;Choice 3&quot;);
    // 也可以直接输入 choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        match c.value() {
            0 =&gt; println!(&quot;choice 1 selected&quot;),
            1 =&gt; println!(&quot;choice 2 selected&quot;),
            2 =&gt; println!(&quot;choice 3 selected&quot;),
            _ =&gt; unreachable!(),
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/37966791/145727397-dd713782-9f8e-474b-b009-f2ebeb5170ea.png" alt="image" /></p>
<p>另外，你也可以解构出菜单选项的字符串来进行匹配：</p>
<pre><code>```rust
use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        if let Some(choice) = c.choice() {
            match choice.as_str() {
                &quot;Choice 1&quot; =&gt; println!(&quot;choice 1 selected&quot;),
                &quot;Choice 2&quot; =&gt; println!(&quot;choice 2 selected&quot;),
                &quot;Choice 3&quot; =&gt; println!(&quot;choice 3 selected&quot;),
                _ =&gt; unreachable!(),
            }
        }
    });

    app.run().unwrap();
}
```
</code></pre>
<ol start="2">
<li>
<p>通过<code>add()</code>方法添加菜单选项，你需要在其中设置好每个选项的回调：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()

    choice.add(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 1 selected&quot;),
        );
    choice.add(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 2 selected&quot;),
        );
    choice.add(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 3 selected&quot;),
        );

    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>另外在 <a href="Events">事件 Events</a> 还会提到，你可以直接传递一个函数而不适用闭包：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn menu_cb(m: &amp;mut impl MenuExt) {
    if let Some(choice) = m.choice() {
        match choice.as_str() {
            &quot;New\t&quot; =&gt; println!(&quot;New&quot;),
            &quot;Open\t&quot; =&gt; println!(&quot;Open&quot;),
            &quot;Third&quot; =&gt; println!(&quot;Third&quot;),
            &quot;Quit\t&quot; =&gt; {
                println!(&quot;Quitting&quot;);
                app::quit();
            },
            _ =&gt; println!(&quot;{}&quot;, choice),
        }
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut menubar = menu::MenuBar::new(0, 0, 400, 40, &quot;rew&quot;);
    menubar.add(&quot;File/New\t&quot;, Shortcut::None, menu::MenuFlag::Normal, menu_cb);
    menubar.add(
        &quot;File/Open\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let idx = menubar.add(
        &quot;File/Recent&quot;,
        Shortcut::None,
        menu::MenuFlag::Submenu,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/First\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/Second\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Quit\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let mut btn1 = button::Button::new(160, 150, 80, 30, &quot;Modify 1&quot;);
    let mut btn2 = button::Button::new(160, 200, 80, 30, &quot;Modify 2&quot;);
    let mut clear = button::Button::new(160, 250, 80, 30, &quot;Clear&quot;);
    win.end();
    win.show();

    btn1.set_callback({
        let menubar = menubar.clone();
        move |_| {
            if let Some(mut item) = menubar.find_item(&quot;File/Recent&quot;) {
                item.add(
                    &quot;Recent/Third&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
                item.add(
                    &quot;Recent/Fourth&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
            }
        }
    });

    btn2.set_callback({
        let mut menubar = menubar.clone();
        move |_| {
            menubar.add(
                &quot;File/Recent/Fifth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
            menubar.add(
                &quot;File/Recent/Sixth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
        }
    });

    clear.set_callback(move |_| {
        menubar.clear_submenu(idx).unwrap();
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>此外，你还可以使用<code>add_emit()</code>方法来传递一个<code>sender</code>和一个<code>message</code>，这样就不用直接使用回调，而是可以集中在<code>App::wait()</code>中处理：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

#[derive(Clone)]
enum Message {
    Choice1,
    Choice2,
    Choice3,
}

fn main() {
    let a = app::App::default();
    let (s, r) = app::channel();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label(&quot;Select item&quot;);

    choice.add_emit(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice1,
    );
    choice.add_emit(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice2,
    );
    choice.add_emit(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s,
        Message::Choice3,
    );

    wind.end();
    wind.show();

    while a.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                Message::Choice1 =&gt; println!(&quot;choice 1 selected&quot;),
                Message::Choice2 =&gt; println!(&quot;choice 2 selected&quot;),
                Message::Choice3 =&gt; println!(&quot;choice 3 selected&quot;),
            }
        }
    }
}
</code></pre></pre>
</li>
</ol>
<p>你可能会问，为什么不直接用第一个例子那样简单的代码，还要使用其他更复杂的方式完成回调方法。其实每种方法都有它的用途。
对于简单的<strong>下拉菜单</strong>，用第一种方法会更加方便。对于程序的<strong>菜单栏</strong>，用第二种方法会更好，它可以让你为菜单选项设置快捷键<code>Shortcuts</code>和选项的类型<code>MenuFlags</code>（例如下拉菜单，选择选项，用于分隔的占位菜单等），另外你不用再像第一个例子一样，在菜单的回调中处理所有事件。使用<code>add_emit()</code>方法处理子菜单一样很容易，就像在<a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/editor.rs">编辑器示例</a>中那样：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut menu = menu::SysMenuBar::default().with_size(800, 35);
    menu.set_frame(FrameType::FlatBox);
    menu.add_emit(
        &quot;&amp;File/New...\t&quot;,
        Shortcut::Ctrl | 'n',
        menu::MenuFlag::Normal,
        *s,
        Message::New,
    );

    menu.add_emit(
        &quot;&amp;File/Open...\t&quot;,
        Shortcut::Ctrl | 'o',
        menu::MenuFlag::Normal,
        *s,
        Message::Open,
    );

    menu.add_emit(
        &quot;&amp;File/Save\t&quot;,
        Shortcut::Ctrl | 's',
        menu::MenuFlag::Normal,
        *s,
        Message::Save,
    );

    menu.add_emit(
        &quot;&amp;File/Save as...\t&quot;,
        Shortcut::Ctrl | 'w',
        menu::MenuFlag::Normal,
        *s,
        Message::SaveAs,
    );

    menu.add_emit(
        &quot;&amp;File/Print...\t&quot;,
        Shortcut::Ctrl | 'p',
        menu::MenuFlag::MenuDivider,
        *s,
        Message::Print,
    );

    menu.add_emit(
        &quot;&amp;File/Quit\t&quot;,
        Shortcut::Ctrl | 'q',
        menu::MenuFlag::Normal,
        *s,
        Message::Quit,
    );

    menu.add_emit(
        &quot;&amp;Edit/Cut\t&quot;,
        Shortcut::Ctrl | 'x',
        menu::MenuFlag::Normal,
        *s,
        Message::Cut,
    );

    menu.add_emit(
        &quot;&amp;Edit/Copy\t&quot;,
        Shortcut::Ctrl | 'c',
        menu::MenuFlag::Normal,
        *s,
        Message::Copy,
    );

    menu.add_emit(
        &quot;&amp;Edit/Paste\t&quot;,
        Shortcut::Ctrl | 'v',
        menu::MenuFlag::Normal,
        *s,
        Message::Paste,
    );

    menu.add_emit(
        &quot;&amp;Help/About\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        *s,
        Message::About,
    );

    if let Some(mut item) = menu.find_item(&quot;&amp;File/Quit\t&quot;) {
        item.set_label_color(Color::Red);
    }
<span class="boring">}
</span></code></pre></pre>
<p>注意最后一个调用，它使用<code>find_item()</code>方法，在菜单中匹配到符合的选项，然后把它的Label颜色设为红色：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727434-d66c6d55-018d-4341-9570-7c2864b5bf29.png" alt="image" /></p>
<h2 id="系统菜单栏"><a class="header" href="#系统菜单栏">系统菜单栏</a></h2>
<p>在MacOS上，你可能更喜欢使用系统提供的菜单栏，它通常出现在屏幕的顶部。为此可以使用<code>SysMenuBar</code>组件。它与所有实现<code>MenuExt Trait</code>的组件具有相同的API，当程序为MacOS以外的其他目标平台编译时，该组件将变为一个普通的<code>MenuBar</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出-input--output"><a class="header" href="#输入输出-input--output">输入输出 Input &amp; Output</a></h1>
<p>FLTK提供的输入/输出组件均实现了<code>InputExt trait</code>。在<code>Input</code>和<code>Output</code> mod中可以找到这些组件：</p>
<ul>
<li>Input</li>
<li>IntInput</li>
<li>FloatInput</li>
<li>MultilineInput</li>
<li>SecretInput</li>
<li>FileInput</li>
<li>Output</li>
<li>MultilineOutput</li>
</ul>
<p>实现了<code>InputExt trait</code>的组件都会携带一个文本值，对应用户输入的文本，可以用<code>value()</code>方法获得文本值，用<code>set_value()</code>方法修改文本值：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727249-2fa4d384-2bd3-41fd-bbae-61a3a33b12f6.png" alt="image" /></p>
<p>需要注意的是，我们使用了<code>IntInput</code>来限制用户只能输入整数值。虽然用户不能再输入字符了，但就开发者而言，<code>value()</code>获取到的文本值仍然是一个<code>String</code>。</p>
<p><code>Output</code>组件的值不能被用户修改，可以视作一个无法编辑的输入框：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(200, 50).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Check this text:&quot;);
    let mut output = output::Output::default();
    output.set_value(&quot;You can't edit this!&quot;);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727261-88ec533f-200b-4df7-a570-76ebd2ba520a.png" alt="image" /></p>
<p>也可以使用<code>InputExt::set_readonly(bool)</code>方法将<code>Input</code>组件设置为只读：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let mut input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
        input.set_readonly(true);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>这会在用户输入内容并按下按钮后让文本框不可修改。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="估值器-valuators"><a class="header" href="#估值器-valuators">估值器 Valuators</a></h1>
<p>FLTK提供的<code>Valuator</code>组件均实现了<code>ValuatorExt trait</code>。这些组件会在内部跟踪步长<code>step</code>，范围<code>range</code>和边界<code>bound</code>这些数据，你会在图形界面上看到它们的具体作用。
你可能在别的地方使用过<code>Scrollbar</code>和<code>Sliders</code>这些组件。可以在<code>Valuator</code> mod中找到这些组件：</p>
<ul>
<li>Slider</li>
<li>NiceSlider</li>
<li>ValueSlider</li>
<li>Dial</li>
<li>LineDial</li>
<li>Counter</li>
<li>Scrollbar</li>
<li>Roller</li>
<li>Adjuster</li>
<li>ValueInput</li>
<li>ValueOutput</li>
<li>FillSlider</li>
<li>FillDial</li>
<li>HorSlider (Horizontal slider)</li>
<li>HorFillSlider</li>
<li>HorNiceSlider</li>
<li>HorValueSlider</li>
</ul>
<p>在图形界面通过拖动等方式改变<code>Valuator</code>的值会触发其回调。<code>Valuator</code>的当前值可以通过<code>value()</code>方法来获取，可以用<code>set_value()</code>来设置其值。根据使用情况，你也可以获取和改变<code>range</code>和<code>step</code>的值：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut slider = valuator::HorNiceSlider::default().with_size(400, 20).center_of_parent();
    slider.set_minimum(0.);
    slider.set_maximum(100.);
    slider.set_step(1., 1); // 设置步长为10
    slider.set_value(50.); // 设置开始
    win.end();
    win.show();

    slider.set_callback(|s| {
        println!(&quot;slider at {}&quot;, s.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727188-4ac06d45-7fd1-44f7-9adc-366d9bb79d8f.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文字-text"><a class="header" href="#文字-text">文字 Text</a></h1>
<p><code>Text</code>组件实现了<code>DisplayExt trait</code>。FLTK提供了3个文字组件，可以在<code>text</code> mod中找到：</p>
<ul>
<li>TextDisplay</li>
<li>TextEditor</li>
<li>SimpleTerminal</li>
</ul>
<p>文本组件的主要作用是显示或编辑文本。前两个部件需要一个<code>TextBuffer</code>，<code>SimpleTerminal</code>内部有一个<code>TextBuffer</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf.clone());
    win.end();
    win.show();

    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727101-175fe355-1383-4789-ae40-2945ef0c63e2.png" alt="image" /></p>
<p>在文本组件上，对内容的操作多数是使用<code>TextBuffer</code>完成的。可以用<code>append()</code>来添加文本，也可以用<code>set_text()</code>来设置Buffer的内容。
你可以使用<code>DisplayExt::buffer()</code>方法得到Buffer的Clone（TextBuffer内部存储了一个对实际Buffer的可变指针引用），继而可以通过它来操作Buffer：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    win.end();
    win.show();

    let mut my_buf = txt.buffer().unwrap();

    my_buf.set_text(&quot;Hello world!&quot;);
    my_buf.append(&quot;\n&quot;);
    my_buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p><code>DisplayExt</code>定义了很多管理文本属性的方法，例如可以设置何时换行，光标位置，字体，颜色，大小等。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::Color, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    // 设置换行模式
    // 不同于 AtPixel 和 AtColumn, AtBounds不需要第二个参数
    // AtBounds 会设置文本到达输入框边界便会自动换行，对于大小可变的窗口很好用。
    txt.wrap_mode(text::WrapMode::AtBounds, 0);
    txt.set_text_color(Color::Red);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727121-8396c77e-836d-4406-abd1-92af32ff7242.png" alt="image" /></p>
<p><code>TextBuffer</code>还有第二个用途，它可以作为样式缓冲区（Style Buffer）。Style Buffer是你的Text Buffer的一个镜像，它使用样式表（包含字体、颜色和大小的配置）来为你的文本细粒度地设置样式，样式表中的样式本身是有索引的，具体说是使用相应的顺序字母作为索引：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Color, Font},
    prelude::*,
    *,
};

const STYLES: &amp;[text::StyleTableEntry] = &amp;[
    text::StyleTableEntry {
        color: Color::Green,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::Red,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::from_u32(0x8000ff),
        font: Font::Courier,
        size: 16,
    },
];

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    let mut sbuf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    // A是样式表中的第一个元素的索引，这里为“Hello world!”的每个字母应用A代表的样式
    sbuf.set_text(&amp;&quot;A&quot;.repeat(&quot;Hello world!&quot;.len())); 
    buf.append(&quot;\n&quot;); 
    // 虽然针对换行的样式可能并没有显示出来，但是这里还需要将其写上，以免弄乱之后的文字样式
    sbuf.append(&quot;B&quot;); 
    buf.append(&quot;This is a text editor!&quot;);
    sbuf.append(&amp;&quot;C&quot;.repeat(&quot;This is a text editor!&quot;.len()));

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default()
        .with_size(390, 290)
        .center_of_parent();
    txt.set_buffer(buf);
    txt.set_highlight_data(sbuf, STYLES.to_vec());
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727157-be992344-763d-41f9-b3d8-2dfa13fbaab1.png" alt="image" /></p>
<p><code>Terminal</code>的例子使用了<code>SimpleTerminal</code>和一个有样式的<code>TextBuffer</code>，点击这里查看这个例子 <a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/terminal.rs">Terminal</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅览器-browsers"><a class="header" href="#阅览器-browsers">阅览器 Browsers</a></h1>
<p><code>Browser</code>组件实现了<code>BrowserExt trait</code>，可以在<code>Browser</code> mod中找到以下类型的Browser：</p>
<ul>
<li>Browser</li>
<li>SelectBrowser</li>
<li>HoldBrowser</li>
<li>MultiBrowser</li>
<li>FileBrowser</li>
<li>CheckBrowser</li>
</ul>
<p>为了实例化一个阅览器，我们需要设置好每一项item的宽度，在<code>add()</code>方法中还需要使用分隔符来将每一个item分开：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    // 现在在我们的`add()`方法中可以使用'\t'来制表符
    b.add(&quot;USER\tPID\t%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    b.add(&quot;root\t2888\t0.0\t0.0\t1352\t0\ttty3\tSW\tAug15\t0:00\t@b@f/sbin/mingetty tty3&quot;);
    b.add(&quot;erco\t2889\t0.0\t13.0\t221352\t0\ttty3\tR\tAug15\t1:34\t@b@f/usr/local/bin/render a35 0004&quot;);
    b.add(&quot;uucp\t2892\t0.0\t0.0\t1352\t0\tttyS0\tSW\tAug15\t0:00\t@b@f/sbin/agetty -h 19200 ttyS0 vt100&quot;);
    b.add(&quot;root\t13115\t0.0\t0.0\t1352\t0\ttty2\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty2&quot;);
    b.add(
        &quot;root\t13464\t0.0\t0.0\t1352\t0\ttty1\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty1 --noclear&quot;,
    );
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733437-e3061015-12fa-4f2e-a1e3-01f59c4b189d.png" alt="image" /></p>
<p>可以使用<code>@</code>并在后面跟上格式化符来实现其他丰富的格式化效果：</p>
<ul>
<li>'@.' 打印其余行，且让剩余的'@'符号无效</li>
<li>'@@' 打印其余以'@'开头的行</li>
<li>'@l' 使用大号字体(24 point) </li>
<li>'@m' 使用中号字体(18 point)</li>
<li>'@s' 使用小号字体(11 point)</li>
<li>'@b' 使用宽字体(adds FL_BOLD to font)</li>
<li>'@i' 使用斜体(adds FL_ITALIC to font)</li>
<li>'@f' 或 '@t' 使用等距字体 (sets font to FL_COURIER)</li>
<li>'@c' 水平居中</li>
<li>'@r' 向右对齐文本</li>
<li>'@B0', '@B1', ... '@B255' 使用<code>fl_color(n)</code>填充背景</li>
<li>'@C0', '@C1', ... '@C255' 使用<code>fl_color(n)</code>渲染文本</li>
<li>'@F0', '@F1', ... 使用 <code>fl_font(n)</code> 渲染文本</li>
<li>'@S1', '@S2', ... 使用相应的尺寸来渲染文本</li>
<li>'@u' or '@_' 字体添加下划线</li>
<li>'@-' 字体中间添加修改线</li>
</ul>
<p>在下面的例子中，我们在<code>%CPU</code>前面加上<code>@C88</code>，将其渲染成红色：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    b.add(&quot;USER\tPID\t@C88%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733713-2fe3207d-25f7-4acd-ae91-754679c5696a.png" alt="图像 image" /></p>
<p>这些颜色表示遵循FLTK的色彩映射规则，可以从0到255进行索引。</p>
<p><img src="https://www.fltk.org/doc-1.4/fltk-colormap.png" alt="色彩映射 colormap" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树-trees"><a class="header" href="#树-trees">树 Trees</a></h1>
<p><code>Tree</code>组件可以实现元素按照的。你可能会想，它是不是定义在<code>TreeExt trait</code>中，哈哈哈，然而这里并没有。所有方法都是来自<code>Tree</code>结构体类型。可以使用<code>add()</code>方法为Tree添加元素：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726958-f1f2a095-39c5-496f-b772-18d024dd609d.png" alt="image" /></p>
<p>Item下还可以子Item，可以使用正斜线分隔符<code>/</code>来添加：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727026-bfcff44f-2b01-4679-937b-3e7d441dfdf0.png" alt="image" /></p>
<p>看过上面代码的例子，你会发现树的根标签总是 &quot;ROOT &quot;。可以通过<code>set_root_label()</code>方法来设置根标签：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_root_label(&quot;My Tree&quot;);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727045-a25be6bc-a514-4b4a-b7b9-0a7ee2e359b4.png" alt="image" /></p>
<p>还能调用<code>set_show_root(false)</code>方法来隐藏根标签。</p>
<p>可以使用<code>first_selected_item()</code>方法来获取被点击到的元素：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727072-8596cf09-100c-4cb6-a427-0d3c66702b39.png" alt="image" /></p>
<p>现在我们的Tree中的元素只能单选，让我们把它改成允许多选的树（这里我们也改变了元素之间连线的样式）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    // 设置Tree的选择模式为多选
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>现在的问题是，我们需要获取选择到的所有选项，而不只是第一个被选中的项目，这里我们使用<code>get_selected_items()</code>方法，该方法返回一个<code>Option&lt;Vec&gt;</code>。这里我们使用<code>item_pathname()</code>来获取Item在树中的路径。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(items) = t.get_selected_items() {
            for i in items {
                println!(&quot;{} selected&quot;, t.item_pathname(&amp;i).unwrap());
            }
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727000-4b881896-309d-465d-8305-9a7e0a92eaea.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表格-tables"><a class="header" href="#表格-tables">表格 Tables</a></h1>
<p>FLTK还提供了<code>Table</code>组件，Table的使用方法可以参见GitHub库中的例子<a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/table.rs">示例</a>。有个好处是，我们提供了<a href="https://crates.io/crates/fltk-table">fltk-table crate</a>，使用它的话我们可以写更少的样板代码，写出的界面也会更简单、直观。</p>
<pre><pre class="playground"><code class="language-rust edition2018">extern crate fltk_table;

use fltk::{
    app, enums,
    prelude::{GroupExt, WidgetExt},
    window,
};
use fltk_table::{SmartTable, TableOpts};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut wind = window::Window::default().with_size(800, 600);

    // 通过 TableOpts 结构体设置行和列
    let mut table = SmartTable::default()
    .with_size(790, 590)
    .center_of_parent()
    .with_opts(TableOpts {
        rows: 30,
        cols: 15,
        editable: true,
        ..Default::default()
    });
    
    wind.end();
    wind.show();

    // 用一些值填充表格
    for i in 0..30 {
        for j in 0..15 {
            table.set_cell_value(i, j, &amp;(i + j).to_string());
        }
    }

    // 把 第4行第5列 的表格设置为&quot;another&quot;, 需要注意索引是从0开始的
    table.set_cell_value(3, 4, &quot;another&quot;);

    assert_eq!(table.cell_value(3, 4), &quot;another&quot;);

    // 防止按 Esc键 时关闭窗口
    wind.set_callback(move |_| {
        if app::event() == enums::Event::Close {
            app.quit();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-table/raw/HEAD/screenshots/styled.jpg" alt="fltk-table" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义组件-custom-widgets"><a class="header" href="#自定义组件-custom-widgets">自定义组件 Custom widgets</a></h1>
<p>fltk-rs允许你创建自定义组件。我们需要定义一个<code>Struct</code>来作为自定义组件的类型，我们需要用一个已经存在的<code>Widget</code>和<code>widget type</code>来扩展它。最基本的<code>Widget type</code>是<code>widget::Widget</code>。</p>
<ol>
<li>
<p>定义你的<code>Struct</code>，以及它需要维护的内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<p>你会注意到两件事，我们正在使用一个<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>来存储我们需要用到的数据。在一般情况下这是没有必要的。但是，在它的回调方法被调用时它的所有权会被移动，为了在执行完一次回调之后仍能使用它，我们将把它包装在一个<code>Rc&lt;RefCell&lt;&gt;&gt;</code>中。这段代码中我们已经导入了必要的模块。</p>
<ol start="2">
<li>
<p>为组件实现方法。最重要的是要有构造函数，因为我们要通过它来初始化组件和内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyCustomButton {

    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { 
            // 我们需要实现绘制方法
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black);
            // 设置文字的颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; 
                // 使 num_clicks 在点击时递增
                i.do_callback(); 
                // 执行我们使用 set_callback() 设置的回调方法
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>在我们的自定义组件上应用<code>widget_extends！</code>宏，该宏需要传入我们的小组件，它扩展的基本类型，以及结构体中表示该基本类型的成员。这是通过实现<code>Deref Trait</code>和<code>DerefMut Trait</code>实现的。该宏还会自动为我们的自定义组件添加了其他函数和固定的方法（anchoring methods）：</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 通过宏扩展widget::Widget
widget_extends!(MyCustomButton, widget::Widget, inner);
<span class="boring">}
</span></code></pre></pre>
<p>现在来试一试我们的自定义组件：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // 设置白色背景
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    // 注意，set_color和set_callback是宏自动为我们实现了
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p>全部代码：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl MyCustomButton {

    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { 
            // 我们需要一个绘制的方法
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // 设置文字颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1;
                // 使 num_clicks 在点击时递增
                i.do_callback(); 
                // 执行我们使用 set_callback() 设置的回调方法
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}

// 通过宏扩展widget::Widget
widget_extends!(MyCustomButton, widget::Widget, inner);

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    // 设置背景为白色
    app::background(255, 255, 255);
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727718-fd0ee71f-f0c2-4438-a038-9b6950638a35.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对话框-dialogs"><a class="header" href="#对话框-dialogs">对话框 Dialogs</a></h1>
<p>fltk提供了几种对话框类型，有文件对话框和其他一些。</p>
<h2 id="文件对话框-file-dialogs"><a class="header" href="#文件对话框-file-dialogs">文件对话框 File dialogs</a></h2>
<p>有2种类型，原生文件对话框和FLTK自己的文件对话框。原生对话框只是显示操作系统自己的对话框。对于windows来说，那是win32对话框，对于MacOS来说，那是Cocoa对话框，而对于其他posix系统来说，取决于你正在运行什么。在GNOME和其他基于gtk的桌面上，它显示gtk对话框，在KDE上它显示kdialog。</p>
<h3 id="原生对话框-native-dialogs"><a class="header" href="#原生对话框-native-dialogs">原生对话框 Native dialogs</a></h3>
<p>唤起一个原生对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filename());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146625105-94b11a5d-0938-4962-96d1-aaff5424ffe8.png" alt="image" /></p>
<p>这将打印出所选文件的路径。有几种类型可以作为NativeFileChooserType被传递，这里我们浏览文件，你可以选择BrowseDir来代替，也可以启用多文件/目录选择。如果你选择了多个文件，你可以使用filenames()方法得到一个Vec：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select files&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>你也可以选择添加过滤器来有选择地选取文件：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.set_filter(&quot;*.{txt,rs,toml}&quot;);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });
<span class="boring">}
</span></code></pre></pre>
<p>这将只显示.txt、.rs和.toml文件。</p>
<h3 id="fltl提供的文件选择器-fltks-own-file-chooser"><a class="header" href="#fltl提供的文件选择器-fltks-own-file-chooser">FLTL提供的文件选择器 FLTK's own file chooser</a></h3>
<p>FLTK也提供了自己的文件选择器：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::FileChooser::new(
            /*start dir*/ &quot;.&quot;,
            /*pattern*/ &quot;*.{txt,rs,toml}&quot;,
            /*type*/ dialog::FileChooserType::Multi,
            /*title*/ &quot;Select file:&quot;,
        );
        dialog.show();
        while dialog.shown() {
            app::wait();
        }
        if dialog.count() &gt; 1 {
            for i in 1..=dialog.count() { // values start at 1
                println!(&quot; VALUE[{}]: '{}'&quot;, i, dialog.value(i).unwrap());
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726912-600e4c58-32b7-4a1b-8e6a-44e640549722.png" alt="image" /></p>
<p>用file_chooser()和dir_chooser()函数提供了一个方便的函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let file = dialog::file_chooser(
            &quot;Choose File&quot;,
            &quot;*.rs&quot;,
            /*start dir*/ &quot;.&quot;,
            /*relative*/ true,
        );
        if let Some(file) = file {
            println!(&quot;{}&quot;, file);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h3 id="帮助对话框-help-dialog"><a class="header" href="#帮助对话框-help-dialog">帮助对话框 Help dialog</a></h3>
<p>FLTK提供了一个帮助对话框，可以显示html 2文档：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut help = dialog::HelpDialog::new(100, 100, 400, 300);
        help.set_value(&quot;&lt;h2&gt;Hello world&lt;/h2&gt;&quot;); // this takes html
        help.show();
        while help.shown() {
            app::wait();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>html文件也可以用HelpDialog::load(path_to_html_file)方法加载：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726889-442d0453-e1d0-4b41-8717-f121fdf860fa.png" alt="image" /></p>
<h3 id="提示对话框-alert-dialogs"><a class="header" href="#提示对话框-alert-dialogs">提示对话框 Alert dialogs</a></h3>
<p>FLTK还提供了几种对话框类型，可以使用自由函数方便地显示：</p>
<ul>
<li>message</li>
<li>alert</li>
<li>choice</li>
<li>input</li>
<li>password (类似于input，但不显示输入内容)</li>
</ul>
<p>显示一个简单的message对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        dialog::message_default(&quot;Message&quot;);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>这将在默认的位置（基本上在指针附近）显示一个message。如果你想手动输入坐标，你可以使用 message() 函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        dialog::message(100, 100, &quot;Message&quot;);
    });
<span class="boring">}
</span></code></pre></pre>
<p>前面提到的所有函数都有变体，一个有_default()后缀，不需要坐标，另一个没有，需要坐标。
有些对话框会返回一个值，比如choice，input，and password。input和password返回输入的文本，而choice则返回选择值的索引：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        // 密码和输入也需要第二个参数，这是默认值
        let pass = dialog::password_default(&quot;Enter password:&quot;, &quot;&quot;);
        if let Some(pass) = pass {
            println!(&quot;{}&quot;, pass);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726850-61fc17e4-cd6e-4821-a9b5-396203806066.png" alt="image" /></p>
<p>使用choice的一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>这将打印索引，即选择No将打印0，Yes将打印1，Cancel将打印2。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726775-d000a807-8bf5-439b-a991-8bf25fcd5049.png" alt="image" /></p>
<p>你已经注意到，所有这些对话框都没有一个。你也可以在对话框前调用函数来添加一个title：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        dialog::message_title(&quot;Exit!&quot;);
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>你也可以使用 dialog::message_title_default() 来设置所有这些对话框的默认标题，你要在你的程序的开始部分这样做：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    dialog::message_title_default(&quot;My App!&quot;);
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726685-f086bde2-db63-4fa8-a579-954dbacbe44d.png" alt="image" /></p>
<h2 id="自定义对话框-custom-dialogs"><a class="header" href="#自定义对话框-custom-dialogs">自定义对话框 Custom dialogs</a></h2>
<p>所有这些对话框与你的程序设想的样子可能不相符合，特别是关于颜色和字体。如果你有一个深度定制的程序，你可能也会想要定制对话框。对话框基本上是一个在应用程序中生成的模式窗口。它可以与你的应用程序的其他部分具有相同的风格：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app, button,
    enums::{Color, Font, FrameType},
    frame, group, input,
    prelude::*,
    window,
};

fn style_button(btn: &amp;mut button::Button) {
    btn.set_color(Color::Cyan);
    btn.set_frame(FrameType::RFlatBox);
    btn.clear_visible_focus();
}

pub fn show_dialog() -&gt; MyDialog {
    MyDialog::default()
}

pub struct MyDialog {
    inp: input::Input,
}

impl MyDialog {
    pub fn default() -&gt; Self {
        let mut win = window::Window::default()
            .with_size(400, 100)
            .with_label(&quot;My Dialog&quot;);
        win.set_color(Color::from_rgb(240, 240, 240));
        let mut pack = group::Pack::default()
            .with_size(300, 30)
            .center_of_parent()
            .with_type(group::PackType::Horizontal);
        pack.set_spacing(20);
        frame::Frame::default()
            .with_size(80, 0)
            .with_label(&quot;Enter name:&quot;);
        let mut inp = input::Input::default().with_size(100, 0);
        inp.set_frame(FrameType::FlatBox);
        let mut ok = button::Button::default().with_size(80, 0).with_label(&quot;Ok&quot;);
        style_button(&amp;mut ok);
        pack.end();
        win.end();
        win.make_modal(true);
        win.show();
        ok.set_callback({
            let mut win = win.clone();
            move |_| {
                win.hide();
            }
        });
        while win.shown() {
            app::wait();
        }
        Self { inp }
    }
    pub fn value(&amp;self) -&gt; String {
        self.inp.value()
    }
}

fn main() {
    let a = app::App::default();
    app::set_font(Font::Times);
    let mut win = window::Window::default().with_size(600, 400);
    win.set_color(Color::from_rgb(240, 240, 240));
    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Click&quot;)
        .center_of_parent();
    style_button(&amp;mut btn);
    let mut frame = frame::Frame::new(btn.x() - 40, btn.y() - 100, btn.w() + 80, 30, None);
    frame.set_frame(FrameType::BorderBox);
    frame.set_color(Color::Red.inactive());
    win.end();
    win.show();
    btn.set_callback(move |_| {
        let d = show_dialog();
        frame.set_label(&amp;d.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726727-a0018457-1d87-4519-9d6e-08d8f8030d1a.png" alt="image" /></p>
<h2 id="打印机话框-printer-dialog"><a class="header" href="#打印机话框-printer-dialog">打印机话框 Printer dialog</a></h2>
<p>FLTK还提供了一个打印机对话框，它使用你的系统平台的本地打印机对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
let mut but = button::Button::default();
but.set_callback(|widget| {
    let mut printer = printer::Printer::default();
    if printer.begin_job(1).is_ok() {
        printer.begin_page().ok();
        let (width, height) = printer.printable_rect();
        draw::set_draw_color(enums::Color::Black);
        draw::set_line_style(draw::LineStyle::Solid, 2);
        draw::draw_rect(0, 0, width, height);
        draw::set_font(enums::Font::Courier, 12);
        printer.set_origin(width / 2, height / 2);
        printer.print_widget(widget, -widget.width() / 2, -widget.height() / 2);
        printer.end_page().ok();
        printer.end_job();
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>这里只是打印按钮的图像并指定它在纸上显示的位置。你可以传递任何widget（主要是像TextEditor widget）作为打印widget。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图像-images"><a class="header" href="#图像-images">图像 Images</a></h1>
<p>FLTK支持矢量图和位图，开箱即提供下列几种图像类型：</p>
<ul>
<li>BmpImage</li>
<li>JpegImage</li>
<li>GifImage</li>
<li>PngImage</li>
<li>SvgImage</li>
<li>Pixmap</li>
<li>RgbImage</li>
<li>XpmImage</li>
<li>XbmImage</li>
<li>PnmImage</li>
</ul>
<p>它还提供了两个helper types：</p>
<ul>
<li>SharedImage：它包装了之前所有的类型，所以你不需要指定图像类型。</li>
<li>TiledImage：它提供了一个任何具体类型的平铺图像（图形学术语）。</li>
</ul>
<p>图像类型实现了ImageExt trait，提供了允许缩放和检索图像元数据的方法。
Image可以通过向它的load()构造函数传递路径来构建，或者对某些类型可以使用接受图像数据的from_data()构造函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 需要一个路径
let image = image::SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();

/// 需要图像数据
let image= image::SvgImage::from_data(&amp;data).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Image可以通过WidgetExt::set_image()/set_image_scaled()或set_deimage()/set_deimage_scaled()（用于deactivated/grayed image）与widget一起使用。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>或者通过WidgetExt::draw()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    frame.draw(move |f| {
        image.scale(f.w(), f.h(), true, true);
        image.draw(f.x() + 40, f.y(), f.w(), f.h());
    });

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/hello.jpg" alt="svg" /></p>
<p>在你的应用程序中使用图像作为图标和背景也有助于赋予你的应用程序以风格。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="事件-events"><a class="header" href="#事件-events">事件 Events</a></h1>
<p>在前面提到的例子中，你主要看到了回调（Callback），除此之外，FLTK还提供了多种处理事件的方式：</p>
<ul>
<li>我们可以使用set_callback()方法，在点击我们的按钮时自动触发该方法。</li>
<li>我们可以使用handle()方法进行细粒度的事件处理。</li>
<li>我们可以使用emit()方法，该方法接收一个sender和一个message，这使我们可以在event loop中处理事件。</li>
<li>我们可以定义我们自己的事件，它可以在另一个部件的处理方法中被处理。</li>
</ul>
<h3 id="设置回调-callback"><a class="header" href="#设置回调-callback">设置回调 Callback</a></h3>
<p>WidgetExt trait 提供了set_callback方法。</p>
<h4 id="使用闭包"><a class="header" href="#使用闭包">使用闭包</a></h4>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|_| println!(&quot;The button was clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>捕获的参数是你所设置了回调的widget的可变借用<code>&amp;mut Self</code>： </p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|b| b.set_label(&quot;Clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>set_callback()方法有默认的触发器，不同widget可能有不同的触发器。对按钮来说，当它有焦点时，触发器是点击或按下回车。
可以通过set_trigger()方法为widget改变触发器。对于按钮可能没什么意义，但是对于Input widget来说，触发器可以被设置为 &quot;CallbackTrigger::Changed&quot;，这可以使Input widget的状态改变时触发回调：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut inp = input::Input::default()
        .with_size(160, 30)
        .center_of_parent();
    win.end();
    win.show();
    inp.set_trigger(enums::CallbackTrigger::Changed);
    inp.set_callback(|i| println!(&quot;{}&quot;, i.value()));
    a.run().unwrap();
}
</code></pre></pre>
<p>用户每输入一个字符就会打印一次。</p>
<p>使用闭包的好处是能够“关闭”作用域参数，即你也可以将周围作用域中的变量传递到闭包中：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(move |_| {
        my_window.set_label(&quot;button was pressed&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>你会注意到在<a href="Menus">菜单</a>中，处理是在每个MenuI tem基础上进行的。</p>
<h4 id="使用方法对象"><a class="header" href="#使用方法对象">使用方法对象</a></h4>
<p>如果你喜欢的话你也可以直接设置方法对象：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn button_cb(w: &amp;mut impl WidgetExt) {
    w.set_label(&quot;Clicked&quot;);
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(button_cb);
    app.run().unwrap();
}
</code></pre></pre>
<p>我们使用<code>&amp;mut impl WidgetExt</code>，以便能够在多种不同的widget类型中重复使用这个函数对象。或者，你可以直接使用<code>&amp;mut button::Button</code>来表示只有Button可以使用。
这种方法的一个缺点是，为了处理状态，你必须管理全局状态：</p>
<pre><pre class="playground"><code class="language-rust edition2018">extern crate lazy_static;

use fltk::{prelude::*, *};
use std::sync::Mutex;

#[derive(Default)]
struct State {
    count: i32,
}

impl State {
    fn increment(&amp;mut self) {
        self.count += 1;
    }
}

lazy_static::lazy_static! {
    static ref STATE: Mutex&lt;State&gt; = Mutex::new(State::default());
}


fn button_cb(_w: &amp;mut button::Button) {
    let mut state = STATE.lock().unwrap();
    state.increment();
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Increment!&quot;);
    my_window.end();
    my_window.show();
    
    but.set_callback(button_cb);
    
    app.run().unwrap();
}
</code></pre></pre>
<p>这里我们使用lazy_static，也有其他的crate来优化状态管理。</p>
<p>同样，对菜单来说，在<code>MenuExt::add()/insert()</code>或<code>MenuItem::add()/insert()</code>方法中，我们可以使用<code>&amp;mut impl MenuExt</code>来设置menu widget和menu item的回调。</p>
<h3 id="使用处理方法-handle-method"><a class="header" href="#使用处理方法-handle-method">使用处理方法 handle method</a></h3>
<p>handle方法接收一个参数为事件的闭包，并为已处理的事件返回一个bool。这个bool值让FLTK知道该事件是否被处理。
它的调用是这样的：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    but.handle(|_, event| {
        println!(&quot;The event: {:?}&quot;, event);
        false
    });
    
    app.run().unwrap();
}
</code></pre></pre>
<p>这将打印出event，但并不处理它，因为我们返回false。很明显，我们想做一些有用的事情，所以把处理调用改为：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|_, event| match event {
        Event::Push =&gt; {
            println!(&quot;I was pushed!&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们做一些有用的事情来处理推送事件并返回真，将其他事件都忽略并返回假。</p>
<p>另一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|b, event| match event {
        Event::Push =&gt; {
            b.set_label(&quot;Pushed&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<h3 id="使用messages"><a class="header" href="#使用messages">使用messages</a></h3>
<p>这允许我们创建Channel和一个Sender Receiver结构，然后我们可以发射Message（必须是Send + Sync安全的），并在我们的事件循环中处理。这样做的好处是，当我们需要将我们的类型传递到闭包或生成的线程中时，我们不必用智能指针来包装它们。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    let (s, r) = app::channel();
    
    but.emit(s, true);
    // 这等同于调用but.set_callback(move |_| s.send(true))

    while app.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // 这里不作任何事
            }
        }
    }
}
</code></pre></pre>
<p>跟之前的例子一样，Messages 可以在事件循环中被接受， 另外你也可以在后台线程或app::add_idle()的回调中接收Message：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    app::add_idle(move || {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // 这里不做任何事
            }
        }
    });
<span class="boring">}
</span></code></pre></pre>
<p>你也不限于使用fltk channel，你可以使用任何channel。例如，这个使例子用std channel：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
btn.set_callback(move |_| {
    s.send(Message::SomeMessage).unwrap();
});
<span class="boring">}
</span></code></pre></pre>
<p>你也可以定义一个适用于所有widget的方法，类似于emit()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::sync::mpsc::Sender;

pub trait SenderWidget&lt;W, T&gt;
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T);
}

impl&lt;W, T&gt; SenderWidget&lt;W, T&gt; for W
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T) {
        self.set_callback(move |_| {
            sender.send(msg.clone()).unwrap();
        });
    }
}

fn main() {
    let btn = button::Button::default();
    let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
    btn.send(s.clone(), Message::SomeMessage);
}
</code></pre></pre>
<h3 id="创建自己的events"><a class="header" href="#创建自己的events">创建自己的events</a></h3>
<p>FLTK识别了29个事件，这些事件在enums::Event中可以看到。然而，它允许我们使用app::handle(impl Into<i32>, window)调用创建我们自己的事件。handle函数接受一个任意的i32（&gt;30）值作为信号，理想情况下，这些值应该是预定义的，可以在另一个widget的handle()方法中处理，另一个widget需要在传递给app::handle的窗口中。
在下面的例子中，我们创建了一个带有Frame和button的窗口。button的回调通过app::handle_main函数发送一个CHANGED事件。该CHANGED信号在框架的handle方法中被查询到：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::*, enums::*, frame::*, group::*, prelude::*, window::*};
use std::cell::RefCell;
use std::rc::Rc;

pub struct MyEvent;

impl MyEvent {
    const CHANGED: i32 = 40;
}

#[derive(Clone)]
pub struct Counter {
    count: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl Counter {
    pub fn new(val: i32) -&gt; Self {
        Counter {
            count: Rc::from(RefCell::from(val)),
        }
    }

    pub fn increment(&amp;mut self) {
        *self.count.borrow_mut() += 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn decrement(&amp;mut self) {
        *self.count.borrow_mut() -= 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn value(&amp;self) -&gt; i32 {
        *self.count.borrow()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = app::App::default();
    let counter = Counter::new(0);
    let mut wind = Window::default().with_size(160, 200).with_label(&quot;Counter&quot;);
    let mut pack = Pack::default().with_size(120, 140).center_of(&amp;wind);
    pack.set_spacing(10);
    let mut but_inc = Button::default().with_size(0, 40).with_label(&quot;+&quot;);
    let mut frame = Frame::default()
        .with_size(0, 40)
        .with_label(&amp;counter.clone().value().to_string());
    let mut but_dec = Button::default().with_size(0, 40).with_label(&quot;-&quot;);
    pack.end();
    wind.end();
    wind.show();

    but_inc.set_callback({
        let mut c = counter.clone();
        move |_| c.increment()
    });

    but_dec.set_callback({
        let mut c = counter.clone();
        move |_| c.decrement()
    });
    
    frame.handle(move |f, ev| {
        if ev == MyEvent::CHANGED.into() {
            f.set_label(&amp;counter.clone().value().to_string());
            true
        } else {
            false
        }
    });

    Ok(app.run()?)
}
</code></pre></pre>
<p>发送的i32信号可以即时创建，或者也可以添加到局部/全局常量中，或者添加到一个枚举中。</p>
<h4 id="优点"><a class="header" href="#优点">优点</a></h4>
<ul>
<li>无开销。</li>
<li>该信号的处理与任何fltk事件一样。</li>
<li>app::handle函数可以返回一个bool，表示该事件是否被处理。</li>
<li>允许在事件循环之外处理自定义信号/事件。</li>
<li>允许在你的应用程序中采用MVC或SVU架构。</li>
</ul>
<h4 id="缺点"><a class="header" href="#缺点">缺点</a></h4>
<ul>
<li>该信号只能在一个widget的处理方法中处理。</li>
<li>该信号在事件循环中是不可访问的（为此，你可能想使用WidgetExt::emit或本页之前描述的channel）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拖放-drag--drop"><a class="header" href="#拖放-drag--drop">拖放 Drag &amp; Drop</a></h1>
<p>拖放是FLTK支持的事件类型。如果你实现了这些事件，你就可以拖动组件，也可以将外部文件拖入FLTK应用程序。你可能还想实现在widget上绘图，这就要求处理Event::Drag。</p>
<h2 id="拖动组件"><a class="header" href="#拖动组件">拖动组件</a></h2>
<p>这里我们将为窗口本身实现拖动。我们将创建一个没有边框的窗口。通常情况下，你可以使用边框来拖动窗口。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 400);
    wind.set_color(enums::Color::White);
    wind.set_border(false);
    wind.end();
    wind.show();

    wind.handle({
        let mut x = 0;
        let mut y = 0;
        move |w, ev| match ev {
            enums::Event::Push =&gt; {
                let coords = app::event_coords();
                x = coords.0;
                y = coords.1;
                true
            }
            enums::Event::Drag =&gt; {
                w.set_pos(app::event_x_root() - x, app::event_y_root() - y);
                true
            }
            _ =&gt; false,
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h2 id="拖动文件"><a class="header" href="#拖动文件">拖动文件</a></h2>
<p>将一个文件拖入程序中会调用Paste事件，并将文件的路径填入app::event_text()。因此，当我们处理拖动时，我们想在Event::Paste中捕获路径，检查文件是否存在，读取其内容并填充我们的text widget：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    let path = path.trim();
                    let path = path.replace(&quot;file://&quot;, &quot;&quot;);
                    let path = std::path::PathBuf::from(&amp;path);
                    if path.exists() {
                        // we use a timeout to avoid pasting the path into the buffer
                        app::add_timeout3(0.0, {
                            let mut buf = buf.clone();
                            move |_| {
                                buf.load_file(&amp;path).unwrap();
                            }
                        });
                    }
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>如果你对文件的内容不感兴趣，你可以只取路径并显示给用户：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let mut buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    buf.append(&amp;path);
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<h2 id="拖动绘图"><a class="header" href="#拖动绘图">拖动绘图</a></h2>
<p>你可以在事件里面绘图，但你会可能想使用屏幕外的画法。在widget绘图方法中，你只是把屏幕外的内容复制到widget中。一个更详细的例子可以在<a href="Drawing.html#offscreen-drawing">绘图</a>中的屏幕外绘图部分看到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态管理器-state-management"><a class="header" href="#状态管理器-state-management">状态管理器 State management</a></h1>
<p>FLTK并不强加某种形式的状态管理或应用程序架构。这是留给用户自己选择的。fltk-rs repo和本书中的所有例子都已经使用了回调（Callback）或消息（message），你会发现很多这两种方法的例子。
这些都在<a href="Events.html">事件 Event</a>中讨论过。</p>
<p>此外，所有的例子可能看起来都是在主函数中处理一切，这只是为了简化。您可以创建自己的应用程序结构，将主窗口和您的应用程序的状态包含在其中：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

#[derive(Copy, Clone)]
enum Message {
    Inc,
    Dec,
}

struct MyApp {
    app: app::App,
    main_win: window::Window,
    frame: frame::Frame,
    count: i32,
    receiver: app::Receiver&lt;Message&gt;,
}

impl MyApp {
    pub fn new() -&gt; Self {
        let count = 0;
        let app = app::App::default();
        let (s, receiver) = app::channel();
        let mut main_win = window::Window::default().with_size(400, 300);
        let col = group::Flex::default()
            .with_size(100, 200)
            .column()
            .center_of_parent();
        let mut inc = button::Button::default().with_label(&quot;+&quot;);
        inc.emit(s, Message::Inc);
        let frame = frame::Frame::default().with_label(&amp;count.to_string());
        let mut dec = button::Button::default().with_label(&quot;-&quot;);
        dec.emit(s, Message::Dec);
        col.end();
        main_win.end();
        main_win.show();
        Self {
            app,
            main_win,
            frame,
            count,
            receiver,
        }
    }

    pub fn run(mut self) {
        while self.app.wait() {
            if let Some(msg) = self.receiver.recv() {
                match msg {
                    Message::Inc =&gt; self.count += 1,
                    Message::Dec =&gt; self.count -= 1,
                }
                self.frame.set_label(&amp;self.count.to_string());
            }
        }
    }
}

fn main() {
    let a = MyApp::new();
    a.run();
}
</code></pre></pre>
<h2 id="helper-crates"><a class="header" href="#helper-crates">Helper crates</a></h2>
<p>crates生态系统给出了许多提供状态管理的crates。此外，在fltk-rs组织下有2个crate，它们提供了架构你的应用程序和管理其状态的方法：</p>
<ul>
<li><a href="https://github.com/fltk-rs/flemish">flemish</a>:</li>
</ul>
<p>提供了一个类似Elm的SVU架构。这是反应式（reactive）的，本质上是不可变的，而且拆解了每个Message的view。</p>
<ul>
<li><a href="https://github.com/fltk-rs/fltk-evented">fltk-evented</a>:</li>
</ul>
<p>这类似于即时模式的guis，所有事件都在事件循环中处理。在现实中，它也是反应式的，但却是可变的和无状态的。这不会引起触发器的重绘。</p>
<p>这两个crate都避免使用回调，因为在Rust中，由于生命周期和借用机制，处理这些回调极其麻烦。你需要使用具有内部可变性的共享智能指针，才能够借用回调。</p>
<p>你可以看一下这两个crate以获得灵感。</p>
<p>在这两个crate中都展示了一个示例计数器：</p>
<h2 id="flemish"><a class="header" href="#flemish">Flemish</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use flemish::{
    button::Button, color_themes, frame::Frame, group::Flex, prelude::*, OnEvent, Sandbox, Settings,
};

pub fn main() {
    Counter::new().run(Settings {
        size: (300, 100),
        resizable: true,
        color_map: Some(color_themes::BLACK_THEME),
        ..Default::default()
    })
}

#[derive(Default)]
struct Counter {
    value: i32,
}

#[derive(Debug, Clone, Copy)]
enum Message {
    IncrementPressed,
    DecrementPressed,
}

impl Sandbox for Counter {
    type Message = Message;

    fn new() -&gt; Self {
        Self::default()
    }

    fn title(&amp;self) -&gt; String {
        String::from(&quot;Counter - fltk-rs&quot;)
    }

    fn update(&amp;mut self, message: Message) {
        match message {
            Message::IncrementPressed =&gt; {
                self.value += 1;
            }
            Message::DecrementPressed =&gt; {
                self.value -= 1;
            }
        }
    }

    fn view(&amp;mut self) {
        let col = Flex::default_fill().column();
        Button::default()
            .with_label(&quot;Increment&quot;)
            .on_event(Message::IncrementPressed);
        Frame::default().with_label(&amp;self.value.to_string());
        Button::default()
            .with_label(&quot;Decrement&quot;)
            .on_event(Message::DecrementPressed);
        col.end();
    }
}
</code></pre></pre>
<h2 id="fltk-evented"><a class="header" href="#fltk-evented">fltk-evented</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, frame::Frame, group::Flex, prelude::*, window::Window};
use fltk_evented::Listener;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    app::set_font_size(20);

    let mut wind = Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let flex = Flex::default()
        .with_size(120, 160)
        .center_of_parent()
        .column();
    let but_inc: Listener&lt;_&gt; = Button::default().with_label(&quot;+&quot;).into();
    let mut frame = Frame::default();
    let but_dec: Listener&lt;_&gt; = Button::default().with_label(&quot;-&quot;).into();
    flex.end();
    wind.end();
    wind.show();

    let mut val = 0;
    frame.set_label(&amp;val.to_string());

    while a.wait() {
        if but_inc.triggered() {
            val += 1;
            frame.set_label(&amp;val.to_string());
        }

        if but_dec.triggered() {
            val -= 1;
            frame.set_label(&amp;val.to_string());
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布局-layouts"><a class="header" href="#布局-layouts">布局 Layouts</a></h1>
<p>Rust提供了开箱即用的：</p>
<ul>
<li>A Flex widget</li>
<li>Pack</li>
<li>Grid</li>
<li>Widget relative positioning.</li>
</ul>
<h3 id="flex"><a class="header" href="#flex">Flex</a></h3>
<p>Flex widget允许进行灵活的布局。它在group module中，实现了GroupExt trait。有2种形式的Flexwidget，可以使用set_type或with_type方法指定。比如列（Column） 和 行（Row）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(400, 300);
    let mut flex = Flex::new(0, 0, 400, 300, None);
    flex.set_type(group::FlexType::Column);
    let expanding = button::Button::default().with_label(&quot;Expanding&quot;);
    let mut normal = button::Button::default().with_label(&quot;Normal&quot;);
    flex.set_size(&amp;mut normal, 30);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>set_size方法接收另一个widget并将其大小固定为所传递的值，在这个例子中是30。因为这是一个column，所以30代表要设置的widget的高度。
另一个widget是可扩展的，因为没有为它设置尺寸。一个完整的例子可以在这里找到。</p>
<p><a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/flex.rs">第一个例子</a></p>
<p><img src="https://github.com/osen/FL_Flex/raw/main/doc/login.png" alt="image" /></p>
<h3 id="packs"><a class="header" href="#packs">Packs</a></h3>
<p>pack widget（在group module中）也实现了GroupExt trait。有两种形式的Pack，Vertical Pack 和 Horizontal Pack，Vertical Pack是默认的。它只需要子widget的高度，而Horizontal Pack只需要它的子widget的宽度，像下面的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::default().with_size(190, 40).center_of(&amp;my_window);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_size(80, 0).with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_size(80, 0).with_label(&quot;Button2&quot;);
    hpack.end();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>这就在窗口内创建了一个Pack Widget，并在其中填入2个按钮。注意，按钮的x和y坐标不再需要了。你也可以像 repo 中的Calculator示例一样，在Pack中嵌入Pack。
你也可以使用Pack::auto_layout()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::new(0, 200, 400, 100, &quot;&quot;);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_label(&quot;Button2&quot;);
    hpack.end();
    hpack.auto_layout();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>在这种情况下，我们甚至不需要按钮的大小。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937983-ef8bf400-3504-11eb-9da1-09c5ac1aade4.png" alt="image" /></p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<p><a href="https://github.com/fltk-rs/fltk-grid">Grid</a>目前是在一个external crate中实现的。它需要一个layout，使用<code>Grid::set_layout(&amp;mut self, rows, columns)</code>来设置。然后通过<code>Grid::insert(&amp;mut self, row, column)</code>或<code>Grid::insert_ext(&amp;mut self, row, column, row_span, column_span)</code>方法插入widget。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use fltk_grid::Grid;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(500, 300);
    let mut grid = Grid::default_fill();
    // 设置为 &quot;true &quot;以显示单元格的框线和数字
    grid.debug(false); 
    // 5 行，5 列
    grid.set_layout(5, 5); 
    // 组件，行，列
    grid.insert(&amp;mut button::Button::default().with_label(&quot;Click&quot;), 0, 1); 
    // widget, row, col, row_span, col_span
    grid.insert_ext(&amp;mut button::Button::default().with_label(&quot;Button 2&quot;), 2, 1, 3, 1); 
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><a href="https://github.com/fltk-rs/fltk-grid/blob/main/examples/form.rs">Grid example</a></p>
<p><img src="https://user-images.githubusercontent.com/37966791/160347418-b8b54408-3dc9-4fc4-93e8-fb6c1c0282e9.png" alt="image" /></p>
<h3 id="relative-positioning"><a class="header" href="#relative-positioning">Relative positioning</a></h3>
<p>WidgetExt trait提供了几个构造方法，允许我们相对于其他widget的大小和位置来构造widget。这类似于Qml的锚定（anchoring）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let mut frame = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;wind)
        .with_label(&quot;0&quot;);
    let mut but_inc = button::Button::default()
        .size_of(&amp;frame)
        .above_of(&amp;frame, 0)
        .with_label(&quot;+&quot;);
    let mut but_dec = button::Button::default()
        .size_of(&amp;frame)
        .below_of(&amp;frame, 0)
        .with_label(&quot;-&quot;);
    wind.end();
    wind.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/counter.jpg" alt="counter" /></p>
<p>(有一些跳过的主题设计)</p>
<p>这些方法是：</p>
<ul>
<li><code>above_of(&amp;widget, padding)</code>: 将该widget置于所传递的widget之上</li>
<li><code>below_of(&amp;widget, padding)</code>: 将该widget置于所传递的widget之下</li>
<li><code>right_of(&amp;widget, padding)</code>: 将该widget置于所传递的widget右边</li>
<li><code>left_of(&amp;widget, padding)</code>:将该widget置于所传递的widget左边</li>
<li><code>center_of(&amp;widget)</code>: 将widget放置在所传递的widget的中心（包括x和y轴）</li>
<li><code>center_of_parent()</code>: 将widget放在父widget的中心位置（包括x轴和y轴）</li>
<li><code>center_x(&amp;widget)</code>: 将widget放置在所传递的widget的中心（X轴）</li>
<li><code>center_y(&amp;widget)</code>: 将widget放置在所传递的widget的中心（Y轴）</li>
<li><code>size_of(&amp;widget)</code>: 构建与所传widget相同大小的widget</li>
<li><code>size_of_parent()</code>: 构建与其父widget相同大小的widget</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="样式-style"><a class="header" href="#样式-style">样式 Style</a></h1>
<p>FLTK为你的应用程序提供了广泛的自定义style选项，从改变应用程序的总体方案，到自定义颜色、字体、框架类型、自定义绘图...等等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="颜色-colors"><a class="header" href="#颜色-colors">颜色 Colors</a></h1>
<p>FLTK可以处理<a href="https://en.wikipedia.org/wiki/Color_depth#True_color_(24-bit)">true color</a>。一些方便的颜色在enums::Color枚举中列举：</p>
<ul>
<li>Black</li>
<li>White</li>
<li>Red</li>
<li>Blue</li>
<li>Cyan
...etc.</li>
</ul>
<p>你也可以使用颜色方法构建你的颜色：</p>
<ul>
<li>by_index()。这使用了fltk的colorormap。值范围是0到255。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let red = Color::by_index(88);
<span class="boring">}
</span></code></pre></pre>
<p><img src="https://www.fltk.org/doc-1.3/fltk-colormap.png" alt="colormap" /></p>
<ul>
<li>from_hex()。这需要一个24位的十六进制值，形式为RGB。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_hex(0xff0000); // notice it's a const functions
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>from_rgb()。这需要3个值r、g、b：</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_rgb(255, 0, 0); // notice it's a const functions
<span class="boring">}
</span></code></pre></pre>
<p>颜色枚举还提供了一些方便的方法，使用.darker()、.lighter()、.inactive()等方法生成所选颜色的不同色调的颜色：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_rgb(176, 100, 50).lighter();
<span class="boring">}
</span></code></pre></pre>
<p>如果你喜欢html十六进制字符串的颜色，你可以使用from_hex_str()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_hex_str(&quot;#ff0000&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="帧类型-frametypes"><a class="header" href="#帧类型-frametypes">帧类型 FrameTypes</a></h1>
<p>FLTK有广泛的帧类型。这些可以在enums模块下找到：
<img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/frames.jpg" alt="image" /></p>
<p>这些可以用WidgetExt::set_frame()来设置。一些widget/traits也支持set_down_frame()：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/hello.jpg" alt="image" />
在这里，我们将Frame的FrameType设置为EngravedBox，你可以看到图像周围的情况。</p>
<p>​	ButtonExt支持set_down_frame()：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>btn1.set_frame(enums::FrameType::RFlatBox);
btn1.set_down_frame(enums::FrameType::RFlatBox);
<span class="boring">}
</span></code></pre></pre>
<p>此外，我们可以使用app::set_frame_type_cb()来改变我们的FrameTypes的绘制程序：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Color, FrameType},
    prelude::*,
    *
};

fn down_box(x: i32, y: i32, w: i32, h: i32, c: Color) {
    draw::draw_box(FrameType::RFlatBox, x, y, w, h, Color::BackGround2);
    draw::draw_box(FrameType::RoundedFrame, x - 10, y, w + 20, h, c);
}

fn main() {
    let app = app::App::default();
    app::set_frame_type_cb(FrameType::DownBox, down_box, 0, 0, 0, 0);
    let mut w = window::Window::default().with_size(480, 230).with_label(&quot;Gui&quot;);
    w.set_color(Color::from_u32(0xf5f5f5));

    let mut txf = input::Input::default().with_size(160, 30).center_of_parent();    
    txf.set_color(Color::Cyan.darker());

    w.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146932070-ae63fd63-3f37-4d97-978e-4604d2bc0e4b.png" alt="image" /></p>
<p>这就用一个自定义的down_box路径改变了默认的DownBox。我们也可以在我们的绘制例程中使用ImageExt::draw()来绘制图像（比如svg图像，以获得可伸缩的圆角边框）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字体-fonts"><a class="header" href="#字体-fonts">字体 Fonts</a></h1>
<p>FLTK已经有16种字体，可以在enums::Font中找到：</p>
<ul>
<li>Helvetica</li>
<li>HelveticaBold</li>
<li>HelveticaItalic</li>
<li>HelveticaBoldItalic</li>
<li>Courier</li>
<li>CourierBold</li>
<li>CourierItalic</li>
<li>CourierBoldItalic</li>
<li>Times</li>
<li>TimesBold</li>
<li>TimesItalic </li>
<li>TimesBoldItalic </li>
<li>Symbol </li>
<li>Screen </li>
<li>ScreenBold </li>
<li>Zapfdingbats</li>
</ul>
<p>它还允许加载系统字体和捆绑字体。</p>
<p>系统字体依赖于系统，默认情况下不被加载。这些字体可以用App::load_system_fonts()方法加载。
然后可以使用app::fonts()函数获取字体，还可以使用app::font_count()、app::font_name()和app::font_index()函数进行查询。
然后可以使用Font::by_index()或Font::by_name()方法来使用。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default().load_system_fonts();
    // 要按路径加载字体，请检查App::load_font()方法
    let fonts = app::fonts();
    // println!(&quot;{:?}&quot;, fonts);
    let mut wind = window::Window::default().with_size(400, 300);
    let mut frame = frame::Frame::default().size_of(&amp;wind);
    frame.set_label_size(30);
    wind.set_color(enums::Color::White);
    wind.end();
    wind.show();
    println!(&quot;The system has {} fonts!\nStarting slideshow!&quot;, fonts.len());
    let mut i = 0;
    while app.wait() {
        if i == fonts.len() {
            i = 0;
        }
        frame.set_label(&amp;format!(&quot;[{}]&quot;, fonts[i]));
        frame.set_label_font(enums::Font::by_index(i));
        app::sleep(0.5);
        i += 1;
    }
}
</code></pre></pre>
<p>如果你想加载一个不在系统中的捆绑字体，你可以选择使用Font::load_font()和Font::set_font()，这允许你用自定义字体替换FLTK的预定义字体：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::Font, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();

    let font = Font::load_font(&quot;angelina.ttf&quot;).unwrap();
    Font::set_font(Font::Helvetica, &amp;font);
    app::set_font_size(24);

    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p>load_font()从.ttf文件中加载字体，set_font()用我们加载的字体替换Font::Helvetica（FLTK的默认字体）：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145735197-130f7dd6-a31f-4bc6-a362-90a13493a556.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绘制事物-drawing-things"><a class="header" href="#绘制事物-drawing-things">绘制事物 Drawing things</a></h1>
<p>fltk-rs在draw module中提供了让你绘制自定义元素的自由函数。只有当调用是在允许绘制的上下文中进行时，例如在WidgetBase::draw()方法中或在Offscreen上下文中，绘制才有效：</p>
<h2 id="在组件上绘制"><a class="header" href="#在组件上绘制">在组件上绘制</a></h2>
<p>注意，我们在widget的draw方法中使用了draw调用：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.draw(|w| {
        use draw::*;
        // 白色窗口
        draw_rect_fill(0, 0, w.w(), w.h(), enums::Color::White);
        // 画一个蓝色的圆
        set_draw_color(enums::Color::Blue.inactive());
        draw_pie(w.w() / 2 - 50, w.h() / 2 - 50, 100, 100, 0.0, 360.0);
        // 绘制具有角度的字体
        set_draw_color(enums::Color::Red);
        set_font(enums::Font::Courier, 16);
        draw_text_angled(45, &quot;Hello World&quot;, w.w() / 2, w.h() / 2);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145693473-defb2298-fc6b-4d2f-8a0c-3d4902b39dd3.jpg" alt="draw" /></p>
<p>我们用整个窗口作为我们的画布，也可以是在任何widget上。其他可用的功能允许绘制直线、矩形、弧线、饼、循环、多边形，甚至图像。</p>
<h2 id="在屏幕外绘制"><a class="header" href="#在屏幕外绘制">在屏幕外绘制</a></h2>
<p>有时你想根据事件来画东西，比如推拖光标的时候。在这种情况下，你可以使用draw::Offscreen来做到这一点。在这种情况下，我们使用widget的draw方法只是复制屏幕外的内容，而绘制是在widget的handle方法中进行的。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    draw::{
        draw_line, draw_point, draw_rect_fill, set_draw_color, set_line_style, LineStyle, Offscreen,
    },
    enums::{Color, Event, FrameType},
    frame::Frame,
    prelude::*,
    window::Window,
};
use std::cell::RefCell;
use std::rc::Rc;

const WIDTH: i32 = 800;
const HEIGHT: i32 = 600;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);

    let mut wind = Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;RustyPainter&quot;);
    let mut frame = Frame::default()
        .with_size(WIDTH - 10, HEIGHT - 10)
        .center_of(&amp;wind);
    frame.set_color(Color::White);
    frame.set_frame(FrameType::DownBox);

    wind.end();
    wind.show();

    // We fill our offscreen with white
    let offs = Offscreen::new(frame.width(), frame.height()).unwrap();
    #[cfg(not(target_os = &quot;macos&quot;))]
    {
        offs.begin();
        draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
        offs.end();
    }

    let offs = Rc::from(RefCell::from(offs));

    frame.draw({
        let offs = offs.clone();
        move |_| {
            let mut offs = offs.borrow_mut();
            if offs.is_valid() {
                offs.rescale();
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
            } else {
                offs.begin();
                draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
                offs.end();
            }
        }
    });

    frame.handle({
        let mut x = 0;
        let mut y = 0;
        move |f, ev| {
            // println!(&quot;{}&quot;, ev);
            // println!(&quot;coords {:?}&quot;, app::event_coords());
            // println!(&quot;get mouse {:?}&quot;, app::get_mouse());
            let offs = offs.borrow_mut();
            match ev {
                Event::Push =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    x = coords.0;
                    y = coords.1;
                    draw_point(x, y);
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                Event::Drag =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    draw_line(x, y, coords.0, coords.1);
                    x = coords.0;
                    y = coords.1;
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                _ =&gt; false,
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>注意我们是如何用offs.begin()打开一个Offscreen上下文，然后用offs.end()关闭它。这使得我们可以在Offscreen内调用绘图函数：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146173813-67038a94-7739-480e-a181-29498aac842a.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="样式设计-styling"><a class="header" href="#样式设计-styling">样式设计 Styling</a></h1>
<p>FLTK在风格化应用方面提供了许多东西。我们已经看到，我们可以使用true color和不同的字体，此外还可以进行自定义绘制。Styling就是利用所有这些。它可以利用WidgetExt中的方法在每个widget上进行，也可以使用app模块中的函数在全局上完成。</p>
<h2 id="widgetext"><a class="header" href="#widgetext">WidgetExt</a></h2>
<p>大多数WidgetExt trait与修改框架类型、标签类型、widget颜色、文本颜色、文本字体和文本大小有关。
这些都有setter和 getter，可以在[这里]（https://docs.rs/fltk/*/fltk/prelude/trait.WidgetExt.html）找到。</p>
<p>一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Align, Color, Font, FrameType},
    prelude::*,
    *,
};

const BLUE: Color = Color::from_hex(0x42A5F5);
const SEL_BLUE: Color = Color::from_hex(0x2196F3);
const GRAY: Color = Color::from_hex(0x757575);
const WIDTH: i32 = 600;
const HEIGHT: i32 = 400;

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;Flutter-like!&quot;);
    let mut bar =
        frame::Frame::new(0, 0, WIDTH, 60, &quot;  FLTK App!&quot;).with_align(Align::Left | Align::Inside);
    let mut text = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;win)
        .with_label(&quot;You have pushed the button this many times:&quot;);
    let mut count = frame::Frame::default()
        .size_of(&amp;text)
        .below_of(&amp;text, 0)
        .with_label(&quot;0&quot;);
    let mut but = button::Button::new(WIDTH - 100, HEIGHT - 100, 60, 60, &quot;@+6plus&quot;);
    win.end();
    win.make_resizable(true);
    win.show();

    // Theming
    app::background(255, 255, 255);
    app::set_visible_focus(false);

    bar.set_frame(FrameType::FlatBox);
    bar.set_label_size(22);
    bar.set_label_color(Color::White);
    bar.set_color(BLUE);
    bar.draw(|b| {
        draw::set_draw_rgb_color(211, 211, 211);
        draw::draw_rectf(0, b.height(), b.width(), 3);
    });

    text.set_label_size(18);
    text.set_label_font(Font::Times);

    count.set_label_size(36);
    count.set_label_color(GRAY);

    but.set_color(BLUE);
    but.set_selection_color(SEL_BLUE);
    but.set_label_color(Color::White);
    but.set_frame(FrameType::OFlatFrame);
    // End theming

    but.set_callback(move |_| {
        let label = (count.label().parse::&lt;i32&gt;().unwrap() + 1).to_string();
        count.set_label(&amp;label);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/flutter_like.jpg" alt="counter" /></p>
<p>widget也支持在其中显示图像，这在image章节有更多讨论。</p>
<h2 id="global-styling"><a class="header" href="#global-styling">Global styling</a></h2>
<p>这些可以在程序module中找到。从改变程序的主题开始：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, enums::*, *};
let app = app::App::default().with_scheme(app::Scheme::Plastic);
<span class="boring">}
</span></code></pre></pre>
<p>提供有四个主题：</p>
<ul>
<li>Base</li>
<li>Gtk</li>
<li>Gleam</li>
<li>Plastic</li>
</ul>
<p>设置应用程序的颜色、默认字体、默认框架类型和是否在widget上显示焦点：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, enums, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    app::set_background_color(170, 189, 206);
    app::set_background2_color(255, 255, 255);
    app::set_foreground_color(0, 0, 0);
    app::set_selection_color(255, 160,  63);
    app::set_inactive_color(130, 149, 166);
    app::set_font(enums::Font::Times);
    
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727821-5923fcd4-3a57-4a15-b36f-574b3e5321ea.png" alt="image" /></p>
<h3 id="custom-drawing"><a class="header" href="#custom-drawing">Custom Drawing</a></h3>
<p>FLTK还提供了原始绘图drawing primitives，这使得给widget自定义外观非常容易。这是用draw()方法完成的，它需要一个闭包。让我们来绘制一个自己的按钮（虽然FLTK提供了一个ShadowFrame FrameType），在这里创建一个我们自己的：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::*, *};

fn main() {
    let app = app::App::default();
    app::set_color(255, 255, 255); // white
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);

    let mut but = button::Button::default()
        .with_pos(160, 210)
        .with_size(80, 40)
        .with_label(&quot;Button1&quot;);

    but.draw2(|b| {
        draw::set_draw_color(Color::Gray0);
        draw::draw_rectf(b.x() + 2, b.y() + 2, b.width(), b.height());
        draw::set_draw_color(Color::from_u32(0xF5F5DC));
        draw::draw_rectf(b.x(), b.y(), b.width(), b.height());
        draw::set_draw_color(Color::Black);
        draw::draw_text2(
            &amp;b.label(),
            b.x(),
            b.y(),
            b.width(),
            b.height(),
            Align::Center,
        );
    });

    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100938232-62956a80-3505-11eb-888f-ffe655e7aadc.jpg" alt="draw" /></p>
<p>draw()方法也支持在widget内部绘制图像，这将在下一节看到。</p>
<h2 id="fltk-theme"><a class="header" href="#fltk-theme">fltk-theme</a></h2>
<p>这是一个<a href="https://github.com/fltk-rs/fltk-theme">crate</a>，它提供了几个预定义的主题，只要加载主题就可以使用</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use fltk_theme::{widget_themes, WidgetTheme, ThemeType};

fn main() {
    let a = app::App::default();
    let widget_theme = WidgetTheme::new(ThemeType::Aero);
    widget_theme.apply();
    let mut win = window::Window::default().with_size(400, 300);
    let mut btn = button::Button::new(160, 200, 80, 30, &quot;Hello&quot;);
    btn.set_frame(widget_themes::OS_DEFAULT_BUTTON_UP_BOX);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-theme/raw/main/screenshots/aqua_classic.jpg" alt="aqua-classic" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动画-animations"><a class="header" href="#动画-animations">动画 Animations</a></h1>
<p>动画可以通过几种机制在fltk-rs中显示：</p>
<ul>
<li>利用事件循环 Leveraging the event loop</li>
<li>使用线程 Spawning threads</li>
<li>超时 Timeouts</li>
</ul>
<h2 id="利用事件循环"><a class="header" href="#利用事件循环">利用事件循环</a></h2>
<p>fltk提供了app::wait()和app::check()，允许在一个阻塞操作中更新ui：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // 我们的按钮占据了窗口的左侧
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        while btn.w() != 0 {
            btn.set_size(btn.w() - 2, btn.h());
            app::sleep(0.016);
            btn.parent().unwrap().redraw();
            app::wait(); // or app::check();
        }
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="使用线程"><a class="header" href="#使用线程">使用线程</a></h2>
<p>这确保我们不会阻塞主/ui线程：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // our button takes the whole left side of the window
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        std::thread::spawn({
            let mut btn = btn.clone();
            move || {
                while btn.w() != 0 {
                    btn.set_size(btn.w() - 2, btn.h());
                    app::sleep(0.016);
                    app::awake(); // to awaken the ui thread
                    btn.parent().unwrap().redraw();
                }
            }
        });
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="超时"><a class="header" href="#超时">超时</a></h2>
<p>fltk为重复性操作提供了timeout功能。我们可以添加一个timeout，重复操作或让它消失。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn move_button(mut btn: button::Button, handle: app::TimeoutHandle) {
    btn.set_size(btn.w() - 2, btn.h());
    btn.parent().unwrap().redraw();
    if btn.w() == 20 {
        app::remove_timeout3(handle);
    } else {
        app::repeat_timeout3(0.016, handle);
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    let mut btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut btn);
    btn.clear_visible_focus();
    win.end();
    win.show();

    btn.set_callback(|b| {
        let btn = b.clone();
        app::add_timeout3(0.016, move |handle| {
            let btn = btn.clone();
            move_button(btn, handle)
        });
    });

    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<p>我们是在用户点击按钮时加入timeout，根据按钮的大小，我可以重复使用或者删除它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="build-issues"><a class="header" href="#build-issues">Build issues</a></h2>
<h3 id="why-does-the-build-fails-when-i-follow-one-of-the-tutorials"><a class="header" href="#why-does-the-build-fails-when-i-follow-one-of-the-tutorials">Why does the build fails when I follow one of the tutorials?</a></h3>
<p>The first tutorial uses the fltk-bundled feature flag, which is only supported for certain platforms since these are built using the Github Actions CI, namely:</p>
<ul>
<li>Windows 10 x64 (msvc and gnu).</li>
<li>MacOS 12 x64 and aarch64.</li>
<li>Ubuntu 20.04 or later, x64 and aarch64.</li>
</ul>
<p>If you're not running one of the aforementioned platforms, you'll have to remove the fltk-bundled feature flag in your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.3&quot;
</code></pre>
<p>Furthermore, the fltk-bundled flag assumes you have curl and tar installed (for Windows, they're available in the Native Tools Command Prompt).</p>
<h3 id="build-fails-on-windows-why-cant-cmake-find-my-toolchain"><a class="header" href="#build-fails-on-windows-why-cant-cmake-find-my-toolchain">Build fails on windows, why can't CMake find my toolchain?</a></h3>
<p>If you're building using the MSVC toolchain, make sure you run your build (at least your initial build) using the Native Tools Command Prompt, which should appear once you start typing &quot;native&quot; in the start menu, choose the version corresponding to your installed Rust toolchain (x86 or x64). The Native Tools Command Prompt has all the environment variables set correctly for native development. <a href="https://github.com/alexcrichton/cmake-rs">cmake-rs</a> which the bindings use might not be able to find the Visual Studio 2022 generator, in which case, you can try to use the fltk-bundled feature, or use ninja via the use-ninja feature. This requires installing <a href="https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages">Ninja</a> which can be installed with Chocolatey, Scoop or manually.</p>
<p>If you're building for the GNU toolchain, make sure that Make is also installed, which usually comes installed in mingw64 toolchain.</p>
<h3 id="build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do"><a class="header" href="#build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do">Build fails on MacOS 11 with an Apple M1 chip, what can I do?</a></h3>
<p>If you're getting &quot;file too small to be an archive&quot; error, you might be hitting this <a href="https://github.com/rust-lang/cargo/issues/8875">issues</a> or this <a href="https://github.com/rust-lang/rust/issues/50220">issue</a>. MacOS's native C/C++ toolchain shouldn't have this issue, and can be installed by running <code>xcode-select --install</code> or by installing XCode. Make sure the corresponding Rust toolchain (aarch64-apple-darwin) is installed as well. You can uninstall other Rust apple-darwin toolchains or use cargo-lipo instead if you need universal/fat binaries.</p>
<h3 id="why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows"><a class="header" href="#why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows">Why do I get a Link error while using the mingw toolchain on windows?</a></h3>
<p>If the linking fails because of this <a href="https://github.com/rust-lang/rust/issues/47048">issue</a> with older toolchains, it should work by using the fltk-shared feature (an issue with older compilers). Which would also generate a dynamic library which would need to be deployed with your application.</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.3&quot;, features = [&quot;fltk-shared&quot;] }
</code></pre>
<h3 id="why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls"><a class="header" href="#why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls">Why does my msys2 mingw built fltk app using, fltk-bundled, isn't self-contained and requires several dlls?</a></h3>
<p>If you have installed libgdiplus via pacman, it would require those dependencies on other systems. If you're using the windows sdk-provided libgdiplus, it shouldn't require extra dlls. You can either uninstall libgdiplus that was installed via pacman, or or you can build using the feature flag: <code>no-gdiplus</code>.</p>
<h3 id="why-do-i-get-link-errors-when-i-use-the-system-fltk-feature"><a class="header" href="#why-do-i-get-link-errors-when-i-use-the-system-fltk-feature">Why do I get link errors when I use the system-fltk feature?</a></h3>
<p>This crate targets FLTK 1.4, while currently most distros distribute an older version of FLTK (1.3.5). You can try to install FLTK (C++) by building from source.</p>
<h3 id="build-fails-on-arch-linux-because-of-pango-or-cairo"><a class="header" href="#build-fails-on-arch-linux-because-of-pango-or-cairo">Build fails on Arch linux because of pango or cairo?</a></h3>
<p>Pango changed its include paths which caused build failures across many projects. There are 2 solutions:</p>
<ul>
<li>Use the no-pango feature. Downsides: loss of rtl and cjk language support.</li>
<li>Set the CFLAGS and CXXFLAGS to correct the global include paths.</li>
</ul>
<pre><code>export CFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
export CXXFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
</code></pre>
<h3 id="how-do-i-force-cmake-to-use-a-certain-c-compiler"><a class="header" href="#how-do-i-force-cmake-to-use-a-certain-c-compiler">How do I force CMake to use a certain C++ compiler?</a></h3>
<p>FLTK works with all 3 major compilers. If you would like to change the C++ compiler that's chosen by default by CMake, you can change the CXX environment variable before running the build:</p>
<pre><code>export CXX=/usr/bin/clang++
cargo run
</code></pre>
<p>CMake caches the C++ compiler variable after it's first run, so if the above failed because of a previous run, you would have to run <code>cargo clean</code> or you can manually delete the CMakeCache.txt file in the build directory.</p>
<h3 id="can-i-accelerate-the-build-speed"><a class="header" href="#can-i-accelerate-the-build-speed">Can I accelerate the build speed?</a></h3>
<p>You can use the &quot;use-ninja&quot; feature flag if you have ninja installed. </p>
<h3 id="can-i-cache-a-previous-build-of-the-fltk-library"><a class="header" href="#can-i-cache-a-previous-build-of-the-fltk-library">Can I cache a previous build of the FLTK library?</a></h3>
<p>You can use the fltk-bundled feature and use either the CFLTK_BUNDLE_DIR or CFLTK_BUNDLE_URL to point to the location of your cached cfltk and fltk libraries.</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<h3 id="how-do-i-deploy-my-application"><a class="header" href="#how-do-i-deploy-my-application">How do I deploy my application?</a></h3>
<p>Rust, by default, statically links your application. FLTK is built also for static linking. That means that the resulting executable can be directly deployed without the need to deploy other files along with it. If you want to create a WIN32 application, Mac OS Bundle or Linux AppImage, please check the question just below!</p>
<h3 id="why-do-i-get-a-console-window-whenever-i-start-my-gui-app"><a class="header" href="#why-do-i-get-a-console-window-whenever-i-start-my-gui-app">Why do I get a console window whenever I start my GUI app?</a></h3>
<p>This is the default behavior of the toolchain, and is helpful for debugging purposes. It can be turned off easily by adding <code>#![windows_subsystem = &quot;windows&quot;]</code> at the beginning of your main.rs file if you're on windows. 
If you would like to keep the console window on debug builds, but not on release builds, you can use <code>#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]</code> instead.</p>
<p>For Mac OS and Linux, this is done by a post-build process to create a Mac OS Bundle or Linux AppImage respectively.</p>
<p>See <a href="https://github.com/burtonageo/cargo-bundle">cargo-bundle</a> for an automated tool for creating Mac OS app bundles. </p>
<p>See <a href="https://docs.appimage.org/packaging-guide/overview.html#converting-existing-binary-packages">here</a> for directions on creating an AppImage for Linux.</p>
<h3 id="why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected"><a class="header" href="#why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected">Why is the size of my resulting executable larger than I had expected?</a></h3>
<p>FLTK is known for it's small applications. Make sure you're building in release, and make sure symbols are stripped using the strip command in Unix-like systems. On Windows it's unnecessary since symbols would end up in the pdb file (which shouldn't be deployed).</p>
<p>If you need an even smaller size, try using opt-level=&quot;z&quot;:</p>
<pre><code class="language-toml">[profile.release]
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Newer versions of cargo (&gt;1.46) support automatically stripping binaries in the post-build phase:</p>
<pre><code class="language-toml">cargo-features = [&quot;strip&quot;]

[profile.release]
strip = true
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Furthermore, you can build Rust's stdlib optimized for size (it comes optimized for speed by default). More info on that <a href="https://github.com/johnthagen/min-sized-rust">here</a></p>
<h3 id="can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm"><a class="header" href="#can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm">Can I cross-compile my application to a mobile platform or WASM?</a></h3>
<p>FLTK currently doesn't support WASM nor iOS. It has experimental support for Android (YMMV). It is focused on desktop applications.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<h3 id="can-i-use-this-crate-in-a-commercial-application"><a class="header" href="#can-i-use-this-crate-in-a-commercial-application">Can I use this crate in a commercial application?</a></h3>
<p>Yes. This crate has an MIT license which requires acknowledgment. FLTK (the C++ library) is licensed under the LGPL license with an exception allowing static linking for commercial/closed-source use. You can find the full terms of both licenses here:</p>
<ul>
<li><a href="https://github.com/fltk/fltk/blob/master/COPYING">COPYING</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/blob/master/LICENSE">LICENSE</a></li>
</ul>
<h2 id="alignment"><a class="header" href="#alignment">Alignment</a></h2>
<h3 id="why-cant-i-align-input-or-output-text-to-the-right"><a class="header" href="#why-cant-i-align-input-or-output-text-to-the-right">Why can't I align input or output text to the right?</a></h3>
<p>FLTK has some known issues with text alignment.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<h3 id="do-you-plan-on-supporting-multithreading-or-asyncawait"><a class="header" href="#do-you-plan-on-supporting-multithreading-or-asyncawait">Do you plan on supporting multithreading or async/await?</a></h3>
<p>FLTK supports multithreaded and concurrent applications. See the examples dir and the <a href="https://github.com/fltk-rs/demos">fltk-rs demos repo</a> for examples on usage with threads, messages, async_std and tokio (web-todo examples).</p>
<h3 id="should-i-explicitly-call-applock-and-appunlock"><a class="header" href="#should-i-explicitly-call-applock-and-appunlock">Should I explicitly call app::lock() and app::unlock()?</a></h3>
<p>fltk-rs surrounds all mutating calls to widgets with a lock on the C++ wrapper side. Normally you wouldn't have to call app::lock() and app::unlock(). 
This depends however on the support of recursive mutexes in your system. 
If you notice haning in multithreaded applications, you might have to initialize threads (like xlib threads) by calling app::lock() once in your main thread. 
In that case, you can wrap widgets in an Arc<Mutex> or surround widget-mutating functions/methods with an app::lock and app::unlock. 
But that should rarely be required.</p>
<h2 id="windowing"><a class="header" href="#windowing">Windowing</a></h2>
<h3 id="why-does-fltk-exit-when-i-hit-the-escape-key"><a class="header" href="#why-does-fltk-exit-when-i-hit-the-escape-key">Why does FLTK exit when I hit the escape key?</a></h3>
<p>This is the default behavior in FLTK. You can easily override it by setting a callback for your main window:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    wind.set_callback(|_| {
        if fltk::app::event() == fltk::enums::Event::Close {
            app::quit(); // Which would close using the close button. You can also assign other keys to close the application
        }
    });
<span class="boring">}
</span></code></pre></pre>
<h2 id="panicscrashes"><a class="header" href="#panicscrashes">Panics/Crashes</a></h2>
<h3 id="my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it"><a class="header" href="#my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it">My app panics when I try to handle events, how can I fix it?</a></h3>
<p>This is due to a debug_assert which checks that the involved widget and the window are capable of handling events. Although most events would be handled correctly, some events require that the aforementioned conditions be met. Thus it is advisable to place your event handling code after the main drawing is done, i.e after calling your main window's show() method. Another point is that event handling and drawing should be done in the main thread. Panics accross FFI boundaries are undefined behavior, as such, the wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<h2 id="memory-and-unsafety"><a class="header" href="#memory-and-unsafety">Memory and unsafety</a></h2>
<h3 id="how-memory-safe-is-fltk-rs"><a class="header" href="#how-memory-safe-is-fltk-rs">How memory-safe is fltk-rs?</a></h3>
<p>The callback mechanism consists of a closure as a void pointer with a shim which dereferences the void pointer into a function pointer and calls the function. This is technically undefined behavior, however most implementations permit it and it's the method used by most wrappers to handle callbacks across FFI boundaries. <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/function-pointers.html#representation">link</a></p>
<p>As stated before, panics accross FFI boundaries are undefined behavior, as such, the C++ wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<p>FLTK manages it's own memory. Any widget is automatically owned by a parent which does the book-keeping as well and deletion, this is the enclosing widget implementing GroupExt such as windws etc. This is done in the C++ FLTK library itself. Any constructed widget calls the current() method which detects the enclosing group widget, and calls its add() method rending ownership to the group widget. Upon destruction of the group widget, all owned widgets are freed. Also all widgets are wrapped in a mutex for all mutating methods, and their lifetimes are tracked using an Fl_Widget_Tracker, That means widgets have interior mutability as if wrapped in an Arc&lt;Mutex<widget>&gt; and have a tracking pointer to detect deletion. Cloning a widget performs a memcpy of the underlying pointer and allows for interior mutability; it does not create a new widget.
Images are reference-counted. All mutating methods are wrapped in locks.
This locking might lead to some performance degradation as compared to the original FLTK library, it does allow for multithreaded applications, and is necessary in an FLTK (C++) application if it also required threading.</p>
<p>Overriding drawing methods will box data to be sent to the C++ library, so the data should optimally be limited to widgets or plain old data types to avoid unnecessary leaks if a custom drawn widget might be deleted during the lifetime of the program.</p>
<h3 id="can-i-get-memory-leaks-with-fltk-rs"><a class="header" href="#can-i-get-memory-leaks-with-fltk-rs">Can I get memory leaks with fltk-rs?</a></h3>
<p>Non-parented widgets that can no longer be accessed are a memory leak. Otherwise, as mentioned in the previous section all parented widgets lifetimes' are managed by the parent.
An example of a leaking widget:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    win.end();
    win.show();

    {
        button::Button::default(); // this leaks since it's not parented by the window, and has no handle in main
    }
}
</code></pre></pre>
<p>A more subtle cause of leaks, is removing a widget from a group, then the scope ends without it being added to another group or deleted:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    {
        button::Button::default(); // This doesn't leak since the parent is the window
    }
    win.end();
    win.show();

    {
        win.remove_by_index(0); // the button leaks here since it's removed and we no longer have access to it
    }
}
</code></pre></pre>
<h3 id="why-is-fltk-rs-using-so-much-unsafe-code"><a class="header" href="#why-is-fltk-rs-using-so-much-unsafe-code">Why is fltk-rs using so much unsafe code?</a></h3>
<p>Interfacing with C++ or C code can't be reasoned about by the Rust compiler, so the unsafe keyword is needed.</p>
<h3 id="is-fltk-rs-panicexception-safe"><a class="header" href="#is-fltk-rs-panicexception-safe">Is fltk-rs panic/exception-safe?</a></h3>
<p>FLTK (C++) doesn't throw exceptions, neither do the C wrapper (cfltk) nor the fltk-sys crate. The higher level fltk crate, which wraps fltk-sys, is not exception-safe since it uses asserts internally after various operations to ensure memory-safety. An example is a widget constructor which checks that the returned pointer (from the C++ side) is not null from allocation failure. It also asserts all widget reads/writes are happening on valid (not deleted) widgets.
Also any function sending a string across FFI is checked for interal null bytes. For such functions, the developer can perform a sanity check on passed strings to make sure they're valid UTF-8 strings, or check that a widget was not deleted prior to accessing a widget. That said, all functions passed as callbacks to be handled by the C++ side are exception-safe.</p>
<h3 id="are-there-any-environment-variables-which-can-affect-the-build-or-behavior"><a class="header" href="#are-there-any-environment-variables-which-can-affect-the-build-or-behavior">Are there any environment variables which can affect the build or behavior?</a></h3>
<ul>
<li><code>CFLTK_TOOLCHAIN=&lt;path&gt;</code> allows passing the path to a CMake file acting as a CMAKE_TOOLCHAIN_FILE, this allows passing extra info to cmake if needed.</li>
<li><code>CFLTK_WAYLAND_ONLY=&lt;1 or 0&gt;</code> allows building for wayland only without directly linking X11 libs nor relying on their headers for the build process. This only works with the <code>use-wayland</code> feature flag.</li>
<li><code>CFLTK_BUNDLE_DIR=&lt;path&gt;</code> allows passing a path of prebuilt cfltk and fltk static libs, useful for when a customized build of fltk is needed, or for targetting other arches when building with the <code>fltk-bundled</code> flag.</li>
<li><code>CFLTK_BUNDLE_URL=&lt;url&gt;</code> similar to above but allows passing a url which will directs the build script to download from the passed url.</li>
<li><code>FLTK_BACKEND=&lt;x11 or wayland&gt;</code> allows choosing the backend of your hybrid X11/wayland FLTK app. This only works for apps built with <code>use-wayland</code> feature flag. </li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Please refer to the <a href="https://github.com/fltk-rs/fltk-rs/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> page for further information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
