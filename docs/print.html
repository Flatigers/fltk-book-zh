<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fltk book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Home.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li class="chapter-item expanded "><a href="Setup.html"><strong aria-hidden="true">2.</strong> 配置</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Cross-Compiling.html"><strong aria-hidden="true">2.1.</strong> 交叉编译</a></li><li class="chapter-item "><a href="Fluid.html"><strong aria-hidden="true">2.2.</strong> 使用 Fluid</a></li></ol></li><li class="chapter-item expanded "><a href="The-App-struct.html"><strong aria-hidden="true">3.</strong> App 结构</a></li><li class="chapter-item expanded "><a href="Windows.html"><strong aria-hidden="true">4.</strong> 窗口 Windows</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="GlutWindow.html"><strong aria-hidden="true">4.1.</strong> GlutWindow</a></li></ol></li><li class="chapter-item expanded "><a href="Widgets.html"><strong aria-hidden="true">5.</strong> 组件 Widgets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Buttons.html"><strong aria-hidden="true">5.1.</strong> 按钮 Buttons</a></li><li class="chapter-item "><a href="Labels.html"><strong aria-hidden="true">5.2.</strong> 标签 Labels</a></li><li class="chapter-item "><a href="Group-widgets.html"><strong aria-hidden="true">5.3.</strong> 组控件 Group widgets</a></li><li class="chapter-item "><a href="Menus.html"><strong aria-hidden="true">5.4.</strong> 菜单 Menus</a></li><li class="chapter-item "><a href="Input-&-Output.html"><strong aria-hidden="true">5.5.</strong> 输入输出 Input & Output</a></li><li class="chapter-item "><a href="Valuators.html"><strong aria-hidden="true">5.6.</strong> 估值器 Valuators</a></li><li class="chapter-item "><a href="Text.html"><strong aria-hidden="true">5.7.</strong> 文字 Text</a></li><li class="chapter-item "><a href="Browsers.html"><strong aria-hidden="true">5.8.</strong> 阅览器 Browsers</a></li><li class="chapter-item "><a href="Trees.html"><strong aria-hidden="true">5.9.</strong> 树 Trees</a></li><li class="chapter-item "><a href="Tables.html"><strong aria-hidden="true">5.10.</strong> 表格 Tables</a></li><li class="chapter-item "><a href="Custom-Widgets.html"><strong aria-hidden="true">5.11.</strong> 自定义组件 Custom widgets</a></li></ol></li><li class="chapter-item expanded "><a href="Dialogs.html"><strong aria-hidden="true">6.</strong> 对话框 Dialogs</a></li><li class="chapter-item expanded "><a href="Images.html"><strong aria-hidden="true">7.</strong> 图像 Images</a></li><li class="chapter-item expanded "><a href="Events.html"><strong aria-hidden="true">8.</strong> 事件 Events</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Drag-&-Drop.html"><strong aria-hidden="true">8.1.</strong> 拖放 Drag & Drop</a></li><li class="chapter-item "><a href="State-Management.html"><strong aria-hidden="true">8.2.</strong> 状态管理器 State Management</a></li></ol></li><li class="chapter-item expanded "><a href="Layouts.html"><strong aria-hidden="true">9.</strong> 布局 Layouts</a></li><li class="chapter-item expanded "><a href="Style.html"><strong aria-hidden="true">10.</strong> 样式 Style</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Colors.html"><strong aria-hidden="true">10.1.</strong> 颜色 Colors</a></li><li class="chapter-item "><a href="FrameTypes.html"><strong aria-hidden="true">10.2.</strong> 边框类型 FrameTypes</a></li><li class="chapter-item "><a href="Fonts.html"><strong aria-hidden="true">10.3.</strong> 字体 Fonts</a></li><li class="chapter-item "><a href="Drawing.html"><strong aria-hidden="true">10.4.</strong> 绘制 Drawing things</a></li><li class="chapter-item "><a href="Styling.html"><strong aria-hidden="true">10.5.</strong> 自定义风格 Styling</a></li></ol></li><li class="chapter-item expanded "><a href="Animations.html"><strong aria-hidden="true">11.</strong> 动画 Animations</a></li><li class="chapter-item expanded "><a href="Accessibility.html"><strong aria-hidden="true">12.</strong> 无障碍 Accessibility</a></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">13.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">fltk book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Flatigers/fltk-book-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>翻译最近更新于：2023/6/28</p>
<p>翻译已基本完成，受限于译者水平，内容有错误和不足，欢迎大家提交Issue 和 PullRequest 一起改进！</p>
<h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<p>欢迎来到 <a href="https://github.com/fltk-rs/fltk-rs">fltk-rs</a> 教程 !</p>
<p>这是为 <a href="https://crates.io/crates/fltk">fltk crate</a> 而写的一本说明书。 其他资源有:</p>
<ul>
<li><a href="https://docs.rs/fltk">官方文档</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs#tutorials">视频</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/discussions">讨论、社区</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/tree/master/fltk/examples">示例</a></li>
<li><a href="https://github.com/fltk-rs/demos">示范</a></li>
<li><a href="https://github.com/tdryer/7guis-fltk-rs">7guis-fltk-rs</a></li>
<li><a href="https://github.com/wyhinton/FLTK-RS-Examples">FLTK-RS-Examples</a></li>
<li>Erco's FLTK cheat <a href="http://seriss.com/people/erco/fltk/">page</a>, 一份优秀的FLTK C++ 参考 </li>
</ul>
<p><a href="https://github.com/fltk/fltk">FLTK</a> 是一个跨平台的轻量级 GUI库。
该库自身是使用 C++98编写的，具有高度可移植性。 fltk crate 是使用 rust 编写的，它是通过FFI来调用一个 使用C89和C++11编写的FLTK封装器 <a href="https://github.com/MoAlyousef/cfltk">cfltk</a>。</p>
<p>该库的构造极其简洁，对习惯使用面向对象GUI库的开发者比较友好。该封装本身也遵循简化文档的相同模型，因为方法的名称与C++所对应的函数是相同或类似的。这使得 FLTK C++ 的文档变得非常简单，因为这些方法基本上是相互对映的。</p>
<p>C++：</p>
<pre><code class="language-c++">int main() {
    auto wind = new Fl_Window(100, 100, 400, 300, &quot;My Window&quot;);
    wind-&gt;end();
    wind-&gt;show();
}
</code></pre>
<p>映射为Rust后：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>为什么选择 FLTK ？</p>
<ul>
<li>轻量。二进制文件简小，<code>strip</code> 后仅有大约1MB。 <a href="https://szibele.com/memory-footprint-of-gui-toolkits/">低内存占用</a>。</li>
<li>快速。安装快、构建快、启动快、运行快。</li>
<li>仅有一个运行文件。不需要配置DDL库。</li>
<li>向前兼容，支持旧架构。</li>
<li>FLTK的允许性许可证，允许闭源应用静态链接。</li>
<li>主题化 (4款默认支持的主题: Base, GTK, Plastic and Gleam)，以及 <a href="https://crates.io/crates/fltk-theme">fltk-theme</a> 中的其他主题。</li>
<li>提供了约80个可供自定义的 widget。</li>
<li>内置图像支持。</li>
</ul>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>将以下代码添加到你的 Cargo.toml 文件:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.4&quot;
</code></pre>
<p>使用捆绑库（适用于 x64 windows (msvc &amp; gnu (msys2)), x64 linux &amp; macos）:</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.4&quot;, features = [&quot;fltk-bundled&quot;] }
</code></pre>
<p>该库提供了特定平台的绑定，它会自动编译,并使用静态链接的方式链接到你的二进制文件中。</p>
<p>现在编写我们的第一个示例，导入必要的 fltk 模块：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, window::Window};
fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>运行这段示例，你会发现并没有什么反应。我们还需要使用一行代码运行事件循环（event loop），这相当于在C++中使用<code>Fl::run()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, prelude::*, window::Window};
fn main() {
    let a = app::App::default();
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>这段代码中，我们实例化了 App 结构，它会初始化运行时（runtime）和样式（styles）。在程序的末尾，我们调用 run() 函数来让程序正常工作。</p>
<h2 id="贡献本书"><a class="header" href="#贡献本书">贡献本书</a></h2>
<p>这本书是使用 <a href="https://github.com/rust-lang/mdBook">mdbook</a>，根据 <a href="https://github.com/fltk-rs/fltk-book">fltk-book</a> 仓库的内容生成的。本书的作者为 <strong>Mohammed Alyousef</strong>，由 <strong>Flatig L</strong> 翻译为中文</p>
<p>你可能需要执行 <code>cargo install mdbook</code>. 更多说明可以在fltk-book的README文件和mdbook的 <a href="https://rust-lang.github.io/mdBook/">用户指南</a> 中找到。</p>
<p>你也可以在这里贡献中文翻译 <a href="https://github.com/Flatigers/fltk-book-zh">fltk-book-zh</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<p>请确保你的电脑上配置了 Rust (version &gt; 1.45)，CMake (version &gt; 3.11)，Git， C++11 编译工具链，并设置好了PATH，这样便可以方便地构建跨平台程序。我们还提供了特定平台上fltk的捆绑库形式，可以通过启用fltk-bundle这个feature来启用（这里会用到curl来下载库，tar来解包）。如果你安装了 ninja-build 构建工具，你可以使用 &quot;use-ninja&quot; feature来启用。它可能会加快构建速度。</p>
<ul>
<li>
<p>Windows: </p>
<ul>
<li>MSVC: Windows SDK</li>
<li>Gnu: 无依赖</li>
</ul>
</li>
<li>
<p>MacOS: 无依赖</p>
</li>
<li>
<p>Linux: 需要安装 X11 and OpenGL 头文件。具有图形用户界面的Linux发行版上带有这些库。</p>
<p>基于 Debian 的Linux发行版，运行：</p>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>基于 RHEL的Linux发行版，运行：</p>
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel libstdc++-static
</code></pre>
<p>基于 Arch 的Linux发行版，运行：</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>Alpine Linux：</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
</li>
<li>
<p>Android： Android Studio，Android Sdk， Android Ndk。</p>
</li>
</ul>
<h2 id="配置细节"><a class="header" href="#配置细节">配置细节</a></h2>
<p>这一部分将假设你没有安装Rust，分几个不同的环境进行讨论：</p>
<h3 id="windows-msvc-toolchain"><a class="header" href="#windows-msvc-toolchain">Windows (MSVC toolchain)</a></h3>
<ul>
<li>访问rust语言官网的 <a href="https://www.rust-lang.org/learn/get-started">开始</a>。</li>
<li>按照 &quot;Visual Studio C++ build tools &quot;的链接，下载MSVC编译器和Windows sdk。</li>
<li>使用安装器安装：</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/37966791/116013495-2dff8800-a639-11eb-8e4c-8c6228e00abc.png" alt="image" /></p>
<p>确保选中这些：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/116013520-48d1fc80-a639-11eb-934a-fac6609135b4.png" alt="image" /></p>
<ul>
<li>你可以在其中查看有没有CMake安装选项，或者直接点这里下载 <a href="https://cmake.org/download/">Cmake</a>。</li>
<li>如果你还没有GIt，请点击下载 <a href="https://git-scm.com/downloads">Git</a>。</li>
<li>从 rust-lang.org 网站上，下载适合你的架构的正确的rustup安装程序。</li>
<li>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</li>
</ul>
<h3 id="windows-gnu-toolchain"><a class="header" href="#windows-gnu-toolchain">Windows (gnu toolchain)</a></h3>
<p>如果你没有msys2，点击这里安装 <a href="https://www.msys2.org/">msys2</a>。</p>
<ul>
<li>你可以通过pacman软件包管理器安装Rust工具链，或者通过前面所说的rustup（推荐）。注意，使用pacman安装需要显示指定你要使用gnu工具链（否则会默认安装MSVC工具链）。
你应该依据你电脑的架构安装合适的工具链。例如，64位设备应该安装x86_64-pc-windows-gnu工具链。
如果你决定通过软件包管理器安装Rust，请确保你得到的是mingw的变体，并且有正确的MINGW_PACKAGE_PREFIX（对于64位机器，这个环境变量相当于mingw-w64-x86_64）。</li>
<li>假设你通过pacman安装了东西，打开mingw shell（注意，这里不是msys2 shell，它可以在msys2安装目录下找到，或者通过<code>source shell mingw64</code>）并运行以下内容：
<pre><code>pacman -S curl tar git $MINGW_PACKAGE_PREFIX-rust $MINGW_PACKAGE_PREFIX-gcc $MINGW_PACKAGE_PREFIX-cmake $MINGW_PACKAGE_PREFIX-make --needed
</code></pre>
如果你打算使用ninja，可以用<code>$MINGW_PACKAGE_PREFIX-ninja</code>替换<code>$MINGW_PACKAGE_PREFIX-make</code>。</li>
<li>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</li>
</ul>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<ul>
<li>
<p>运行下列代码安装Xcode命令行工具（它带有C++编译器）：</p>
<pre><code> xcode-select --install
</code></pre>
<p>按照说明执行步骤。或者可以不用XCode，直接用Homebrew安装clang或gcc：</p>
</li>
<li>
<p>可以点击这里下载<a href="https://cmake.org/download/">CMake</a>。
或者，也可以跟上面一样使用Homebrew：</p>
<pre><code>brew install cmake
</code></pre>
</li>
<li>
<p>安装Rust Toolchain：</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>按照默认设置进行即可。</p>
</li>
<li>
<p>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</p>
</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>使用你的软件包管理器安装一个C++编译器，以及CMake，make，git。
以Debian/Ubuntu 为例：
<pre><code>sudo apt-get install g++ cmake git make
</code></pre>
</li>
<li>要使用FLTK的开发依赖项（dependencies-dev），你还可以使用软件包管理器。
对基于Debian的GUI发行版，运行下列代码：
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
对于基于RHEL的GUI发行版，运行下列代码：
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel
</code></pre>
对于基于Arch Linux的GUI发行版，运行下列代码：
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
对于Alpine linux：
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
</li>
<li>安装Rust Toolchain：
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
一切按默认即可。</li>
<li>一切准备好后，就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>依赖，然后开始编写你的应用程序。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h1>
<h2 id="使用预编译包"><a class="header" href="#使用预编译包">使用预编译包</a></h2>
<p>如果你要为以下平台编译fltk程序的话，很幸运，它们已经有预编译包了：</p>
<ul>
<li>x86_64-pc-windows-gnu</li>
<li>x86_64-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
<li>aarch64-apple-darwin</li>
<li>x86_64-unknown-linux-gnu</li>
<li>aarch64-unknown-linux-gnu</li>
</ul>
<p>通过rustup设置目标平台（target），然后调用进行编译：</p>
<pre><code>rustup target add &lt;your target&gt; # 使用上列目标平台替换target
cargo build --target=&lt;your target&gt; --features=fltk-bundled
</code></pre>
<p>对于arch64-unknonw-linux-gnu，你可能需要指定链接器：</p>
<pre><code>CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu --features=fltk-bundled
</code></pre>
<p>你可以在 <code>.cargo/config.toml</code> （HOME下全局配置或在项目根目录下局部配置）中指定好链接器，这样你就不需要在命令中使用了：</p>
<pre><code># .cargo/config.toml
[target.aarch64-unknown-linux-gnu]
linker = &quot;aarch64-linux-gnu-gcc&quot;
</code></pre>
<p>之后便可以直接编译了：</p>
<pre><code>cargo build --target=aarch64-unknown-linux-gnu --features=fltk-bundled
</code></pre>
<h2 id="使用cross"><a class="header" href="#使用cross">使用cross</a></h2>
<p>如果你安装了docker，可以试试用 <a href="https://github.com/cross-rs/cross">cross</a>：</p>
<pre><code>cargo install cross
cross build --target=&lt;your target&gt;  # 使用你的target替换，cross build时Docker守护进程必须正在运行，不需要通过rustup添加target
</code></pre>
<p>如果你的target需要外部依赖项（比如在Linux上），你必须创建自定义Docker镜像，并经过如下步骤来进行交叉编译：</p>
<ol>
<li>
<p>设置<code>Cross.toml</code>文件。</p>
<p>例如，对一个有如下结构的项目来说：</p>
<pre><code>myapp
     |_src
     |    |_main.rs    
     |
     |_Cargo.toml
     |
     |_Cross.toml
     |
     |_arm64-dockerfile
</code></pre>
<p>arm64-dockerfile则是自定义的Docker镜像文件（名称并不重要，只要确保Cross.toml指向该文件）的内容：</p>
<pre><code class="language-dockerfile">FROM ghcr.io/cross-rs/aarch64-unknown-linux-gnu:edge

ENV DEBIAN_FRONTEND=noninteractive

RUN dpkg --add-architecture arm64 &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install --assume-yes --no-install-recommends \
    libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
    libxinerama-dev:arm64 libxcursor-dev:arm64 \
    libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
    libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64
</code></pre>
<p>注意库包名称后面的架构，如：libx11-dev:arm64。</p>
<p>Cross.toml的内容：</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
dockerfile = &quot;./arm64-dockerfile&quot;
</code></pre>
</li>
<li>
<p>配置<code>Cargo.toml</code>文件：</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
pre-build = [&quot;&quot;&quot; \
dpkg --add-architecture arm64 &amp;&amp; \
apt-get update &amp;&amp; \
apt-get install --assume-yes --no-install-recommends \
libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
libxinerama-dev:arm64 libxcursor-dev:arm64 \
libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64 \
&quot;&quot;&quot;]
</code></pre>
</li>
<li>
<p>运行cross：</p>
<pre><code>cross build --target=aarch64-unknown-linux-gnu
</code></pre>
<p>第一次运行可能会花较长时间</p>
</li>
</ol>
<h2 id="使用交叉编译-cc-toolchain"><a class="header" href="#使用交叉编译-cc-toolchain">使用交叉编译 C/C++ toolchain</a></h2>
<p>你需要有一个C/C++交叉编译器，还有设置好前面的方案中提到过的target，（通过<code>rustup target add</code>安装）。</p>
<p>对于Windows和MacOS，系统编译器已经可以向特定的target编译程序了。比如在MacOS上，如果你已经可以使用编译器编译fltk应用程序，你可以这样为其他平台编译（假设你有一个intel x86_64 mac）：</p>
<pre><code>rustup target add aarch64-apple-darwin
cargo build --target=arch64-apple-darwin
</code></pre>
<h3 id="linux-编译-64位windows"><a class="header" href="#linux-编译-64位windows">Linux 编译 64位Windows</a></h3>
<p>在你能够为自己的设备正确编译之后，如果你想在Linux上为64位Windows交叉编译应用程序：</p>
<ul>
<li>你需要使用下列命令添加Rust target：
<pre><code>rustup target add x86_64-pc-windows-gnu # 此时在arch上编译
</code></pre>
</li>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行部上，你可以运行：
<pre><code>apt-get install mingw-w64 # 或者 gcc-mingw-w64-x86-64
</code></pre>
在基于RHEL的发行部上：
<pre><code>dnf install mingw64-gcc
</code></pre>
在Arch上：
<pre><code>pacman -S mingw-w64-gcc
</code></pre>
在Alpine上：
<pre><code>apk add mingw-w64-gcc
</code></pre>
</li>
<li>在项目根目录添加<code>.cargo/config.toml</code> （如果你想全局设置的话，也可以修改HOME目录下的相应文件），并指定链接器和打包工具：
<pre><code class="language-toml"># .cargo/config.toml
[target.x86_64-pc-windows-gnu]
linker = &quot;x86_64-w64-mingw32-gcc&quot;
ar = &quot;x86_64-w64-mingw32-gcc-ar&quot;
</code></pre>
</li>
<li>运行build：
<pre><code>cargo build --target=x86_64-pc-windows-gnu
</code></pre>
</li>
</ul>
<h3 id="x64-linux-gnu-编译-aarch64-linux-gnu"><a class="header" href="#x64-linux-gnu-编译-aarch64-linux-gnu">x64 linux-gnu 编译 aarch64 linux-gnu</a></h3>
<p>另一个例子是，在基于x86_64 debian的发行版上为基于arm64 debian的发行版进行编译：
假设你已经安装了cmake：</p>
<ul>
<li>使用下列命令添加 rust target：
<pre><code>rustup target add aarch64-unknown-linux-gnu
</code></pre>
</li>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行版上，你可以运行：
<pre><code>apt-get install g++-aarch64-linux-gnu
</code></pre>
</li>
<li>为你的系统添加需要的架构：
<pre><code>sudo dpkg --add-architecture arm64
</code></pre>
</li>
<li>你可能需要将下列镜像添加到<code>/etc/apt/sources.list</code>以便下载：
<pre><code>sudo sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
</code></pre>
第一条命令改变当前镜像为该系统的 amd64 架构的镜像。其他命令则将 arm64 部分添加到 /etc/apt/sources.list 文件中。</li>
<li>更新程序清单：
<pre><code>sudo apt-get update
</code></pre>
</li>
<li>为目标平台安装需要的依赖：
<pre><code>sudo apt-get install libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
</code></pre>
注意，软件包名称中的<code>:arm64</code>后缀。</li>
<li>运行build：
<pre><code>CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
你可以在 <code>.cargo/config.toml</code> （HOME下全局配置或在项目根目录下局部配置）中指定好链接器，这样你就不需要在命令中使用了：
<pre><code># .cargo/config.toml
[target.aarch64-unknown-linux-gnu]
linker = &quot;aarch64-linux-gnu-gcc&quot;
</code></pre>
之后便可以运行：
<pre><code>cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
</li>
</ul>
<h2 id="使用docker"><a class="header" href="#使用docker">使用docker</a></h2>
<p>直接使用目标平台的docker镜像可以让你免去使用cross交叉编译到不同linux target的麻烦。
你需要一个Dockerfile，来拉取你需要的target，并安装Rust和C++工具链以及所需的依赖。
例如，为allpine linux构建：</p>
<pre><code class="language-dockerfile">FROM alpine:latest AS alpine_build
RUN apk add rust cargo git cmake make g++ pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
COPY . .
RUN cargo build --release

FROM scratch AS export-stage
COPY --from=alpine_build target/release/&lt;your binary name&gt; .
</code></pre>
<p>然后运行：</p>
<pre><code>DOCKER_BUILDKIT=1 docker build --file Dockerfile --output out .
</code></pre>
<p>你的二进制文件将生成在<code>./out</code>目录中。
注意在alpine上，如果你通过rustup安装Rust，你可能需要在你的dockerfile中让musl-gcc和musl-g++指向相应的工具链（运行<code>cargo build</code>之前）。</p>
<pre><code class="language-dockerfile">RUN ln -s /usr/bin/x86_64-alpine-linux-musl-gcc /usr/bin/musl-gcc
RUN ln -s /usr/bin/x86_64-alpine-linux-musl-g++ /usr/bin/musl-g++
</code></pre>
<p>由于Rust工具链的这个问题<a href="https://github.com/rust-lang/rust/issues/61328">Issue-61328</a>，你可能还在编译时需要添加<code>-C target-feature=-crt-static</code>这个环境变量。</p>
<p>另一个例子是在 amd64 linux-gnu 编译 arm64 linux-gnu 程序：</p>
<pre><code class="language-dockerfile">FROM ubuntu:20.04 AS ubuntu_build

ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update -qq
RUN	apt-get install -y --no-install-recommends lsb-release g++-aarch64-linux-gnu g++ cmake curl tar git make
RUN apt-get install -y ca-certificates &amp;&amp; update-ca-certificates --fresh &amp;&amp; export SSL_CERT_DIR=/etc/ssl/certs
RUN	dpkg --add-architecture arm64 
RUN sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN	apt-get update -qq &amp;&amp; apt-get install -y --no-install-recommends -o APT::Immediate-Configure=0 libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
RUN curl https://sh.rustup.rs -sSf | sh -s -- --default-toolchain stable --profile minimal -y

ENV PATH=&quot;/root/.cargo/bin:$PATH&quot; \
	CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ \
	CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \
    CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc \
    CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++ \
    PKG_CONFIG_PATH=&quot;/usr/lib/aarch64-linux-gnu/pkgconfig/:${PKG_CONFIG_PATH}&quot;

RUN rustup target add aarch64-unknown-linux-gnu

COPY . .

RUN  cargo build --release --target=aarch64-unknown-linux-gnu

FROM scratch AS export-stage
COPY --from=ubuntu_build target/aarch64-unknown-linux-gnu/release/&lt;your binary name&gt; .
</code></pre>
<h2 id="使用cmake文件"><a class="header" href="#使用cmake文件">使用CMake文件</a></h2>
<p>文件的路径可以传递给 CFLTK_TOOLCHAIN 环境变量：</p>
<pre><code>CFLTK_TOOLCHAIN=$(pwd)/toolchain.cmake cargo build --target=&lt;your target&gt;
</code></pre>
<p>在较新版本的 CMake（3.20 以上）中，可以直接设置 CMAKE_TOOLCHAIN_FILE 环境变量。</p>
<p>CMake 文件的内容通常是，设置 CMAKE_SYSTEM_NAME 以及交叉编译器。 在 Linux/BSD 上还需要设置 PKG_CONFIG_EXECUTABLE 和 PKG_CONFIG_PATH。一个示例：</p>
<pre><code class="language-cmake">set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm64)

set(triplet aarch64-linux-gnu)
set(CMAKE_C_COMPILER /usr/bin/${triplet}-gcc)
set(CMAKE_CXX_COMPILER /usr/bin/${triplet}-g++)
set(ENV{PKG_CONFIG_EXECUTABLE} /usr/bin/${triplet}-pkg-config)
set(ENV{PKG_CONFIG_PATH} &quot;$ENV{PKG_CONFIG_PATH}:/usr/lib/${triplet}/pkgconfig&quot;)

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

</code></pre>
<p>注意 CMAKE_SYSTEM_PROCESSOR 通常是目标平台上 uname -m 的值，其他可能的值参见<a href="https://stackoverflow.com/questions/70475665/what-are-the-possible-values-of-cmake-system-processor/70498851#70498851">Possible Values</a>。 我们将此示例中的<code>triplet</code>变量设置为 aarch64-linux-gnu，这是用于 gcc/g++ 编译器以及 pkg-config 的前缀。 这个<code>triplet</code>也等同于 Rust <code>triplet</code> aarch64-unknown-linux-gnu。 PKG_CONFIG_PATH 设置为包含我们target的 <code>.pc</code> 文件的目录，这些是 Linux/BSD 上的 cairo 和 pango 依赖项所必需的。 最后 4 个选项可以防止CMake混淆host/taregt（当前机器和交叉编译的目标机器）的include/library的路径。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluid"><a class="header" href="#fluid">Fluid</a></h1>
<p>FLTK提供了一个名为FLUID的，所见即所得的快速GUI程序开发工具，它可以方便地编写GUI程序。
目前在Youtube上有一个教你基于Rust使用它的视频教程：
<a href="https://www.youtube.com/watch?v=k_P0wG3-dNk">Use FLUID (RAD tool) with Rust</a></p>
<p>fl2rust crate将Fluid生成的.fl文件转换成Rust代码，并编译进你的程序中。
要获取更多详细信息，请查看它的官方<a href="https://github.com/MoAlyousef/fl2rust">仓库</a>。</p>
<p>你可以使用cargo install 安装 fltk-fluid 和 fl2rust crate 来使用FLUID。</p>
<pre><code>cargo install fltk-fluid
cargo install fl2rust
</code></pre>
<p>然后运行：</p>
<pre><code>fluid &amp;
</code></pre>
<p>你也可以通过使用包管理器获取Fluid，这样的话它将作为一个单独的程序或者是fltk程序的一部分安装到你的系统中。</p>
<p>目前，fl2rust并不能确保生成的Rust代码的正确性。它的使用也只限于构造方法。</p>
<h2 id="用法-1"><a class="header" href="#用法-1">用法</a></h2>
<p>为了演示用法，我们使用<code>cargo new app</code>创建一个新的Rust项目。
fl2rust将作为 <code>build-dependdencies</code> 添加到你的项目中：</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
fltk = &quot;1&quot;

[build-dependencies]
fl2rust = &quot;0.4&quot;
</code></pre>
<p>然后在编译文件build.rs（该文件会在编译Rust程序时运行）中调用它提供的方法来将<code>.fl</code>文件转换成Rust代码。</p>
<pre><pre class="playground"><code class="language-rust edition2021">// build.rs
fn main() {
    use std::path::PathBuf;
    use std::env;
    println!(&quot;cargo:rerun-if-changed=src/myuifile.fl&quot;);
    let g = fl2rust::Generator::default();
    let out_path = PathBuf::from(env::var(&quot;OUT_DIR&quot;).unwrap());
    g.in_out(&quot;src/myuifile.fl&quot;, out_path.join(&quot;myuifile.rs&quot;).to_str().unwrap()).expect(&quot;Failed to generate rust from fl file!&quot;);
}
</code></pre></pre>
<p>我们在src目录下创建一个fluid文件 <code>myuifile.fl</code>。我们通过<code>println!</code>中的指令告诉Cargo，如果文件发生改变就重新运行脚本。这里的文件名和目录是为了演示而设置的，你可以自己选择目录，以及输入和输出的文件名。这里我们将<code>myuifile.fl</code>文件转换成<code>myuifile.rs</code>，它生成在<code>OUT_DIR</code>中，因此我们不会在<code>src</code>目录下看到它。
为了可以使用转换后的文件，你需要在<code>src</code>目录创建一个与上述的输出文件同名的文件：</p>
<pre><code>touch src/myuifile.rs
</code></pre>
<p>然后使用 <code>include</code> 宏，载入生成的文件中的内容。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/myuifile.rs
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(clippy::needless_update)]

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/myuifile.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>最后我们就可以在<code>main.rs</code>中使用这些内容了：</p>
<pre><pre class="playground"><code class="language-rust edition2021">// src/main.rs
use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>现在到了gui的编写部分，打开fluid：</p>
<pre><code class="language-bash">fltk-fluid &amp; # 如果从包管理器安装，只需要运行 fluid
</code></pre>
<p><code>&amp;</code>使终端将它作为一个独立的进程打开，所以我们仍然可以使用终端来使用cargo编译我们的代码，或者你可以打开另一个终端。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146925955-ac778726-1398-4ea2-8e46-a2f8fff89804.png" alt="image" /></p>
<p>我们看到的是一个空窗口和一个菜单栏。编写程序的第一步是创建一个类：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926284-cd9f21ce-b4b1-4009-9766-32876a08de98.png" alt="image" /></p>
<p>现在会弹出一个对话框，我们直接点击 &quot;OK &quot;让它使用默认的名称（UserInterface）。现在你会看到我们刚才创建的类出现在下面的列表中：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926505-545f26c1-ac7d-4f10-94a9-2d0c16875d4e.png" alt="image" /></p>
<p>接下来，再次点击new，为这个类添加一个构造函数：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926749-9199bd23-0346-4286-993f-bfb7588ae420.png" alt="image" /></p>
<p>同样使用它的默认名称，即<code>make_window()</code>。</p>
<p>接下来我们添加一个窗口：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926970-769ad7a1-9d03-457a-91f7-d6a18e2ba3b0.png" alt="image" /></p>
<p>现在出现了一个新的窗口，我们可以拖动边框放大它：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927099-ff014e0d-8ea0-4f90-a500-882eb7b49bb2.png" alt="image" /></p>
<p>双击窗口，这会弹出一个对话框，可以用来设置窗口的gui属性（在GUI标签下）、风格（在Style标签下）和类属性（在C++标签下）。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927520-c2ee18b1-0d17-43cd-93eb-edbf725ddf6c.png" alt="image" /></p>
<p>我们在GUI标签中给这个窗口设置<code>My Window</code>标签 ，然后在Style标签中把颜色改为白色：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932899-6a4419ae-9c91-4b48-a363-d87c85b01778.png" alt="image" /></p>
<p>在C++标签下，我们为这个窗口变量起个名字，<code>my_win</code>。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932794-7e1a2819-842d-45c7-88c8-be9fb728e805.png" alt="image" /></p>
<p>现在，可以通过<code>myuifile::UserInterface::my_win</code>访问窗口了。</p>
<p>之后，用鼠标左键点击窗口，然后添加一个Button（按钮）：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928089-ad0454de-252e-4e81-9079-db0ef5c67c8f.png" alt="image" /></p>
<p>这次我们选择Button。在C++标签下，我们为这个按钮变量起一个名字，<code>btn</code>。在style下，改变按钮的颜色和标签的颜色。然后在GUI下，把它的标签（按钮显示的文字） &quot;click me&quot;。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928419-a1a96e03-5b90-4aaa-8f70-9b17f76f9b9f.png" alt="image" /></p>
<p>可以拖动边框来调整大小，拖动按钮来改变它的位置。Fluid有一个Layout菜单，可以用它修改一组小部件（例如有很多按钮的情况），使其具有相同的布局/大小...等。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928654-43838e2a-aba8-4a24-8d70-1e25e1717c58.png" alt="image" /></p>
<p>现在点击<code>File/Save As...</code>将文件保存在src目录下，命名为<code>myuifile.fl</code>。</p>
<p>可以运行<code>cargo run</code>来看看能不能编译通过，但我们还没有调用<code>make_window()</code>方法，所以暂时还不会看到任何东西。
现在修改 src/main.rs 来让窗口可以显示出来，并为我们的按钮添加一个点击回调事件（callback）。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    let mut ui = myuifile::UserInterface::make_window();
    let mut win = ui.my_win.clone();
    ui.btn.set_callback(move |b| {
        b.set_label(&quot;clicked&quot;);
        win.set_label(&quot;Button clicked&quot;);
        println!(&quot;Works!&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-结构"><a class="header" href="#app-结构">App 结构</a></h1>
<p>Fltk crate的app模块中有一个App结构体。初始化App结构体，将会初始化所有内部样式、字体和支持的图像类型。它还会初始化程序将要在其中运行的多线程环境。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::*;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>run方法将会启动gui程序的事件循环（event loop）。
如果要对事件进行细粒度控制，可以使用wait()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::*;

fn main() {
    let app = app::App::default();
    while app.wait() {
        // 处理事件
    }
}
</code></pre></pre>
<p>此外，可以在App的实例上使用<code>with_scheme()</code>来设置程序的全局主题：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::*;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    app.run().unwrap();
}
</code></pre></pre>
<p>这将你的程序的主题设置为GTK。还有其他的内置主题方案，Basic、Plastic和Gleam（有一个<code>fltk-theme crate</code>提供了更多主题，你也可以自定义主题让它看起来更好看(^ο^)）。</p>
<p>还可以在App的实例上调用<code>load_system_fonts()</code>方法，让程序在启动时加载系统字体。</p>
<p>一个典型的fltk-rs程序将在创建任何组件并显示窗口之前创建App结构体。</p>
<p>任何写在调用<code>run()</code>方法后的代码，将在事件循环结束后执行（通常是关闭程序的所有窗口时，或者调用<code>quit()</code>方法时）。这包括必要时重启程序的指令等。</p>
<p>除了App结构体外，<code>app</code>模块本身还包含与你的程序的全局状态有关的结构体和自由函数。其中包括设置背景色和前景色，以及默认字体和大小等视觉效果，还有屏幕功能、剪贴板功能、全局事件处理器、程序事件、通道（发送器和接收器）和超时等。</p>
<p>其中一些将在本书的其他部分讨论。</p>
<pre><code>原文名词对照：
自由函数 - free functions
屏幕，剪切板功能 - screen functions, clipboard functions
全局事件处理器 - global handler
程序事件 - app events
通道，发送器和接收器 - channels, sender and receiver
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="窗口-windows"><a class="header" href="#窗口-windows">窗口 Windows</a></h1>
<p>FLTK在它支持的系统平台上调用原生窗口，然后基本上是自己绘制图形界面的。它会在windows上调用<code>HWND</code>，在MacOS上调用<code>NSWindow</code>，在X11系统（linux, BSD）上调用<code>XWindow</code>。</p>
<p>Window 与FLTK的其他组件具有相同的接口，<code>WidgetExt trait</code>。这将在下一节讨论。</p>
<p>让我们用到目前为止学到的东西来创建一个Window。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/244393458-7add4afc-11ec-47dc-b62e-68488ada132f.PNG" alt="img1" /></p>
</div>
<p>调用 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WidgetBase.html#tymethod.new">new()</a> 方法需要五个参数：</p>
<ul>
<li><code>x</code> 从电脑屏幕最左侧开始计算的水平距离。</li>
<li><code>y</code> 从电脑屏幕最上侧开始计算的垂直距离。</li>
<li><code>width</code> Window的宽度。</li>
<li><code>height</code> Window的高度。</li>
<li><code>title</code> Window的标题。</li>
</ul>
<p>这里还调用了 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.GroupExt.html#tymethod.end">end()</a> 方法。<code>GroupExt Trait</code>定义了<code>begin()</code>方法和<code>end()</code>方法，Window以及其他实现了该Trait的组件，将<strong>持有</strong>任何在 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.GroupExt.html#tymethod.begin">begin()</a> 和<code>end()</code>方法间创建的组件（通过<code>new()</code>创建Window时，隐式调用了<code>begin()</code>），或者成为这些组件的父组件。
调用 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WidgetExt.html#tymethod.show">show()</a> 会让Window出现在屏幕上。</p>
<h2 id="嵌入窗口"><a class="header" href="#嵌入窗口">嵌入窗口</a></h2>
<p>Window可以被嵌入到其他Window内：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut my_window2 = window::Window::new(10, 10, 380, 280, None);
    my_window2.set_color(Color::Black);
    my_window2.end();
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/244393452-8b8f11ef-036a-4be6-8d6f-b49418322f3c.PNG" alt="embed" /></p>
</div>
<p>在这里创建了第二个窗口<code>my_window2</code>，它会被嵌入到第一个窗口<code>my_window</code>里面。我们把它的颜色设为黑色，这样我们才能注意到它。注意，它的父组件是第一个Window。在父窗口外创建第2个窗口才会创建出两个独立的窗口，需要注意每个窗口都需要调用<code>show()</code>方法才会显示：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, None);
    my_window.end();
    my_window.show();
    let mut my_window2 = window::Window::new(10, 10, 380, 280, &quot;&quot;);
    my_window2.end();
    my_window2.show();
    app.run().unwrap();
}
</code></pre></pre>
<p>可以使用<code>my_window.set_border(false)</code>方法取消<code>my_window</code>的边框，实现无边框窗口：</p>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/100937639-565cdd80-3504-11eb-8cf6-e135243c38b0.png" alt="image" /></p>
</div>
<p><a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WindowExt.html#tymethod.set_border">set_border(bool)</a> 方法也定义在<code>WindowExt trait</code>中，除了直线了<code>WidgetExt Trait</code>和<code>GroupExt Trait</code>的组件外（实现<code>WindowExt</code>需要实现<code>GroupExt</code>，实现<code>GroupExt</code>需要实现<code>WidgetExt</code>），FLTK中的所有窗口类型都实现了该Trait。
所有的Trait可以在fltk crate的<code>fltk::prelude</code>模块中找到：</p>
<p><a href="https://docs.rs/fltk/*/fltk/prelude/index.html">FLTK Trait文档</a></p>
<h2 id="全屏"><a class="header" href="#全屏">全屏</a></h2>
<p>如果你想使用 fltk-rs 开发沉浸式的应用程序，为了充分使用屏幕空间，你可以在需要全屏显示的窗口上应用 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WindowExt.html#tymethod.fullscreen">fullscreen(bool)</a> 方法，将其设为 <code>true</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.fullscreen(true);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glutwindow"><a class="header" href="#glutwindow">GlutWindow</a></h1>
<p>fltk-rs 通过 <code>GlutWindow</code> 提供了 OpenGL Glut 窗口的支持。
下面列举出了使用该组件需要添加的依赖以及其所有关联函数。</p>
<h2 id="开发依赖"><a class="header" href="#开发依赖">开发依赖</a></h2>
<p>你的电脑需要配置有 <code>Git</code> 和 <code>CMake</code> 才可以使用 <code>GlutWindow</code>。</p>
<ol>
<li>
<p>安装CMake和Git： 确保它们已经被正确安装，且已经配置在你的系统的PATH环境变量中. 可以点击这里从官网下载 <a href="https://cmake.org/download/">CMake</a> 和 <a href="https://git-scm.com/downloads">Git</a> 。</p>
</li>
<li>
<p>验证PATH的配置： 在安装上述软件后，测试是否可以通过命令行执行它们。 打开你的终端或命令提示符，输入<code>cmake --version</code> and <code>git --version</code> 来验证。</p>
</li>
<li>
<p>验证库路径： 若编译失败，提示无法找到 <code>fltk_gl</code> 库，你可能需要使用 <code>-L</code> 验证库路径是否正确。确定 <code>fltk_gl</code> 库在你系统中的位置，并在构建命令中添加适当的标记，例如： </p>
<pre><code class="language-bash">cargo build -L /path/to/fltk_gl/library
</code></pre>
<p>将 <code>/path/to/fltk_gl/library</code> 替换为你的系统中 <code>fltk_gl</code> 的实际地址。</p>
</li>
<li>
<p>验证程序依赖： 仔细检查 <code>Cargo.toml</code> 文件中配置的依赖项是否正确，确保你添加了正确版本的 <code>fltk</code> 和 <code>fltk-sys</code> 的依赖项:</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;1.4.4&quot;, features = [&quot;enable-glwindow&quot;] }
</code></pre>
</li>
<li>
<p>清除缓存并重编译：如果上述步骤没有解决你的问题，尝试清除构建文件并重新进行编译。使用以下命令清理构建文件:</p>
<pre><code class="language-bash">cargo clean
</code></pre>
<p>清理后重新运行编译:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>完成上述步骤后，你应该能够成功构建你的项目了。</p>
</li>
</ol>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<pre><code>此部分翻译内容较不准确，，请参见原文：[GlutWindow](https://fltk-rs.github.io/fltk-book/GlutWindow.html)
</code></pre>
<ul>
<li><code>default()</code>: 创建一个默认的初始化的窗口</li>
<li><code>get_proc_address(&amp;self, s: &amp;str)</code>: 获取一个OpenGL程序的地址</li>
<li><code>flush(&amp;mut self)</code>: 强制窗口绘制并调用 <code>draw()</code> 方法</li>
<li><code>valid(&amp;self)</code>: 返回表示OpenGL上下文是否存在的布尔值</li>
<li><code>set_valid(&amp;mut self, v: bool)</code>: 标记OpenGL上下文为有效</li>
<li><code>context_valid(&amp;self)</code>: 返回表示创建时上下文是否有效的布尔值</li>
<li><code>set_context_valid(&amp;mut self, v: bool)</code>: 标记创建时上下文为有效</li>
<li><code>context(&amp;self)</code>: 返回 GlContext.</li>
<li><code>set_context(&amp;mut self, ctx: GlContext, destroy_flag: bool)</code>: 设置 GlContext.</li>
<li><code>swap_buffers(&amp;mut self)</code>: 清除前后端缓冲区</li>
<li><code>ortho(&amp;mut self)</code>: Sets the projection so 0,0 is in the lower left of the window and each pixel is 1 unit wide/tall.</li>
<li><code>can_do_overlay(&amp;self)</code>: 返回表示 GlutWindow 是否可以覆盖的布尔值</li>
<li><code>redraw_overlay(&amp;mut self)</code>: 重绘并覆盖</li>
<li><code>hide_overlay(&amp;mut self)</code>: 隐藏覆盖层</li>
<li><code>make_overlay_current(&amp;mut self)</code>: 使覆盖层即时</li>
<li><code>pixels_per_unit(&amp;self)</code>: 返回每 unit/point 的像素值</li>
<li><code>pixel_w(&amp;self)</code>: 返回窗口宽度的像素值</li>
<li><code>pixel_h(&amp;self)</code>: 返回窗口高度的像素值</li>
<li><code>mode(&amp;self)</code>: 返回 GlutWindow 的模式</li>
<li><code>set_mode(&amp;mut self, mode: Mode)</code>: 设置 GlutWindow 的模式</li>
</ul>
<p>可以查阅官方文档获取 <code>GlWindow</code> 的更多信息 <a href="https://docs.rs/fltk/latest/fltk/window/struct.GlutWindow.html">官方文档</a>.</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<h3 id="绘制一个三角形-opengl-triangle"><a class="header" href="#绘制一个三角形-opengl-triangle">绘制一个三角形 OpenGL Triangle</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    prelude::*,
    *,
    image::IcoImage
};
use glow::*;
fn main() {
    let app = app::App::default();
    let mut win = window::GlWindow::default().with_size(800, 600);
    let icon: IcoImage = IcoImage::load(&amp;std::path::Path::new(&quot;src/fltk.ico&quot;)).unwrap();
    win.make_resizable(true);
    win.set_icon(Some(icon));
    win.set_mode(enums::Mode::Opengl3);
    win.end();
    win.show();
    unsafe {
        let gl = glow::Context::from_loader_function(|s| {
            win.get_proc_address(s) as *const _
        });
        let vertex_array = gl
            .create_vertex_array()
            .expect(&quot;Cannot create vertex array&quot;);
        gl.bind_vertex_array(Some(vertex_array));
        let program = gl.create_program().expect(&quot;Cannot create program&quot;);
        let (vertex_shader_source, fragment_shader_source) = (
            r#&quot;const vec2 verts[3] = vec2[3](
                vec2(0.5f, 1.0f),
                vec2(0.0f, 0.0f),
                vec2(1.0f, 0.0f)
            );
            out vec2 vert;
            void main() {
                vert = verts[gl_VertexID];
                gl_Position = vec4(vert - 0.5, 0.0, 1.0);
            }&quot;#,
            r#&quot;precision mediump float;
            in vec2 vert;
            out vec4 color;
            void main() {
                color = vec4(vert, 0.5, 1.0);
            }&quot;#,
        );
        let shader_sources = [
            (glow::VERTEX_SHADER, vertex_shader_source),
            (glow::FRAGMENT_SHADER, fragment_shader_source),
        ];
        let mut shaders = Vec::with_capacity(shader_sources.len());
        for (shader_type, shader_source) in shader_sources.iter() {
            let shader = gl
                .create_shader(*shader_type)
                .expect(&quot;Cannot create shader&quot;);
            gl.shader_source(shader, &amp;format!(&quot;#version 410\n{}&quot;, shader_source));
            gl.compile_shader(shader);
            if !gl.get_shader_compile_status(shader) {
                panic!(&quot;{}&quot;, gl.get_shader_info_log(shader));
            }
            gl.attach_shader(program, shader);
            shaders.push(shader);
        }
        gl.link_program(program);
        if !gl.get_program_link_status(program) {
            panic!(&quot;{}&quot;, gl.get_program_info_log(program));
        }
        for shader in shaders {
            gl.detach_shader(program, shader);
            gl.delete_shader(shader);
        }
        gl.use_program(Some(program));
        gl.clear_color(0.1, 0.2, 0.3, 1.0);
        win.draw(move |w| {
            gl.clear(glow::COLOR_BUFFER_BIT);
            gl.draw_arrays(glow::TRIANGLES, 0, 3);
            w.swap_buffers();
        });
    }
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://raw.githubusercontent.com/fltk-rs/demos/master/glow/ex.jpg" alt="gl-img" /></p>
<h3 id="拖动旋转-rotate"><a class="header" href="#拖动旋转-rotate">拖动旋转 Rotate</a></h3>
<p>这个示例使用了 <code>GlWindow</code> 创建了一个 <code>OpenGL</code> 窗口，并在窗口中绘制了一个三角形，你可以通过拖动鼠标来使它旋转 <a href="https://github.com/fltk-rs/demos/tree/master/opengl">示例地址</a>.</p>
<div align="center">
<p><img src="https://raw.githubusercontent.com/fltk-rs/demos/master/opengl/ex.jpg" alt="rotate" /></p>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="组件-widgets"><a class="header" href="#组件-widgets">组件 Widgets</a></h1>
<p>FLTK提供了80多个组件。这些组件都实现了<code>WidgetBase</code>和<code>WidgetExt</code>组成的基本集合。 我们已经见过了我们的第一个组件，Window组件。
正如我们在Window组件中了解的，基于功能的不同，不同的组件还会各自实现其他Trait。
在我们之前写的例子中添加一个按钮：</p>
<pre><pre class="playground"><code class="language-rust edition2021">uuse fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<div align="center">
![image](https://user-images.githubusercontent.com/37966791/100937814-adfb4900-3504-11eb-8a6b-f42a4fb4e470.png)
</div>
<p>注意，这个按钮的父组件是my_window，因为它是在隐式调用的<code>begin()</code>和<code>end()</code>之间创建的。
在程序中添加组件的另一种方法是，在实现了<code>GroupExt Trait</code>的Widget上调用该Trait提供的<code>add(widget)</code>方法。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();

    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.add(&amp;but);

    app.run().unwrap();
}
</code></pre></pre>
<p>需要注意一下按钮的初始化方式，它的构造方法基本上与Window相同，因为<code>new()</code>方法是定义在<code>WidgetBase trait</code>中的，而大部分组件都实现了这个Trait。注意，虽然Window的x和y坐标是相对于屏幕而言的，但按钮的x和y坐标却是相对于作为按钮父组件的的Window而言的。你可能已经注意到了这一点，这也适用于我们在上一节中提到的嵌入在另一个窗口中的窗口。</p>
<p>Button组件也实现了<code>ButtonExt trait</code>，它定义了一些有用的方法，比如设置快捷键<code>Shortcut</code>来通过其他方法触发我们的按钮。</p>
<p>也可以使用构建器模式来创建一个组件：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let but1 = Button::new(10, 10, 80, 40, &quot;Button 1&quot;);
// 下面为构建器模式
let but1 = Button::default()
    .with_pos(10, 10)
    .with_size(80, 40)
    .with_label(&quot;Button 1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>它们的效果基本是相同的。</p>
<p>目前位置，我们的程序会显示一个窗口和其中的按钮。这个按钮可以点击，但什么用都没有！但别担心，在下一节中，我们将学习为它添加一些行为（Actions）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="按钮-buttons"><a class="header" href="#按钮-buttons">按钮 Buttons</a></h1>
<p>Button组件的用处很多，它有多种形式：</p>
<ul>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.Button.html">Button</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.CheckButton.html">CheckButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.LightButton.html">LightButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RadioButton.html">RadioButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RadioLightButton.html">RadioLightButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RadioRoundButton.html">RadioRoundButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RepeatButton.html">RepeatButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.ReturnButton.html">ReturnButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RoundButton.html">RoundButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.ShortcutButton.html">ShortcutButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.ToggleButton.html">ToggleButton</a></li>
</ul>
<p>这些组件可以在 <code>Button mod</code> 中找到。
其中最简单的就是<code>Button</code>组件，它能在发生点击事件时执行一些行为。当然所有的按钮都可以这样：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();

}
</code></pre></pre>
<p>其他一些按钮可以带有表示自己某些属性的其他值：
例如<code>CheckButton</code>, <code>ToggleButton</code>, <code>LightButton</code> 带有表示它们当前状态（比如，是否被选中）的信息。</p>
<p>单选按钮（<code>RadioRoundButton</code>、<code>RadioLightButton</code>和<code>RadioButton</code>）也带有它们的一些值，但在父组件（任何实现<code>GroupExt</code>的组件都可以作为父组件）中只有一个可以被选中。因此说，这些组件是可以访问到同一个组合中其他相应组件的值的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    // 用户同一时间只能选中一个按钮，选中后，另一个会被取消选中
    let btn1 = button::RadioRoundButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::RadioRoundButton::default().with_label(&quot;Option 2&quot;); 
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>可以用<code>clear_visible_focus()</code>方法来取消焦点（<code>btn1.clear_visible_focus()</code>）</p>
<div align="center">
![image](https://user-images.githubusercontent.com/37966791/145727291-8be40de6-8ec6-4e57-bb29-fa0f0ac3b251.png)
</div>
<p>其他可选择的按钮没有这个属性。</p>
<p><code>ButtonExt::value()</code>方法会返回一个布尔值，表示一个按钮是否被选中：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn2 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><code>CheckButton</code>还提供了一个方便的方法<code>is_checked()</code>，一系列<code>RadioButton</code>提供了<code>is_toggled()</code>用来判断：</p>
<div align="center">
![image](https://user-images.githubusercontent.com/37966791/145727325-7e5bb45f-674e-4bb2-81c8-27d0ee391d34.png)
</div>
<p>默认情况下，可选择的按钮在创建时都是没有选中的，但这可以用<code>set_value()</code>，（<code>CheckButton</code>可以使用的）<code>set_checked()</code>和（RadioButton可以使用的）<code>set_toggled()</code>等方法来默认选中一个按钮：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let mut btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    btn1.set_value(true);
    // 同样可以使用 btn1.set_checked(true)
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn2 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<div align="center">
![image](https://user-images.githubusercontent.com/37966791/145727352-bf6dba5c-1a0c-4da4-8296-093e10470f0c.png)
</div>
<h1 id="组件效果预览"><a class="header" href="#组件效果预览">组件效果预览</a></h1>
<div align="center">
<h3 id="button"><a class="header" href="#button">Button</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810478-9bb5dd60-714c-4407-b7b5-c3ab060af70b.PNG" alt="Button" /></p>
<h3 id="checkbutton"><a class="header" href="#checkbutton">CheckButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810469-2414d2aa-8a7d-461e-ae39-768a5fe3e99d.PNG" alt="CheckButton" /></p>
<h3 id="lightbutton"><a class="header" href="#lightbutton">LightButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810476-22dda4d2-c8b4-4f24-bd0a-da672877bb9b.PNG" alt="LightButton" /></p>
<h3 id="radiobutton"><a class="header" href="#radiobutton">RadioButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810480-07a9c7b6-7578-4678-8b99-342a00dfb978.PNG" alt="RadioButton" /></p>
<h3 id="radiolightbutton"><a class="header" href="#radiolightbutton">RadioLightButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810483-f5a4602a-34dd-4312-bdd3-9773d9207854.PNG" alt="RadioLightButton" /></p>
<h3 id="radioroundbutton"><a class="header" href="#radioroundbutton">RadioRoundButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810485-e842f808-0be9-44ac-971e-4ea549cd5b23.PNG" alt="RadioRoundButton" /></p>
<h3 id="repeatbutton"><a class="header" href="#repeatbutton">RepeatButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810489-d1c29b47-c51a-46c9-9948-179bc9802a76.PNG" alt="RepeatButton" /></p>
<h3 id="roundbutton"><a class="header" href="#roundbutton">RoundButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810490-b5b9fcfd-38c8-4108-99d6-d22f50f7496e.PNG" alt="RoundButton" /></p>
<h3 id="shortcutbutton"><a class="header" href="#shortcutbutton">ShortcutButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810494-88930640-862a-4825-9592-488046da8907.PNG" alt="ShortcutButton" /></p>
<h3 id="togglebutton"><a class="header" href="#togglebutton">ToggleButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810496-25c7b144-fb9c-44de-b1f8-02b0586eb391.PNG" alt="ToggleButton" /></p>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="标签-labels"><a class="header" href="#标签-labels">标签 Labels</a></h1>
<p>FLTK没有可以用来显示文字的Label组件，但很多组件都具有Label属性。如果你想显示文本的话，你可以使用一个<code>Frame</code>组件，然后为它添加Label属性。</p>
<p>所有组件都可以使用<code>::new()</code>构造函数来创建并设置Label，或者也可以用<code>with_label()</code>或<code>set_label()</code>来设置。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::new(160, 200, 80, 30, &quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>这个按钮上带有 &quot;Click&quot; 文字。</p>
<p>我们也可以使用<code>set_label()</code>或<code>with_label()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::default().with_label(&quot;Click&quot;);
// 或者
let mut btn = button::Button::default();
btn.set_label(&quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>然而，使用<code>::new()</code>方法来添加Label属性，需要的字符串是类型<code>&amp;'static str</code>，所以下面的代码不能正确运行：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let label = String::from(&quot;Click&quot;);  // label变量不是 &amp;'static str
let mut btn = button::Button::new(160, 200, 80, 30, &amp;label);
<span class="boring">}
</span></code></pre></pre>
<p>在这种情况下，你应该使用<code>btn.set_label(&amp;label);</code>。原因是FLTK本身要求传入的字符串是类型是<code>const char *</code> ，对应于Rust中则是<code>&amp;'static str</code>。这些字符串保存在程序的二进制代码中。如果你反汇编一个程序，是可以看到这些字符串的。这些字符串具有静态生命周期，因此FLTK在创建组件Label时默认不会保存下这些字符串。而当使用<code>set_label()</code>和<code>with_label()</code>时，FLTK将调用<code>Fl_Widget::copy_label()</code>，并将字符串进行存储。</p>
<p>Label不限于文字，FLTK预定义了一些符号，在Label中可以转换成图像。</p>
<div align="center">
![symbols](https://www.fltk.org/doc-1.4/symbols.png)
</div>
<p><code>@</code>符号除了可以用来使用这些符号图像外，还可以加上下面这些格式化字符，其顺序和规则如下：</p>
<ul>
<li>'#'表示强制进行规则的缩放，因此可以避免组件的形状被扭曲。</li>
<li>+[1-9]或-[1-9]可以改变缩放比例。</li>
<li>'$'是水平翻转符号，'%'是垂直翻转符号。</li>
<li>[0-9] - 旋转45度的倍数。是'5'和'6'时不会发生旋转，而其他数字则会使其指向数字键盘上那个键的方向。</li>
<li>'0xxxx'，0后有四个数字表示角度，会使其按该度数旋转。</li>
</ul>
<p>因此，如果要显示一个非常大的指向下方的箭头，你可以使用标签字符串&quot;@+92-&gt;&quot;。</p>
<p>符号和文本可以结合在一个Label中，但是符号必须放在文本的开头或结尾处。如果有多行文本，那么符号将被按比例放大以匹配所有行的高度：</p>
<div align="center">
![ex](https://www.fltk.org/doc-1.4/symbol-examples.png)
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="组控件-group-widgets"><a class="header" href="#组控件-group-widgets">组控件 Group widgets</a></h1>
<p>组控件包括窗口类型和在<code>Group</code> mod中的其他组件，如：Group，Scroll，Pack，Tile，Flex ...等等。
它们都实现了<code>GroupExt Trait</code>，该Trait中定义了<code>end()</code>方法，这些控件必须调用<code>::end()</code>方法来表示其包含的范围结束：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>在上面的例子中，按钮 &quot;_btn&quot; 的父组件是Window。
在组控件调用<code>end()</code>后创建的其他组件将不被包含在该控件中，即会创建在这个组控件的外面。
但这些组件仍然可以使用<code>::add(&amp;other_widget)</code>或<code>::insert</code>添加进组控件中。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    let btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.add(&amp;btn);
    
    a.run().unwrap();
}
</code></pre></pre>
<p>另一个选择是重新调用组控件的<code>begin()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.begin();
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();

    a.run().unwrap();
}
</code></pre></pre>
<p>多数实现<code>GroupExt</code>的组控件需要手动布局，但还有几个控件可以自动布局。比如<code>Flex</code>组件，它会在 <a href="Layouts.html">布局 layout</a> 中介绍。<code>Pack</code>需要设置子组件的高度（height）或宽度（width）进行布局，这取决于Pack是垂直的还是水平的。</p>
<p>Pack默认是垂直的（Vertical），我们只需要设置其中子组件的高度：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(200, 300);
    let mut pack = group::Pack::default_fill();
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(0, 40).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(0, 40);
    }
    frame::Frame::default().with_size(0, 40); // 占位
    button::Button::default().with_size(0, 40).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727469-a7181ebf-a3a3-4675-af23-ec40d847a593.png" alt="image" /></p>
<p>要设置水平（horizontal）的Pack，我们需要手动设置<code>with_type()</code>，然后只需要设置其中子组件的宽度：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(300, 100);
    let mut pack = group::Pack::default_fill().with_type(group::PackType::Horizontal);
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(40, 0).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(40, 0);
    }
    frame::Frame::default().with_size(40, 0); // 占位
    button::Button::default().with_size(40, 0).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="菜单-menus"><a class="header" href="#菜单-menus">菜单 Menus</a></h1>
<p>FLTK提供了菜单组件，它们均实现了 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.MenuExt.html">MenuExt</a> trait。Menu组件有下面这几种：</p>
<ul>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuBar.html">MenuBar</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuButton.html">MenuButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuItem.html">MenuItem</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.Choice.html">Choice</a> (下拉列表)</li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.SysMenuBar.html">SysMenuBar</a> (在MacOS出现在屏幕顶部的menu bar)</li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MacAppMenu.html">MacAppMenu</a></li>
</ul>
<p>Menu主要有两方面的作用：</p>
<ol>
<li>
<p>使用 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.MenuExt.html#tymethod.add_choice">add_choice()</a> 方法添加菜单选项，然后在设置回调处理不同选项执行的操作：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1&quot;);
    choice.add_choice(&quot;Choice 2&quot;);
    choice.add_choice(&quot;Choice 3&quot;);
    // 也可以直接输入 choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        match c.value() {
            0 =&gt; println!(&quot;choice 1 selected&quot;),
            1 =&gt; println!(&quot;choice 2 selected&quot;),
            2 =&gt; println!(&quot;choice 3 selected&quot;),
            _ =&gt; unreachable!(),
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
</li>
</ol>
<div align="center">
![image](https://user-images.githubusercontent.com/37966791/145727397-dd713782-9f8e-474b-b009-f2ebeb5170ea.png)
</div>
<p>另外，你也可以解构出菜单选项的字符串来进行匹配：</p>
<pre><code>```rust
use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        if let Some(choice) = c.choice() {
            match choice.as_str() {
                &quot;Choice 1&quot; =&gt; println!(&quot;choice 1 selected&quot;),
                &quot;Choice 2&quot; =&gt; println!(&quot;choice 2 selected&quot;),
                &quot;Choice 3&quot; =&gt; println!(&quot;choice 3 selected&quot;),
                _ =&gt; unreachable!(),
            }
        }
    });

    app.run().unwrap();
}
```
</code></pre>
<ol start="2">
<li>
<p>通过 <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.MenuExt.html#tymethod.add">add()</a> 方法添加菜单选项，你需要在其中设置好每个选项的回调：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()

    choice.add(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 1 selected&quot;),
        );
    choice.add(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 2 selected&quot;),
        );
    choice.add(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 3 selected&quot;),
        );

    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>另外在 <a href="Events">事件 Events</a> 还会提到，你可以直接传递一个函数而不适用闭包：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn menu_cb(m: &amp;mut impl MenuExt) {
    if let Some(choice) = m.choice() {
        match choice.as_str() {
            &quot;New\t&quot; =&gt; println!(&quot;New&quot;),
            &quot;Open\t&quot; =&gt; println!(&quot;Open&quot;),
            &quot;Third&quot; =&gt; println!(&quot;Third&quot;),
            &quot;Quit\t&quot; =&gt; {
                println!(&quot;Quitting&quot;);
                app::quit();
            },
            _ =&gt; println!(&quot;{}&quot;, choice),
        }
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut menubar = menu::MenuBar::new(0, 0, 400, 40, &quot;rew&quot;);
    menubar.add(&quot;File/New\t&quot;, Shortcut::None, menu::MenuFlag::Normal, menu_cb);
    menubar.add(
        &quot;File/Open\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let idx = menubar.add(
        &quot;File/Recent&quot;,
        Shortcut::None,
        menu::MenuFlag::Submenu,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/First\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/Second\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Quit\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let mut btn1 = button::Button::new(160, 150, 80, 30, &quot;Modify 1&quot;);
    let mut btn2 = button::Button::new(160, 200, 80, 30, &quot;Modify 2&quot;);
    let mut clear = button::Button::new(160, 250, 80, 30, &quot;Clear&quot;);
    win.end();
    win.show();

    btn1.set_callback({
        let menubar = menubar.clone();
        move |_| {
            if let Some(mut item) = menubar.find_item(&quot;File/Recent&quot;) {
                item.add(
                    &quot;Recent/Third&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
                item.add(
                    &quot;Recent/Fourth&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
            }
        }
    });

    btn2.set_callback({
        let mut menubar = menubar.clone();
        move |_| {
            menubar.add(
                &quot;File/Recent/Fifth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
            menubar.add(
                &quot;File/Recent/Sixth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
        }
    });

    clear.set_callback(move |_| {
        menubar.clear_submenu(idx).unwrap();
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>此外，你还可以使用<code>add_emit()</code>方法来传递一个<code>sender</code>和一个<code>message</code>，这样就不用直接使用回调，而是可以集中在<code>App::wait()</code>中处理：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

#[derive(Clone)]
enum Message {
    Choice1,
    Choice2,
    Choice3,
}

fn main() {
    let a = app::App::default();
    let (s, r) = app::channel();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label(&quot;Select item&quot;);

    choice.add_emit(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice1,
    );
    choice.add_emit(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice2,
    );
    choice.add_emit(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s,
        Message::Choice3,
    );

    wind.end();
    wind.show();

    while a.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                Message::Choice1 =&gt; println!(&quot;choice 1 selected&quot;),
                Message::Choice2 =&gt; println!(&quot;choice 2 selected&quot;),
                Message::Choice3 =&gt; println!(&quot;choice 3 selected&quot;),
            }
        }
    }
}
</code></pre></pre>
</li>
</ol>
<p>你可能会问，为什么不直接用第一个例子那样简单的代码，还要使用其他更复杂的方式完成回调方法。其实每种方法都有它的用途。
对于简单的<strong>下拉菜单</strong>，用第一种方法会更加方便。对于程序的<strong>菜单栏</strong>，用第二种方法会更好，它可以让你为菜单选项设置快捷键<code>Shortcuts</code>和选项的类型<a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuFlag.html">MenuFlags</a>（例如下拉菜单，选择选项，用于分隔的占位菜单等），另外你不用再像第一个例子一样，在菜单的回调中处理所有事件。使用<code>add_emit()</code>方法处理子菜单一样很容易，就像在<a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/editor.rs">编辑器示例</a>中那样：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut menu = menu::SysMenuBar::default().with_size(800, 35);
    menu.set_frame(FrameType::FlatBox);
    menu.add_emit(
        &quot;&amp;File/New...\t&quot;,
        Shortcut::Ctrl | 'n',
        menu::MenuFlag::Normal,
        *s,
        Message::New,
    );

    menu.add_emit(
        &quot;&amp;File/Open...\t&quot;,
        Shortcut::Ctrl | 'o',
        menu::MenuFlag::Normal,
        *s,
        Message::Open,
    );

    menu.add_emit(
        &quot;&amp;File/Save\t&quot;,
        Shortcut::Ctrl | 's',
        menu::MenuFlag::Normal,
        *s,
        Message::Save,
    );

    menu.add_emit(
        &quot;&amp;File/Save as...\t&quot;,
        Shortcut::Ctrl | 'w',
        menu::MenuFlag::Normal,
        *s,
        Message::SaveAs,
    );

    menu.add_emit(
        &quot;&amp;File/Print...\t&quot;,
        Shortcut::Ctrl | 'p',
        menu::MenuFlag::MenuDivider,
        *s,
        Message::Print,
    );

    menu.add_emit(
        &quot;&amp;File/Quit\t&quot;,
        Shortcut::Ctrl | 'q',
        menu::MenuFlag::Normal,
        *s,
        Message::Quit,
    );

    menu.add_emit(
        &quot;&amp;Edit/Cut\t&quot;,
        Shortcut::Ctrl | 'x',
        menu::MenuFlag::Normal,
        *s,
        Message::Cut,
    );

    menu.add_emit(
        &quot;&amp;Edit/Copy\t&quot;,
        Shortcut::Ctrl | 'c',
        menu::MenuFlag::Normal,
        *s,
        Message::Copy,
    );

    menu.add_emit(
        &quot;&amp;Edit/Paste\t&quot;,
        Shortcut::Ctrl | 'v',
        menu::MenuFlag::Normal,
        *s,
        Message::Paste,
    );

    menu.add_emit(
        &quot;&amp;Help/About\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        *s,
        Message::About,
    );

    if let Some(mut item) = menu.find_item(&quot;&amp;File/Quit\t&quot;) {
        item.set_label_color(Color::Red);
    }
<span class="boring">}
</span></code></pre></pre>
<p>注意最后一个调用，它使用<code>find_item()</code>方法，在菜单中匹配到符合的选项，然后把它的Label颜色设为红色：</p>
<div align="center">
![image](https://user-images.githubusercontent.com/37966791/145727434-d66c6d55-018d-4341-9570-7c2864b5bf29.png)
</div>
<h2 id="系统菜单栏"><a class="header" href="#系统菜单栏">系统菜单栏</a></h2>
<p>在MacOS上，你可能更喜欢使用系统提供的菜单栏，它通常出现在屏幕的顶部。为此可以使用 <a href="https://docs.rs/fltk/latest/fltk/menu/struct.SysMenuBar.html#">SysMenuBar</a> 组件。它与所有实现<code>MenuExt Trait</code>的组件具有相同的API，当程序为MacOS以外的其他目标平台编译时，该组件将变为一个普通的<code>MenuBar</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出-input--output"><a class="header" href="#输入输出-input--output">输入输出 Input &amp; Output</a></h1>
<p>FLTK提供的输入/输出组件均实现了<code>InputExt trait</code>。在<code>Input</code>和<code>Output</code> mod中可以找到这些组件：</p>
<ul>
<li>Input</li>
<li>IntInput</li>
<li>FloatInput</li>
<li>MultilineInput</li>
<li>SecretInput</li>
<li>FileInput</li>
<li>Output</li>
<li>MultilineOutput</li>
</ul>
<p>实现了<code>InputExt trait</code>的组件都会携带一个文本值，对应用户输入的文本，可以用<code>value()</code>方法获得文本值，用<code>set_value()</code>方法修改文本值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727249-2fa4d384-2bd3-41fd-bbae-61a3a33b12f6.png" alt="image" /></p>
<p>需要注意的是，我们使用了<code>IntInput</code>来限制用户只能输入整数值。虽然用户不能再输入字符了，但就开发者而言，<code>value()</code>获取到的文本值仍然是一个<code>String</code>。</p>
<p><code>Output</code>组件的值不能被用户修改，可以视作一个无法编辑的输入框：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(200, 50).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Check this text:&quot;);
    let mut output = output::Output::default();
    output.set_value(&quot;You can't edit this!&quot;);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727261-88ec533f-200b-4df7-a570-76ebd2ba520a.png" alt="image" /></p>
<p>也可以使用<code>InputExt::set_readonly(bool)</code>方法将<code>Input</code>组件设置为只读：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let mut input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
        input.set_readonly(true);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>这会在用户输入内容并按下按钮后让文本框不可修改。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="估值器-valuators"><a class="header" href="#估值器-valuators">估值器 Valuators</a></h1>
<p>FLTK提供的<code>Valuator</code>组件均实现了<code>ValuatorExt trait</code>。这些组件会在内部跟踪步长<code>step</code>，范围<code>range</code>和边界<code>bound</code>这些数据，你会在图形界面上看到它们的具体作用。
你可能在别的地方使用过<code>Scrollbar</code>和<code>Sliders</code>这些组件。可以在<code>Valuator</code> mod中找到这些组件：</p>
<ul>
<li>Slider</li>
<li>NiceSlider</li>
<li>ValueSlider</li>
<li>Dial</li>
<li>LineDial</li>
<li>Counter</li>
<li>Scrollbar</li>
<li>Roller</li>
<li>Adjuster</li>
<li>ValueInput</li>
<li>ValueOutput</li>
<li>FillSlider</li>
<li>FillDial</li>
<li>HorSlider (Horizontal slider)</li>
<li>HorFillSlider</li>
<li>HorNiceSlider</li>
<li>HorValueSlider</li>
</ul>
<p>在图形界面通过拖动等方式改变<code>Valuator</code>的值会触发其回调。<code>Valuator</code>的当前值可以通过<code>value()</code>方法来获取，可以用<code>set_value()</code>来设置其值。根据使用情况，你也可以获取和改变<code>range</code>和<code>step</code>的值：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut slider = valuator::HorNiceSlider::default().with_size(400, 20).center_of_parent();
    slider.set_minimum(0.);
    slider.set_maximum(100.);
    slider.set_step(1., 1); // 设置步长为10
    slider.set_value(50.); // 设置开始
    win.end();
    win.show();

    slider.set_callback(|s| {
        println!(&quot;slider at {}&quot;, s.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727188-4ac06d45-7fd1-44f7-9adc-366d9bb79d8f.png" alt="image" /></p>
<p>下面列举了使用不同的 <code>Valuator</code> 组件实现这个例子的效果：</p>
<details>
<summary><b>展开查看示例</b></summary>
<h2 id="adjuster-widget"><a class="header" href="#adjuster-widget">Adjuster widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242296674-1e126073-2c9f-443d-9dab-fccd66733e39.PNG" alt="Adjuster" /></p>
</div>
<h2 id="counter-widget"><a class="header" href="#counter-widget">Counter widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744205-f2729663-ed21-4e8b-a957-093c436fd00f.PNG" alt="Counter" /></p>
</div>
<h2 id="dial-widget"><a class="header" href="#dial-widget">Dial widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744149-cf050906-0be9-4212-9d0c-ae4f33bbef5a.PNG" alt="Dial" /></p>
</div>
<h2 id="filldial-widget"><a class="header" href="#filldial-widget">FillDial widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744161-7c210cc6-4869-4c17-8a8d-eb115c4a05b3.PNG" alt="FillDial" /></p>
</div>
<h2 id="fillslider-widget"><a class="header" href="#fillslider-widget">FillSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744164-ad6cb154-82bc-4379-988a-205c0991071e.PNG" alt="FillSlider" /></p>
</div>
<h2 id="horfillslider-widget"><a class="header" href="#horfillslider-widget">HorFillSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744166-34698d23-6ace-4971-8a46-5e41d9e03b7f.PNG" alt="HorFillSlider" /></p>
</div>
<h2 id="horniceslider-widget"><a class="header" href="#horniceslider-widget">HorNiceSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744167-4975a80b-eee9-45e9-9655-ade47ac331c2.PNG" alt="HorNiceSlider" /></p>
</div>
<h2 id="horslider-widget"><a class="header" href="#horslider-widget">HorSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744168-eaa87ef0-932a-48b0-9b39-1f35245e0dfe.PNG" alt="HorSlider" /></p>
</div>
<h2 id="horvalueslider-widget"><a class="header" href="#horvalueslider-widget">HorValueSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744171-d17f2c12-aa65-4b95-b026-a501dd9d7112.PNG" alt="HorValueSlider" /></p>
</div>
<h2 id="linedial-widget"><a class="header" href="#linedial-widget">LineDial widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744174-57e1dee1-104e-4870-99b7-cd1bf8cb82a7.PNG" alt="LineDial" /></p>
</div>
<h2 id="niceslider-widget"><a class="header" href="#niceslider-widget">NiceSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744175-b75f737d-5d93-4d98-9a17-700cd7d74fae.PNG" alt="NiceSlider" /></p>
</div>
<h2 id="roller-widget"><a class="header" href="#roller-widget">Roller widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744176-63fc716c-c0ac-45b2-b2ed-1ab79b62c64d.PNG" alt="Roller" /></p>
</div>
<h2 id="scrollbar-widget"><a class="header" href="#scrollbar-widget">Scrollbar widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744178-ed347599-b75a-41e9-8feb-8f87e3f65ec8.PNG" alt="Scrollbar" /></p>
</div>
<h2 id="slider-widget"><a class="header" href="#slider-widget">Slider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744188-7115f63d-cd53-412a-a603-1f606a15d644.PNG" alt="Slider" /></p>
</div>
<h2 id="valueinput-widget"><a class="header" href="#valueinput-widget">ValueInput widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744198-85708994-2123-4d24-97ef-b3e9feb4392e.PNG" alt="ValueInput" /></p>
</div>
<h2 id="valueoutput-widget"><a class="header" href="#valueoutput-widget">ValueOutput widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744199-d62b300e-3661-4d0b-9eea-fd971cedb53e.PNG" alt="ValueOutput" /></p>
</div>
<h2 id="valueslider-widget"><a class="header" href="#valueslider-widget">ValueSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744201-739d9730-c765-434e-a37e-00b89e7d9a10.PNG" alt="ValueSlider" /></p>
</div>
</details>
<hr />
<h1 id="valuator-枚举"><a class="header" href="#valuator-枚举">Valuator 枚举</a></h1>
<p><code>fltk::valuator</code>枚举为<code>Valuator</code>组件提供了一些可用的特性。如果你要使用这些效果，请添加下面的代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut valuator_object = valuator::Counter::default().with_size(200, 50).center_of_parent();
// 为你的组件添加下面这行代码
valuator_object.clone().with_type(fltk::valuator::CounterType::Simple);
<span class="boring">}
</span></code></pre></pre>
<p>下面演示了 <code>Counter</code>, <code>Dial</code>, <code>Scrollbar</code> 和<code>Slider</code> 组件使用这些特性的示例：</p>
<details>
<summary><b>点击查看枚举示例</b></summary>
<h2 id="countertypenormal"><a class="header" href="#countertypenormal">CounterType::Normal</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744208-123e67c2-7d99-4e1e-ba18-961f6a045c3c.PNG" alt="CounterTypeNormal" /></p>
</div>
<h2 id="countertypesimple"><a class="header" href="#countertypesimple">CounterType::Simple</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744209-5a32155d-2481-420d-a4df-e65cb94c896b.PNG" alt="CounterTypeSimple" /></p>
</div>
<hr />
<h2 id="dialtypenormal"><a class="header" href="#dialtypenormal">DialType::Normal</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744158-40daa466-d0ff-4829-a59e-ea53a828316a.PNG" alt="DialTypeNormal" /></p>
</div>
<h2 id="dialtypeline"><a class="header" href="#dialtypeline">DialType::Line</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744156-81aadbdd-349f-4e8f-9a18-aa3aab192384.PNG" alt="DialTypeLine" /></p>
</div>
<h2 id="dialtypefill"><a class="header" href="#dialtypefill">DialType::Fill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744153-86da086c-e41d-474d-93a7-1a5724c1936b.PNG" alt="DialTypeFill" /></p>
</div>
<hr />
<h2 id="scrollbartypevertical"><a class="header" href="#scrollbartypevertical">ScrollbarType::Vertical</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744185-f3d0d260-1d51-4818-8d5e-44a569de13fd.PNG" alt="ScrollbarTypeVertical" /></p>
</div>
<h2 id="scrollbartypehorizontal"><a class="header" href="#scrollbartypehorizontal">ScrollbarType::Horizontal</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744179-2c1ab7b0-3d0c-478b-8991-57e03c830cc2.PNG" alt="ScrollbarTypeHorizontal" /></p>
</div>
<h2 id="scrollbartypeverticalfill"><a class="header" href="#scrollbartypeverticalfill">ScrollbarType::VerticalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744186-4e11a7a3-ead8-4662-a253-adec6f462fae.PNG" alt="ScrollbarTypeVerticalFill" /></p>
</div>
<h2 id="scrollbartypehorizontalfill"><a class="header" href="#scrollbartypehorizontalfill">ScrollbarType::HorizontalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744181-a46e4e21-98b2-4ff8-82e0-2592c2bd6c36.PNG" alt="ScrollbarTypeHorizontalFill" /></p>
</div>
<h2 id="scrollbartypeverticalnice"><a class="header" href="#scrollbartypeverticalnice">ScrollbarType::VerticalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744187-4cbb48c1-91e5-42e8-91c0-a207570ba02c.PNG" alt="ScrollbarTypeVerticalNice" /></p>
</div>
<h2 id="scrollbartypehorizontalnice"><a class="header" href="#scrollbartypehorizontalnice">ScrollbarType::HorizontalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744183-64c40027-584a-496d-93f0-4909a3addf43.PNG" alt="ScrollbarTypeHorizontalNice" /></p>
</div>
<hr />
<h2 id="slidertypevertical"><a class="header" href="#slidertypevertical">SliderType::Vertical</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744192-ca19a6e9-1221-4253-b357-cd4cf12a0801.PNG" alt="SliderTypeVertical" /></p>
</div>
<h2 id="slidertypeverticalfill"><a class="header" href="#slidertypeverticalfill">SliderType::VerticalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744194-20b3c4a9-cd42-4c07-ae44-9753d7ab4393.PNG" alt="SliderTypeVerticalFill" /></p>
</div>
<h2 id="slidertypehorizontalfill"><a class="header" href="#slidertypehorizontalfill">SliderType::HorizontalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744190-11f4f4f4-137a-4d10-8beb-13514c6e8357.PNG" alt="SliderTypeHorizontalFill" /></p>
</div>
<h2 id="slidertypeverticalnice"><a class="header" href="#slidertypeverticalnice">SliderType::VerticalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744196-96dac4e1-bf0d-4622-ba45-84d20985ec89.PNG" alt="SliderTypeVerticalNice" /></p>
</div>
<h2 id="slidertypehorizontalnice"><a class="header" href="#slidertypehorizontalnice">SliderType::HorizontalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744191-83d3520d-c648-4372-8fc6-32ad29ec3162.PNG" alt="SliderTypeHorizontalNice" /></p>
</div>
</details>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="文字-text"><a class="header" href="#文字-text">文字 Text</a></h1>
<p><code>Text</code>组件实现了<code>DisplayExt trait</code>。FLTK提供了3个文字组件，可以在<code>text</code> mod中找到：</p>
<ul>
<li>TextDisplay</li>
<li>TextEditor</li>
<li>SimpleTerminal</li>
</ul>
<p>文本组件的主要作用是显示或编辑文本。前两个部件需要一个<code>TextBuffer</code>，<code>SimpleTerminal</code>内部有一个<code>TextBuffer</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf.clone());
    win.end();
    win.show();

    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727101-175fe355-1383-4789-ae40-2945ef0c63e2.png" alt="image" /></p>
<p>在文本组件上，对内容的操作多数是使用<code>TextBuffer</code>完成的。可以用<code>append()</code>来添加文本，也可以用<code>set_text()</code>来设置Buffer的内容。
你可以使用<code>DisplayExt::buffer()</code>方法得到Buffer的Clone（TextBuffer内部存储了一个对实际Buffer的可变指针引用），继而可以通过它来操作Buffer：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    win.end();
    win.show();

    let mut my_buf = txt.buffer().unwrap();

    my_buf.set_text(&quot;Hello world!&quot;);
    my_buf.append(&quot;\n&quot;);
    my_buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p><code>DisplayExt</code>定义了很多管理文本属性的方法，例如可以设置何时换行，光标位置，字体，颜色，大小等。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::Color, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    // 设置换行模式
    // 不同于 AtPixel 和 AtColumn, AtBounds不需要第二个参数
    // AtBounds 会设置文本到达输入框边界便会自动换行，对于大小可变的窗口很好用。
    txt.wrap_mode(text::WrapMode::AtBounds, 0);
    txt.set_text_color(Color::Red);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727121-8396c77e-836d-4406-abd1-92af32ff7242.png" alt="image" /></p>
<p><code>TextBuffer</code>还有第二个用途，它可以作为样式缓冲区（Style Buffer）。Style Buffer是你的Text Buffer的一个镜像，它使用样式表（包含字体、颜色和大小的配置）来为你的文本细粒度地设置样式，样式表中的样式本身是有索引的，具体说是使用相应的顺序字母作为索引：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    enums::{Color, Font},
    prelude::*,
    *,
};

const STYLES: &amp;[text::StyleTableEntry] = &amp;[
    text::StyleTableEntry {
        color: Color::Green,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::Red,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::from_u32(0x8000ff),
        font: Font::Courier,
        size: 16,
    },
];

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    let mut sbuf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    // A是样式表中的第一个元素的索引，这里为“Hello world!”的每个字母应用A代表的样式
    sbuf.set_text(&amp;&quot;A&quot;.repeat(&quot;Hello world!&quot;.len())); 
    buf.append(&quot;\n&quot;); 
    // 虽然针对换行的样式可能并没有显示出来，但是这里还需要将其写上，以免弄乱之后的文字样式
    sbuf.append(&quot;B&quot;); 
    buf.append(&quot;This is a text editor!&quot;);
    sbuf.append(&amp;&quot;C&quot;.repeat(&quot;This is a text editor!&quot;.len()));

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default()
        .with_size(390, 290)
        .center_of_parent();
    txt.set_buffer(buf);
    txt.set_highlight_data(sbuf, STYLES.to_vec());
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727157-be992344-763d-41f9-b3d8-2dfa13fbaab1.png" alt="image" /></p>
<p><code>Terminal</code>的例子使用了<code>SimpleTerminal</code>和一个有样式的<code>TextBuffer</code>，点击这里查看这个例子 <a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/terminal.rs">Terminal</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅览器-browsers"><a class="header" href="#阅览器-browsers">阅览器 Browsers</a></h1>
<p><code>Browser</code>组件实现了<code>BrowserExt trait</code>，可以在<code>Browser</code> mod中找到以下类型的Browser：</p>
<ul>
<li>Browser</li>
<li>SelectBrowser</li>
<li>HoldBrowser</li>
<li>MultiBrowser</li>
<li>FileBrowser</li>
<li>CheckBrowser</li>
</ul>
<p>为了实例化一个阅览器，我们需要设置好每一项item的宽度，在<code>add()</code>方法中还需要使用分隔符来将每一个item分开：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    // 现在在我们的`add()`方法中可以使用'\t'来制表符
    b.add(&quot;USER\tPID\t%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    b.add(&quot;root\t2888\t0.0\t0.0\t1352\t0\ttty3\tSW\tAug15\t0:00\t@b@f/sbin/mingetty tty3&quot;);
    b.add(&quot;erco\t2889\t0.0\t13.0\t221352\t0\ttty3\tR\tAug15\t1:34\t@b@f/usr/local/bin/render a35 0004&quot;);
    b.add(&quot;uucp\t2892\t0.0\t0.0\t1352\t0\tttyS0\tSW\tAug15\t0:00\t@b@f/sbin/agetty -h 19200 ttyS0 vt100&quot;);
    b.add(&quot;root\t13115\t0.0\t0.0\t1352\t0\ttty2\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty2&quot;);
    b.add(
        &quot;root\t13464\t0.0\t0.0\t1352\t0\ttty1\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty1 --noclear&quot;,
    );
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733437-e3061015-12fa-4f2e-a1e3-01f59c4b189d.png" alt="image" /></p>
<p>可以使用<code>@</code>并在后面跟上格式化符来实现其他丰富的格式化效果：</p>
<ul>
<li>'@.' 打印其余行，且让剩余的'@'符号无效</li>
<li>'@@' 打印其余以'@'开头的行</li>
<li>'@l' 使用大号字体(24 point) </li>
<li>'@m' 使用中号字体(18 point)</li>
<li>'@s' 使用小号字体(11 point)</li>
<li>'@b' 使用宽字体(adds FL_BOLD to font)</li>
<li>'@i' 使用斜体(adds FL_ITALIC to font)</li>
<li>'@f' 或 '@t' 使用等距字体 (sets font to FL_COURIER)</li>
<li>'@c' 水平居中</li>
<li>'@r' 向右对齐文本</li>
<li>'@B0', '@B1', ... '@B255' 使用<code>fl_color(n)</code>填充背景</li>
<li>'@C0', '@C1', ... '@C255' 使用<code>fl_color(n)</code>渲染文本</li>
<li>'@F0', '@F1', ... 使用 <code>fl_font(n)</code> 渲染文本</li>
<li>'@S1', '@S2', ... 使用相应的尺寸来渲染文本</li>
<li>'@u' or '@_' 字体添加下划线</li>
<li>'@-' 字体中间添加修改线</li>
</ul>
<p>在下面的例子中，我们在<code>%CPU</code>前面加上<code>@C88</code>，将其渲染成红色：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    b.add(&quot;USER\tPID\t@C88%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733713-2fe3207d-25f7-4acd-ae91-754679c5696a.png" alt="图像 image" /></p>
<p>这些颜色表示遵循FLTK的色彩映射规则，可以从0到255进行索引。</p>
<p><img src="https://www.fltk.org/doc-1.4/fltk-colormap.png" alt="色彩映射 colormap" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树-trees"><a class="header" href="#树-trees">树 Trees</a></h1>
<p><code>Tree</code>组件可以实现元素按照的。你可能会想，它是不是定义在<code>TreeExt trait</code>中，哈哈哈，然而这里并没有。所有方法都是来自<code>Tree</code>结构体类型。可以使用<code>add()</code>方法为Tree添加元素：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726958-f1f2a095-39c5-496f-b772-18d024dd609d.png" alt="image" /></p>
<p>Item下还可以子Item，可以使用正斜线分隔符<code>/</code>来添加：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727026-bfcff44f-2b01-4679-937b-3e7d441dfdf0.png" alt="image" /></p>
<p>看过上面代码的例子，你会发现树的根标签总是 &quot;ROOT &quot;。可以通过<code>set_root_label()</code>方法来设置根标签：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_root_label(&quot;My Tree&quot;);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727045-a25be6bc-a514-4b4a-b7b9-0a7ee2e359b4.png" alt="image" /></p>
<p>还能调用<code>set_show_root(false)</code>方法来隐藏根标签。</p>
<p>可以使用<code>first_selected_item()</code>方法来获取被点击到的元素：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727072-8596cf09-100c-4cb6-a427-0d3c66702b39.png" alt="image" /></p>
<p>现在我们的Tree中的元素只能单选，让我们把它改成允许多选的树（这里我们也改变了元素之间连线的样式）：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    // 设置Tree的选择模式为多选
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>现在的问题是，我们需要获取选择到的所有选项，而不只是第一个被选中的项目，这里我们使用<code>get_selected_items()</code>方法，该方法返回一个<code>Option&lt;Vec&gt;</code>。这里我们使用<code>item_pathname()</code>来获取Item在树中的路径。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(items) = t.get_selected_items() {
            for i in items {
                println!(&quot;{} selected&quot;, t.item_pathname(&amp;i).unwrap());
            }
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727000-4b881896-309d-465d-8305-9a7e0a92eaea.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表格-tables"><a class="header" href="#表格-tables">表格 Tables</a></h1>
<p>FLTK还提供了<code>Table</code>组件，Table的使用方法可以参见GitHub库中的例子<a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/table.rs">示例</a>。有个好处是，我们提供了<a href="https://crates.io/crates/fltk-table">fltk-table crate</a>，使用它的话我们可以写更少的样板代码，写出的界面也会更简单、直观。</p>
<pre><pre class="playground"><code class="language-rust edition2021">extern crate fltk_table;

use fltk::{
    app, enums,
    prelude::{GroupExt, WidgetExt},
    window,
};
use fltk_table::{SmartTable, TableOpts};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut wind = window::Window::default().with_size(800, 600);

    // 通过 TableOpts 结构体设置行和列
    let mut table = SmartTable::default()
    .with_size(790, 590)
    .center_of_parent()
    .with_opts(TableOpts {
        rows: 30,
        cols: 15,
        editable: true,
        ..Default::default()
    });
    
    wind.end();
    wind.show();

    // 用一些值填充表格
    for i in 0..30 {
        for j in 0..15 {
            table.set_cell_value(i, j, &amp;(i + j).to_string());
        }
    }

    // 把 第4行第5列 的表格设置为&quot;another&quot;, 需要注意索引是从0开始的
    table.set_cell_value(3, 4, &quot;another&quot;);

    assert_eq!(table.cell_value(3, 4), &quot;another&quot;);

    // 防止按 Esc键 时关闭窗口
    wind.set_callback(move |_| {
        if app::event() == enums::Event::Close {
            app.quit();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-table/raw/HEAD/screenshots/styled.jpg" alt="fltk-table" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义组件-custom-widgets"><a class="header" href="#自定义组件-custom-widgets">自定义组件 Custom widgets</a></h1>
<p>fltk-rs允许你创建自定义组件。我们需要定义一个<code>Struct</code>来作为自定义组件的类型，我们需要用一个已经存在的<code>Widget</code>和<code>widget type</code>来扩展它。最基本的<code>Widget type</code>是<code>widget::Widget</code>。</p>
<ol>
<li>
<p>定义你的<code>Struct</code>，以及它需要维护的内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ol>
<p>你会注意到两件事，我们正在使用一个<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>来存储我们需要用到的数据。在一般情况下这是没有必要的。但是，在它的回调方法被调用时它的所有权会被移动，为了在执行完一次回调之后仍能使用它，我们将把它包装在一个<code>Rc&lt;RefCell&lt;&gt;&gt;</code>中。这段代码中我们已经导入了必要的模块。</p>
<ol start="2">
<li>
<p>为组件实现方法。最重要的是要有构造函数，因为我们要通过它来初始化组件和内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyCustomButton {

    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { 
            // 我们需要实现绘制方法
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black);
            // 设置文字的颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; 
                // 使 num_clicks 在点击时递增
                i.do_callback(); 
                // 执行我们使用 set_callback() 设置的回调方法
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>在我们的自定义组件上应用<code>widget_extends！</code>宏，该宏需要传入我们的小组件，它扩展的基本类型，以及结构体中表示该基本类型的成员。这是通过实现<code>Deref Trait</code>和<code>DerefMut Trait</code>实现的。该宏还会自动为我们的自定义组件添加了其他函数和固定的方法（anchoring methods）：</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 通过宏扩展widget::Widget
widget_extends!(MyCustomButton, widget::Widget, inner);
<span class="boring">}
</span></code></pre></pre>
<p>现在来试一试我们的自定义组件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // 设置白色背景
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    // 注意，set_color和set_callback是宏自动为我们实现了
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p>全部代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl MyCustomButton {

    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { 
            // 我们需要一个绘制的方法
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // 设置文字颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1;
                // 使 num_clicks 在点击时递增
                i.do_callback(); 
                // 执行我们使用 set_callback() 设置的回调方法
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}

// 通过宏扩展widget::Widget
widget_extends!(MyCustomButton, widget::Widget, inner);

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    // 设置背景为白色
    app::background(255, 255, 255);
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727718-fd0ee71f-f0c2-4438-a038-9b6950638a35.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对话框-dialogs"><a class="header" href="#对话框-dialogs">对话框 Dialogs</a></h1>
<p>FLTK提供了文件对话框等一系列对话框类型</p>
<h2 id="文件对话框-file-dialogs"><a class="header" href="#文件对话框-file-dialogs">文件对话框 File dialogs</a></h2>
<p>有2种文件对话框类型，系统原生的文件对话框和FLTK自己的文件对话框。原生文件对话框即进行文件选择时会弹出系统的文件选择窗口。对于Windows，弹出的便是Win32对话框，对于MacOS，弹出的是Cocoa对话框，对于其他Posix系统来说，它取决于你的桌面环境。在GNOME和其他基于GTK的桌面上，弹出的是GTK对话框，在KDE上弹出的是kdialog。</p>
<h3 id="原生对话框-native-dialogs"><a class="header" href="#原生对话框-native-dialogs">原生对话框 Native dialogs</a></h3>
<p>这样可以调出一个原生对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filename());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146625105-94b11a5d-0938-4962-96d1-aaff5424ffe8.png" alt="image" /></p>
<p>运行这段代码会弹出一个系统原生的文件对话框，选择一个文件后将在终端打印出文件名。你需要为<code>new()</code>提供一个<code>NativeFileChooserType</code>类型的参数，它表明你该对话框要选择的文件类型，是多个文件还是文件夹之类的。这段代码我们选择了<code>BrowseFile</code>，你可以用<code>BrowseDir</code>替换掉来试试，也可试试多文件/目录的类型选项。如果你选择了多个文件，你可以使用<code>filenames()</code>方法得到一个包含多个文件名的Vector：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select files&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>你可以通过添加过滤器来限制文件类型：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.set_filter(&quot;*.{txt,rs,toml}&quot;);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });
<span class="boring">}
</span></code></pre></pre>
<p>这将让对话框只能选取<code>.txt</code>、<code>.rs</code>和<code>.toml</code>文件。</p>
<h3 id="fltl提供的文件选择器-fltks-own-file-chooser"><a class="header" href="#fltl提供的文件选择器-fltks-own-file-chooser">FLTL提供的文件选择器 FLTK's own file chooser</a></h3>
<p>FLTK也提供了自己的文件选择器：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::FileChooser::new(
            &quot;.&quot;,                            /*对话框弹出时所在目录*/
            &quot;*.{txt,rs,toml}&quot;,              /*文件类型限定*/
            dialog::FileChooserType::Multi, /*对话框类型*/
            &quot;Select file:&quot;,                 /*对话框标题*/
        );
        dialog.show();
        while dialog.shown() {
            app::wait();
        }
        if dialog.count() &gt; 1 {
            for i in 1..=dialog.count() { // values start at 1
                println!(&quot; VALUE[{}]: '{}'&quot;, i, dialog.value(i).unwrap());
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726912-600e4c58-32b7-4a1b-8e6a-44e640549722.png" alt="image" /></p>
<p>使用<code>file_chooser()</code>和<code>dir_chooser()</code>方法可以简化一些操作：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let file = dialog::file_chooser(
            &quot;Choose File&quot;,
            &quot;*.rs&quot;,
            /*start dir*/ &quot;.&quot;,
            /*relative*/ true,
        );
        if let Some(file) = file {
            println!(&quot;{}&quot;, file);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h3 id="帮助文档对话框-help-dialog"><a class="header" href="#帮助文档对话框-help-dialog">帮助文档对话框 Help dialog</a></h3>
<p>FLTK提供了一个帮助文档对话框，可以用来将HTML文件转换为文档显示出来：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut help = dialog::HelpDialog::new(100, 100, 400, 300);
        help.set_value(&quot;&lt;h2&gt;Hello world&lt;/h2&gt;&quot;); // this takes html
        help.show();
        while help.shown() {
            app::wait();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>也可以用<code>HelpDialog::load(path_to_html_file)</code>方法加载一个HTML文件：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726889-442d0453-e1d0-4b41-8717-f121fdf860fa.png" alt="image" /></p>
<h3 id="提示对话框-alert-dialogs"><a class="header" href="#提示对话框-alert-dialogs">提示对话框 Alert dialogs</a></h3>
<p>FLTK还提供了下面几种使用很方便的对话框类型，只需要调用相关函数即可显示：</p>
<ul>
<li>message</li>
<li>alert</li>
<li>choice</li>
<li>input</li>
<li>password (类似于input，但会隐藏输入的内容)</li>
</ul>
<p>显示一个简单的message对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        dialog::message_default(&quot;Message&quot;);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>执行这段代码，将在默认位置（大致在鼠标位置）显示一个message对话框。如果你想手动设置显示的坐标，可以使用<code>message()</code>函数：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        dialog::message(100, 100, &quot;Message&quot;);
    });
<span class="boring">}
</span></code></pre></pre>
<p>这些函数都有相对的变体，一个有<code>_default()</code>后缀，不需要设置坐标，另一个没有后缀，需要手动输入坐标。
有些对话框会返回一个值，比如<code>choice</code>，<code>input</code> 和 <code>password</code>。<code>input</code>和<code>password</code>返回用户输入的文本，而<code>choice</code>则返回选择值的索引：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        // password() 和 input() 需要第二个参数来表示默认显示的值
        let pass = dialog::password_default(&quot;Enter password:&quot;, &quot;&quot;);
        if let Some(pass) = pass {
            println!(&quot;{}&quot;, pass);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726850-61fc17e4-cd6e-4821-a9b5-396203806066.png" alt="image" /></p>
<p>使用<code>choice</code>的示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>在用户选择按钮后将在控制台打印出选项索引，选择No将打印0，Yes将打印1，Cancel将打印2。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726775-d000a807-8bf5-439b-a991-8bf25fcd5049.png" alt="image" /></p>
<p>你可能已经发现这些对话框没有标题。你可以在调用对话框前调用这个函数来为对话框添加标题：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        dialog::message_title(&quot;Exit!&quot;);
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>你也可以在程序的开头调用<code>dialog::message_title_default()</code>来设置所有对话框的默认标题：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    dialog::message_title_default(&quot;My App!&quot;);
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726685-f086bde2-db63-4fa8-a579-954dbacbe44d.png" alt="image" /></p>
<h2 id="自定义对话框-custom-dialogs"><a class="header" href="#自定义对话框-custom-dialogs">自定义对话框 Custom dialogs</a></h2>
<p>上面这些对话框可能并不是你想要的样子，尤其是颜色和字体。如果你的程序是高度风格化的，你绝对还需要自定义对话框。对话框基本是在程序运行期间生成的一个模型窗口（Modal Windows），我们想要制作自定义对话框，只要制作一个窗口即可，它的主题与你为程序设置的主题将是一致的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app, button,
    enums::{Color, Font, FrameType},
    frame, group, input,
    prelude::*,
    window,
};

fn style_button(btn: &amp;mut button::Button) {
    btn.set_color(Color::Cyan);
    btn.set_frame(FrameType::RFlatBox);
    btn.clear_visible_focus();
}

pub fn show_dialog() -&gt; MyDialog {
    MyDialog::default()
}

pub struct MyDialog {
    inp: input::Input,
}

impl MyDialog {
    pub fn default() -&gt; Self {
        let mut win = window::Window::default()
            .with_size(400, 100)
            .with_label(&quot;My Dialog&quot;);
        win.set_color(Color::from_rgb(240, 240, 240));
        let mut pack = group::Pack::default()
            .with_size(300, 30)
            .center_of_parent()
            .with_type(group::PackType::Horizontal);
        pack.set_spacing(20);
        frame::Frame::default()
            .with_size(80, 0)
            .with_label(&quot;Enter name:&quot;);
        let mut inp = input::Input::default().with_size(100, 0);
        inp.set_frame(FrameType::FlatBox);
        let mut ok = button::Button::default().with_size(80, 0).with_label(&quot;Ok&quot;);
        style_button(&amp;mut ok);
        pack.end();
        win.end();
        win.make_modal(true);
        win.show();
        ok.set_callback({
            let mut win = win.clone();
            move |_| {
                win.hide();
            }
        });
        while win.shown() {
            app::wait();
        }
        Self { inp }
    }
    pub fn value(&amp;self) -&gt; String {
        self.inp.value()
    }
}

fn main() {
    let a = app::App::default();
    app::set_font(Font::Times);
    let mut win = window::Window::default().with_size(600, 400);
    win.set_color(Color::from_rgb(240, 240, 240));
    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Click&quot;)
        .center_of_parent();
    style_button(&amp;mut btn);
    let mut frame = frame::Frame::new(btn.x() - 40, btn.y() - 100, btn.w() + 80, 30, None);
    frame.set_frame(FrameType::BorderBox);
    frame.set_color(Color::Red.inactive());
    win.end();
    win.show();
    btn.set_callback(move |_| {
        let d = show_dialog();
        frame.set_label(&amp;d.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726727-a0018457-1d87-4519-9d6e-08d8f8030d1a.png" alt="image" /></p>
<h2 id="打印对话框-printer-dialog"><a class="header" href="#打印对话框-printer-dialog">打印对话框 Printer dialog</a></h2>
<p>FLTK还提供了打印对话框，它会调用你的系统平台的本地打印机对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
let mut but = button::Button::default();
but.set_callback(|widget| {
    let mut printer = printer::Printer::default();
    if printer.begin_job(1).is_ok() {
        printer.begin_page().ok();
        let (width, height) = printer.printable_rect();
        draw::set_draw_color(enums::Color::Black);
        draw::set_line_style(draw::LineStyle::Solid, 2);
        draw::draw_rect(0, 0, width, height);
        draw::set_font(enums::Font::Courier, 12);
        printer.set_origin(width / 2, height / 2);
        printer.print_widget(widget, -widget.width() / 2, -widget.height() / 2);
        printer.end_page().ok();
        printer.end_job();
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>这里打印了按钮的图像并指定了它的位置。你可以传递任何组件（像TextEditor组件之类的）作为被打印的组件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图像-images"><a class="header" href="#图像-images">图像 Images</a></h1>
<p>FLTK支持矢量图和位图，提供下面几种开箱即用的图像类型：</p>
<ul>
<li>BmpImage</li>
<li>JpegImage</li>
<li>GifImage</li>
<li>PngImage</li>
<li>SvgImage</li>
<li>Pixmap</li>
<li>RgbImage</li>
<li>XpmImage</li>
<li>XbmImage</li>
<li>PnmImage</li>
</ul>
<p>它还提供了两个helper types：</p>
<ul>
<li>SharedImage：它包装了上述所有的类型，使用时不需要提供图像的类型。</li>
<li>TiledImage：它提供了任何具体类型的平铺图像（Tiled Image）。</li>
</ul>
<p>图像类型均实现了<code>ImageExt Trait</code>，该Trait中定义了缩放和检索图像元数据的方法。
可以通过向图像类型的<code>load()</code>函数传递图像路径来显示图像，对于某些类型，可以使用<code>from_data()</code>接收图像数据来构建图像：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 需要图像路径
let image = image::SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();

/// 需要图像数据
let image= image::SvgImage::from_data(&amp;data).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>可以通过使用<code>WidgetExt::set_image()</code>/<code>set_image_scaled()</code>或<code>set_deimage()</code>/<code>set_deimage_scaled()</code>（用于deactivated/grayed image）在其他组件上使用<code>Image</code>组件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>或者通过<code>WidgetExt::draw()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    frame.draw(move |f| {
        image.scale(f.w(), f.h(), true, true);
        image.draw(f.x() + 40, f.y(), f.w(), f.h());
    });

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/hello.jpg" alt="svg" /></p>
<p>使用<code>Image</code>作为你的程序的图标或背景将让你的程序更具风格化，更加美观（在FLTK中你可能需要使用其他主题或自定义）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="事件-events"><a class="header" href="#事件-events">事件 Events</a></h1>
<p>在之前章节的示例中，我们处理事件的方法主要是使用回调（Callback）。但是我们可以根据具体的使用情况选择其他方法，FLTK提供的处理事件的方式有这几种：</p>
<ul>
<li><code>set_callback()</code>方法，在点击按钮时自动触发。</li>
<li><code>handle()</code>方法，用于进行细粒度的事件处理。</li>
<li><code>emit()</code>方法，接收一个<code>sender</code>和一个<code>message</code>将触发的事件类型发送，之后在<code>event loop</code>中处理事件。</li>
<li>我们还可以自定义一个可以在另一个组件的处理方法中被处理的事件。</li>
</ul>
<h3 id="设置回调-callback"><a class="header" href="#设置回调-callback">设置回调 Callback</a></h3>
<p><code>WidgetExt trait</code> 中定义了<code>set_callback</code>方法。</p>
<h4 id="使用闭包"><a class="header" href="#使用闭包">使用闭包</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|_| println!(&quot;The button was clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>这里闭包捕获的环境是设置回调的组件自身的<code>&amp;mut self</code>： </p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|b| b.set_label(&quot;Clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>你的按钮何时执行回调方法，点击时？还是鼠标松开时？你需要设置触发器来决定何时执行回调，<code>set_callback()</code>方法会设置默认的触发器，不同组件的触发器可能不同。例如按钮组件的触发器便是，当它具有鼠标焦点时的点击或按下回车。
某个组件的触发器是可以通过<code>set_trigger()</code>方法改变的。改变按钮的触发方式可能没有意义，但是对于<code>Input</code>组建来说，触发器可以被设置为<code>CallbackTrigger::Changed</code>，这可以使<code>Input</code>组件在状态改变时就触发回调：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut inp = input::Input::default()
        .with_size(160, 30)
        .center_of_parent();
    win.end();
    win.show();
    inp.set_trigger(enums::CallbackTrigger::Changed);
    inp.set_callback(|i| println!(&quot;{}&quot;, i.value()));
    a.run().unwrap();
}
</code></pre></pre>
<p>在这个示例中，用户每输入一个字符都会打印一次。</p>
<p>使用闭包的好处便是因为它能够捕获环境，你可以将闭包环境作用域中的其他变量传递进去：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(move |_| {
        my_window.set_label(&quot;button was pressed&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>在<a href="Menus">菜单</a>中，事件处理是在每个<code>MenuItem</code>上进行的。</p>
<h4 id="使用方法对象-function-object"><a class="header" href="#使用方法对象-function-object">使用方法对象 Function Object</a></h4>
<p>如果你喜欢的话你也可以直接传递函数对象：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn button_cb(w: &amp;mut impl WidgetExt) {
    w.set_label(&quot;Clicked&quot;);
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(button_cb);
    app.run().unwrap();
}
</code></pre></pre>
<p>我们使用<code>&amp;mut impl WidgetExt</code>，以便让所有组件都能使用这个回调。或者，你可以直接使用<code>&amp;mut button::Button</code>只让<code>Button</code>使用。
这种方法的一个缺点是，有时候你必须维护全局状态：</p>
<pre><pre class="playground"><code class="language-rust edition2021">extern crate lazy_static;

use fltk::{prelude::*, *};
use std::sync::Mutex;

#[derive(Default)]
struct State {
    count: i32,
}

impl State {
    fn increment(&amp;mut self) {
        self.count += 1;
    }
}

lazy_static::lazy_static! {
    static ref STATE: Mutex&lt;State&gt; = Mutex::new(State::default());
}


fn button_cb(_w: &amp;mut button::Button) {
    let mut state = STATE.lock().unwrap();
    state.increment();
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Increment!&quot;);
    my_window.end();
    my_window.show();
    
    but.set_callback(button_cb);
    
    app.run().unwrap();
}
</code></pre></pre>
<p>这里我们用了<code>lazy_static</code>，当然也有其他的<code>crate</code>来用来进行状态管理。</p>
<p>同样，对菜单来说，在<code>MenuExt::add()/insert()</code>或<code>MenuItem::add()/insert()</code>方法中，我们可以使用<code>&amp;mut impl MenuExt</code>来设置<code>Menu</code>和<code>Menu Item</code>的回调。</p>
<h3 id="使用处理方法-handle-method"><a class="header" href="#使用处理方法-handle-method">使用处理方法 handle method</a></h3>
<p><code>handle</code>方法接收一个有事件参数的闭包，并在处理后返回一个<code>bool</code>。这个返回值让FLTK知道该事件是否被处理。
它的使用是这样的：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    but.handle(|_, event| {
        println!(&quot;The event: {:?}&quot;, event);
        false
    });
    
    app.run().unwrap();
}
</code></pre></pre>
<p>这段代码将打印出<code>event</code>，但并不做其他处理，所以我们返回false。很明显，我们应该做一些有用的处理，所以我们把它改成这样：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|_, event| match event {
        Event::Push =&gt; {
            println!(&quot;I was pushed!&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们处理事件<code>Event</code>然后返回<code>true</code>，将其他事件将被忽略并返回<code>false</code>。</p>
<p>另一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|b, event| match event {
        Event::Push =&gt; {
            b.set_label(&quot;Pushed&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<h3 id="使用messages"><a class="header" href="#使用messages">使用messages</a></h3>
<p>这允许我们创建Channel和<code>Sender</code> <code>Receiver</code>的结构，在触发后发送Message（Message必须是<code>Send + Sync</code>），并在<code>event loop</code>中处理。这样做的好处是，当我们需要将我们的一些量传递到闭包或线程中时，不必再使用智能指针来包装它们。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    let (s, r) = app::channel();
    
    but.emit(s, true);
    // 相当于 but.set_callback(move |_| s.send(true))

    while app.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // 什么都不做
            }
        }
    }
}
</code></pre></pre>
<p>跟之前的例子一样，Messages 可以在<code>event loop</code>中被接受，另外你也可以在后台线程或<code>app::add_idle()</code>的回调中接收<code>Message</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    app::add_idle(move || {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // 这里不做任何事
            }
        }
    });
<span class="boring">}
</span></code></pre></pre>
<p>这里也不限于使用<code>fltk channel</code>，你可以使用任何channel。例如，这个例子用使用了<code>std channel</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
btn.set_callback(move |_| {
    s.send(Message::SomeMessage).unwrap();
});
<span class="boring">}
</span></code></pre></pre>
<p>类似于<code>emit()</code>方法，你也可以定义一个适用于所有组件的<code>send()</code>方法，：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc::Sender;

pub trait SenderWidget&lt;W, T&gt;
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T);
}

impl&lt;W, T&gt; SenderWidget&lt;W, T&gt; for W
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T) {
        self.set_callback(move |_| {
            sender.send(msg.clone()).unwrap();
        });
    }
}

fn main() {
    let btn = button::Button::default();
    let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
    btn.send(s.clone(), Message::SomeMessage);
}
</code></pre></pre>
<h3 id="创建自己的事件"><a class="header" href="#创建自己的事件">创建自己的事件</a></h3>
<p>FLTK在<code>enums::Event</code>中预先定义了29个事件。我们还可以使用调用<code>app::handle(impl Into&lt;i32&gt;, window)</code>创建我们自己的事件。<code>handle</code>函数以任意一个大于30的<code>i32</code>类型值作为信号标识，最好提前定义好信号标识。我们可以在另一个组件的<code>handle()</code>方法中处理事件，注意这个组件需要放在传递给<code>app::handle</code>的那个窗口内部。
在下面的例子中，我们创建了一个带有<code>Frame</code>和<code>Button</code>的窗口。<code>Button</code>的回调函数在执行时，通过<code>app::handle_main</code>函数发送一个<code>CHANGED</code>事件。该<code>CHANGED</code>信号在<code>Frame</code>的<code>handle</code>方法中被接收到并做出处理：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::*, enums::*, frame::*, group::*, prelude::*, window::*};
use std::cell::RefCell;
use std::rc::Rc;

pub struct MyEvent;

impl MyEvent {
    const CHANGED: i32 = 40;
}

#[derive(Clone)]
pub struct Counter {
    count: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl Counter {
    pub fn new(val: i32) -&gt; Self {
        Counter {
            count: Rc::from(RefCell::from(val)),
        }
    }

    pub fn increment(&amp;mut self) {
        *self.count.borrow_mut() += 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn decrement(&amp;mut self) {
        *self.count.borrow_mut() -= 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn value(&amp;self) -&gt; i32 {
        *self.count.borrow()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = app::App::default();
    let counter = Counter::new(0);
    let mut wind = Window::default().with_size(160, 200).with_label(&quot;Counter&quot;);
    let mut pack = Pack::default().with_size(120, 140).center_of(&amp;wind);
    pack.set_spacing(10);
    let mut but_inc = Button::default().with_size(0, 40).with_label(&quot;+&quot;);
    let mut frame = Frame::default()
        .with_size(0, 40)
        .with_label(&amp;counter.clone().value().to_string());
    let mut but_dec = Button::default().with_size(0, 40).with_label(&quot;-&quot;);
    pack.end();
    wind.end();
    wind.show();

    but_inc.set_callback({
        let mut c = counter.clone();
        move |_| c.increment()
    });

    but_dec.set_callback({
        let mut c = counter.clone();
        move |_| c.decrement()
    });
    
    frame.handle(move |f, ev| {
        if ev == MyEvent::CHANGED.into() {
            f.set_label(&amp;counter.clone().value().to_string());
            true
        } else {
            false
        }
    });

    Ok(app.run()?)
}
</code></pre></pre>
<p>发送的<code>i32</code>信号可以是动态创建的，也可以把它存在一个局部或全局常量中，或者存放在一个枚举中。</p>
<h4 id="优点"><a class="header" href="#优点">优点</a></h4>
<ul>
<li>无开销。</li>
<li>信号的处理方式与其他任何FLTK事件一样。</li>
<li><code>app::handle</code>函数可以返回一个bool，表示该事件是否被处理。</li>
<li>允许在事件循环之外处理自定义信号/事件。</li>
<li>允许在程序中使用MVC或SVU架构。</li>
</ul>
<h4 id="缺点"><a class="header" href="#缺点">缺点</a></h4>
<ul>
<li>信号只能在一个组件的处理方法中处理。</li>
<li>该信号在事件循环中是不可访问的（为解决，可以使用<code>WidgetExt::emit</code>或本节前面部分描述的<code>channel</code>）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拖放-drag--drop"><a class="header" href="#拖放-drag--drop">拖放 Drag &amp; Drop</a></h1>
<p>FLTK支持拖放的事件类型。如果你为组件实现了拖放事件，你就可以拖动组件，也可以把文件拖入程序框内。如果还想在组件上绘图，处理<code>Event::Drag</code>事件将会帮你做到。</p>
<h2 id="拖动组件"><a class="header" href="#拖动组件">拖动组件</a></h2>
<p>通常情况下，你可以拖动窗口边框来移动窗口。现在我们将窗口设置为无边框，然后再为窗口本身实现拖放事件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 400);
    wind.set_color(enums::Color::White);
    wind.set_border(false);
    wind.end();
    wind.show();

    wind.handle({
        let mut x = 0;
        let mut y = 0;
        move |w, ev| match ev {
            enums::Event::Push =&gt; {
                let coords = app::event_coords();
                x = coords.0;
                y = coords.1;
                true
            }
            enums::Event::Drag =&gt; {
                w.set_pos(app::event_x_root() - x, app::event_y_root() - y);
                true
            }
            _ =&gt; false,
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h2 id="拖动文件"><a class="header" href="#拖动文件">拖动文件</a></h2>
<p>将一个文件拖入程序框中会触发<code>Paste</code>事件，并将文件的路径传入<code>app::event_text()</code>。因此，当我们处理文件拖放时，我们需要在<code>Event::Paste</code>中捕获路径，这里我们将检查文件是否存在，读取其内容并填充我们的<code>text</code>组件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    let path = path.trim();
                    let path = path.replace(&quot;file://&quot;, &quot;&quot;);
                    let path = std::path::PathBuf::from(&amp;path);
                    if path.exists() {
                        // 我们使用 timeout 来避免路径传入缓冲区
                        app::add_timeout3(0.0, {
                            let mut buf = buf.clone();
                            move |_| {
                                buf.load_file(&amp;path).unwrap();
                            }
                        });
                    }
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>如果你对文件的内容不感兴趣，你可以只取得文件的路径并显示：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let mut buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    buf.append(&amp;path);
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<h2 id="拖动绘图"><a class="header" href="#拖动绘图">拖动绘图</a></h2>
<p>我们已经学会了如何在屏幕内通过拖放绘制组件，现在我们还可以响应屏幕外的事件，比如用鼠标绘画这些。我们会将屏幕外事件，如鼠标的移动坐标等等，复制到组件中，然后进行绘制。一个更详细的例子可以在<a href="Drawing.html#offscreen-drawing">绘图 Drawing</a>中看到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态管理器-state-management"><a class="header" href="#状态管理器-state-management">状态管理器 State management</a></h1>
<p>FLTK没有固化的某种形式的状态管理方法或程序架构，这些部分交由开发者自行设计选择。fltk-rs仓库和本书中的所有示例几乎都使用了回调（Callback）和消息（message）的方式来处理事件和管理状态，你能找它们的很多例子。
这些都在<a href="Events.html">事件 Event</a>中讨论过。</p>
<p>此外，为了简单起见，所有的示例都是在<code>main</code>函数中处理一切。您可以创建自己的<code>App</code>结构，将主窗口和你维护的数据状态放在里面：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

#[derive(Copy, Clone)]
enum Message {
    Inc,
    Dec,
}

struct MyApp {
    app: app::App,
    main_win: window::Window,
    frame: frame::Frame,
    count: i32,
    receiver: app::Receiver&lt;Message&gt;,
}

impl MyApp {
    pub fn new() -&gt; Self {
        let count = 0;
        let app = app::App::default();
        let (s, receiver) = app::channel();
        let mut main_win = window::Window::default().with_size(400, 300);
        let col = group::Flex::default()
            .with_size(100, 200)
            .column()
            .center_of_parent();
        let mut inc = button::Button::default().with_label(&quot;+&quot;);
        inc.emit(s, Message::Inc);
        let frame = frame::Frame::default().with_label(&amp;count.to_string());
        let mut dec = button::Button::default().with_label(&quot;-&quot;);
        dec.emit(s, Message::Dec);
        col.end();
        main_win.end();
        main_win.show();
        Self {
            app,
            main_win,
            frame,
            count,
            receiver,
        }
    }

    pub fn run(mut self) {
        while self.app.wait() {
            if let Some(msg) = self.receiver.recv() {
                match msg {
                    Message::Inc =&gt; self.count += 1,
                    Message::Dec =&gt; self.count -= 1,
                }
                self.frame.set_label(&amp;self.count.to_string());
            }
        }
    }
}

fn main() {
    let a = MyApp::new();
    a.run();
}
</code></pre></pre>
<h2 id="辅助-crates"><a class="header" href="#辅助-crates">辅助 crates</a></h2>
<p>Rust的Crate生态为我们提供了很多用于进行状态管理的Crate。在<code>fltk-rs</code> GitHub组织下有2个crate，它们提供了几种程序架构设计和状态管理的方法：</p>
<ul>
<li><a href="https://github.com/fltk-rs/flemish">flemish</a>:</li>
</ul>
<p>提供了一个类似<code>Elm</code>的SVU架构。它是反应式（reactive）的，本质上不可变，每次发送消息都会让视图进行重绘，参见Elm的设计。</p>
<ul>
<li><a href="https://github.com/fltk-rs/fltk-evented">fltk-evented</a>:</li>
</ul>
<p>类似于即时模式的GUI界面，所有事件都在事件循环中处理。实际上它也是反应式的，但它是可变且无状态的。使用它可以避免触发事件引起视图重绘。</p>
<p>这两个crate都尽量避免使用回调方法，由于Rust的生命周期和借用检查机制，处理回调极其麻烦。你需要使用内部可变性的智能指针，才能够在回调中借用。</p>
<p>你可以看一下这两个crate，或许会启发你的灵感。</p>
<p>下面是分别使用这两个Crate实现计时器的示例：</p>
<h2 id="flemish"><a class="header" href="#flemish">Flemish</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use flemish::{
    button::Button, color_themes, frame::Frame, group::Flex, prelude::*, OnEvent, Sandbox, Settings,
};

pub fn main() {
    Counter::new().run(Settings {
        size: (300, 100),
        resizable: true,
        color_map: Some(color_themes::BLACK_THEME),
        ..Default::default()
    })
}

#[derive(Default)]
struct Counter {
    value: i32,
}

#[derive(Debug, Clone, Copy)]
enum Message {
    IncrementPressed,
    DecrementPressed,
}

impl Sandbox for Counter {
    type Message = Message;

    fn new() -&gt; Self {
        Self::default()
    }

    fn title(&amp;self) -&gt; String {
        String::from(&quot;Counter - fltk-rs&quot;)
    }

    fn update(&amp;mut self, message: Message) {
        match message {
            Message::IncrementPressed =&gt; {
                self.value += 1;
            }
            Message::DecrementPressed =&gt; {
                self.value -= 1;
            }
        }
    }

    fn view(&amp;mut self) {
        let col = Flex::default_fill().column();
        Button::default()
            .with_label(&quot;Increment&quot;)
            .on_event(Message::IncrementPressed);
        Frame::default().with_label(&amp;self.value.to_string());
        Button::default()
            .with_label(&quot;Decrement&quot;)
            .on_event(Message::DecrementPressed);
        col.end();
    }
}
</code></pre></pre>
<h2 id="fltk-evented"><a class="header" href="#fltk-evented">fltk-evented</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::Button, frame::Frame, group::Flex, prelude::*, window::Window};
use fltk_evented::Listener;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    app::set_font_size(20);

    let mut wind = Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let flex = Flex::default()
        .with_size(120, 160)
        .center_of_parent()
        .column();
    let but_inc: Listener&lt;_&gt; = Button::default().with_label(&quot;+&quot;).into();
    let mut frame = Frame::default();
    let but_dec: Listener&lt;_&gt; = Button::default().with_label(&quot;-&quot;).into();
    flex.end();
    wind.end();
    wind.show();

    let mut val = 0;
    frame.set_label(&amp;val.to_string());

    while a.wait() {
        if but_inc.triggered() {
            val += 1;
            frame.set_label(&amp;val.to_string());
        }

        if but_dec.triggered() {
            val -= 1;
            frame.set_label(&amp;val.to_string());
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布局-layouts"><a class="header" href="#布局-layouts">布局 Layouts</a></h1>
<p>FLTK-rs提供了这些开箱即用的布局组件：</p>
<ul>
<li>Flex</li>
<li>Pack</li>
<li>Grid</li>
<li>组件相对定位</li>
</ul>
<h3 id="flex"><a class="header" href="#flex">Flex</a></h3>
<p><code>Flex</code>组件可以让你灵活的布局。它在<code>group mod</code>中定义，实现了<code>GroupExt Trait</code>。可以使用<code>set_type</code>或<code>with_type</code>方法选择Flex的布局形式。比如列（Column）和行（Row）布局：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(400, 300);
    let mut flex = Flex::new(0, 0, 400, 300, None);
    flex.set_type(group::FlexType::Column);
    let expanding = button::Button::default().with_label(&quot;Expanding&quot;);
    let mut normal = button::Button::default().with_label(&quot;Normal&quot;);
    flex.set_size(&amp;mut normal, 30);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><code>set_size</code>方法接收一个放在Flex内部的组件，将其大小（高度或宽度）设置为传递的值，示例中设置高度为30。因为这是一个Column类型的Flex，所以传入的值代表组件的高度。
示例中另一个按钮大小是变的，因为没有为它设置尺寸。参见这个完整的例子：</p>
<p><a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/flex.rs">示例1</a></p>
<p><img src="https://github.com/osen/FL_Flex/raw/main/doc/login.png" alt="image" /></p>
<h3 id="packs"><a class="header" href="#packs">Packs</a></h3>
<p><code>Pack</code>组件同样在<code>group mod</code>中，并实现了<code>GroupExt trait</code>。类似的，也有两种形式的Pack，<code>Vertical Pack</code> 和 <code>Horizontal Pack</code>，Pack默认是Vertical，它需要设置子组件的高度，而Horizontal Pack需要设置它的子组件的宽度，比如这个示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::default().with_size(190, 40).center_of(&amp;my_window);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_size(80, 0).with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_size(80, 0).with_label(&quot;Button2&quot;);
    hpack.end();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>我们在窗口内创建了一个<code>Pack</code>，并在其中创建2个按钮。我们不需要设置按钮的坐标。你也可以像 FLTK仓库的示例 中的<code>Calculator</code>一样，将Pack互相嵌套。可以试试<code>Pack::auto_layout()</code>方法自动布局：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::new(0, 200, 400, 100, &quot;&quot;);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_label(&quot;Button2&quot;);
    hpack.end();
    hpack.auto_layout();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>这种情况下，我们甚至不需要设置按钮的大小。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937983-ef8bf400-3504-11eb-9da1-09c5ac1aade4.png" alt="image" /></p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<p><a href="https://github.com/fltk-rs/fltk-grid">Grid Crate</a>实现在另一个Crate中的。它需要使用<code>Grid::set_layout(&amp;mut self, rows, columns)</code>来设置一个Layout。然后通过<code>Grid::insert(&amp;mut self, row, column)</code>或<code>Grid::insert_ext(&amp;mut self, row, column, row_span, column_span)</code>方法添加组件。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use fltk_grid::Grid;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(500, 300);
    let mut grid = Grid::default_fill();
    // 若为 &quot;true&quot; 便会显示网格的框线和数字
    grid.debug(false); 
    // 设置Grid为 5 行，5 列
    grid.set_layout(5, 5); 
    // 设置组件和所在的行列
    grid.insert(&amp;mut button::Button::default().with_label(&quot;Click&quot;), 0, 1); 
    // 设置组件和所在的行列以及行高列宽
    grid.insert_ext(&amp;mut button::Button::default().with_label(&quot;Button 2&quot;), 2, 1, 3, 1); 
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><a href="https://github.com/fltk-rs/fltk-grid/blob/main/examples/form.rs">Grid example</a></p>
<p><img src="https://user-images.githubusercontent.com/37966791/160347418-b8b54408-3dc9-4fc4-93e8-fb6c1c0282e9.png" alt="image" /></p>
<h3 id="relative-positioning"><a class="header" href="#relative-positioning">Relative positioning</a></h3>
<p><code>WidgetExt Trait</code>中定义了几个构造方法，允许我们相基于其他组件的大小和位置构建组件。这类似于Qt中Qml的锚定（anchoring）：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let mut frame = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;wind)
        .with_label(&quot;0&quot;);
    let mut but_inc = button::Button::default()
        .size_of(&amp;frame)
        .above_of(&amp;frame, 0)
        .with_label(&quot;+&quot;);
    let mut but_dec = button::Button::default()
        .size_of(&amp;frame)
        .below_of(&amp;frame, 0)
        .with_label(&quot;-&quot;);
    wind.end();
    wind.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/counter.jpg" alt="counter" /></p>
<p>(我们跳过了一些主题的设计)</p>
<p>这些方法是：</p>
<ul>
<li><code>above_of(&amp;widget, padding)</code>: 将该组件放在所传递的组件上面</li>
<li><code>below_of(&amp;widget, padding)</code>: 将该组件放在所传递的组件下面</li>
<li><code>right_of(&amp;widget, padding)</code>: 将该组件放在所传递的组件右边</li>
<li><code>left_of(&amp;widget, padding)</code>:将该组件置于所传递的组件左边</li>
<li><code>center_of(&amp;widget)</code>: 将组件放置在所传递的组件的中间（包括x和y轴）</li>
<li><code>center_of_parent()</code>: 将组件放在父组件的中间（包括x轴和y轴）</li>
<li><code>center_x(&amp;widget)</code>: 将组件放置在所传递的组件的中心（X轴）</li>
<li><code>center_y(&amp;widget)</code>: 将组件放置在所传递的组件的中心（Y轴）</li>
<li><code>size_of(&amp;widget)</code>: 构建与所传组件相同大小的组件</li>
<li><code>size_of_parent()</code>: 构建与其父组件相同大小的组件</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="样式-style"><a class="header" href="#样式-style">样式 Style</a></h1>
<p>FLTK为你的应用程序提供了丰富的自定义选项，包括改变程序的总体主题，到自定义颜色、字体、Frame、自定义绘图...等等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="颜色-colors"><a class="header" href="#颜色-colors">颜色 Colors</a></h1>
<p>FLTK可以处理<a href="https://en.wikipedia.org/wiki/Color_depth#True_color_(24-bit)">True color</a>。一些常用的颜色在<code>enums::Color</code>中列举出来方便使用：</p>
<ul>
<li>Black</li>
<li>White</li>
<li>Red</li>
<li>Blue</li>
<li>Cyan
...etc.</li>
</ul>
<p>你也可以使用下列方法构建其他的颜色：</p>
<ul>
<li><code>by_index()</code>方法使用fltk的colormap选取颜色。取值范围是0到255。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let red = Color::by_index(88);
<span class="boring">}
</span></code></pre></pre>
<p><img src="https://www.fltk.org/doc-1.3/fltk-colormap.png" alt="colormap" /></p>
<ul>
<li><code>from_hex()</code>方法需要传入一个<code>24bit</code>的十六进制RGB值。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_hex(0xff0000); // 注意它是一个Const函数
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>from_rgb()</code>方法需要传入3个代表R、G、B的值：</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_rgb(255, 0, 0); // 注意它是一个Const函数
<span class="boring">}
</span></code></pre></pre>
<p><code>Color Enum</code>还提供了一些方便的方法，使用<code>.darker()</code>、<code>.lighter()</code>、<code>.inactive()</code>等方法可以在所选颜色的基础上生成色调有些变化的颜色，常用作阴影或按钮点击反馈等：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_rgb(176, 100, 50).lighter();
<span class="boring">}
</span></code></pre></pre>
<p>如果你喜欢使用html十六进制字符串生成颜色，可以使用<code>from_hex_str()</code>方法生成：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_hex_str(&quot;#ff0000&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="边框类型-frametypes"><a class="header" href="#边框类型-frametypes">边框类型 FrameTypes</a></h1>
<p>FLTK提供了丰富的边框类型。这些可以在<code>enums</code>mod下找到：
<img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/frames.jpg" alt="image" /></p>
<p>你可以用<code>WidgetExt::set_frame()</code>来为组件选择边框。一些组件或Trait也支持<code>set_down_frame()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/hello.jpg" alt="image" /></p>
<p>在这里，我们将Frame的<code>FrameType</code>设置为<code>EngravedBox</code>，你可以看到图片周围出现的边框。</p>
<p>​<code>ButtonExt Trait</code>支持使用<code>set_down_frame()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>btn1.set_frame(enums::FrameType::RFlatBox);
btn1.set_down_frame(enums::FrameType::RFlatBox);
<span class="boring">}
</span></code></pre></pre>
<p>此外，我们可以使用<code>app::set_frame_type_cb()</code>来改变我们选择的相应<code>FrameTypes</code>的绘制方式：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    enums::{Color, FrameType},
    prelude::*,
    *
};

fn down_box(x: i32, y: i32, w: i32, h: i32, c: Color) {
    draw::draw_box(FrameType::RFlatBox, x, y, w, h, Color::BackGround2);
    draw::draw_box(FrameType::RoundedFrame, x - 10, y, w + 20, h, c);
}

fn main() {
    let app = app::App::default();
    app::set_frame_type_cb(FrameType::DownBox, down_box, 0, 0, 0, 0);
    let mut w = window::Window::default().with_size(480, 230).with_label(&quot;Gui&quot;);
    w.set_color(Color::from_u32(0xf5f5f5));

    let mut txf = input::Input::default().with_size(160, 30).center_of_parent();    
    txf.set_color(Color::Cyan.darker());

    w.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146932070-ae63fd63-3f37-4d97-978e-4604d2bc0e4b.png" alt="image" /></p>
<p>这就用自定义的<code>down_box</code>绘制方法改变了默认的<code>DownBox</code>。我们还可以在绘制方法中使用<code>ImageExt::draw()</code>来绘制图像（比如画一个svg图像，以获得可缩放的圆角边框）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字体-fonts"><a class="header" href="#字体-fonts">字体 Fonts</a></h1>
<p>FLTK自带了16种字体，可以在<code>enums::Font</code>中找到：</p>
<ul>
<li>Helvetica</li>
<li>HelveticaBold</li>
<li>HelveticaItalic</li>
<li>HelveticaBoldItalic</li>
<li>Courier</li>
<li>CourierBold</li>
<li>CourierItalic</li>
<li>CourierBoldItalic</li>
<li>Times</li>
<li>TimesBold</li>
<li>TimesItalic </li>
<li>TimesBoldItalic </li>
<li>Symbol </li>
<li>Screen </li>
<li>ScreenBold </li>
<li>Zapfdingbats</li>
</ul>
<p>FLTK也允许加载系统默认字体或者将字体文件编译进二进制文件中。</p>
<p>系统字体依赖于用户的系统，默认情况下FLTK并不会加载。但你可以用<code>App::load_system_fonts()</code>方法来让程序加载系统字体。
然后可以使用<code>app::fonts()</code>函数获取加载到的字体，或者用<code>app::font_count()</code>、<code>app::font_name()</code>和<code>app::font_index()</code>函数查看字体的数量，名称等。
查询到后，便可以使用<code>Font::by_index()</code>或<code>Font::by_name()</code>方法来为程序应用字体。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default().load_system_fonts();
    // 要加载指定路径的字体的话，参见 App::load_font() 函数
    let fonts = app::fonts();
    // println!(&quot;{:?}&quot;, fonts);
    let mut wind = window::Window::default().with_size(400, 300);
    let mut frame = frame::Frame::default().size_of(&amp;wind);
    frame.set_label_size(30);
    wind.set_color(enums::Color::White);
    wind.end();
    wind.show();
    println!(&quot;The system has {} fonts!\nStarting slideshow!&quot;, fonts.len());
    let mut i = 0;
    while app.wait() {
        if i == fonts.len() {
            i = 0;
        }
        frame.set_label(&amp;format!(&quot;[{}]&quot;, fonts[i]));
        frame.set_label_font(enums::Font::by_index(i));
        app::sleep(0.5);
        i += 1;
    }
}
</code></pre></pre>
<p>如果你想加载一个自己的字体，你可以选择使用<code>Font::load_font()</code>和<code>Font::set_font()</code>方法：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::Font, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();

    let font = Font::load_font(&quot;angelina.ttf&quot;).unwrap();
    Font::set_font(Font::Helvetica, &amp;font);
    app::set_font_size(24);

    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p><code>load_font()</code>会加载<code>.ttf</code>格式的字体，然后我们使用<code>set_font()</code>用我们这个字体替换FLTK的默认字体<code>Font::Helvetica</code>：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145735197-130f7dd6-a31f-4bc6-a362-90a13493a556.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绘制事物-drawing-things"><a class="header" href="#绘制事物-drawing-things">绘制事物 Drawing things</a></h1>
<p><code>fltk-rs</code>在<code>draw mod</code>中提供了可以绘制自定义元素的函数。但是只有当绘制函数的调用是在特定的上下文中时，例如在<code>WidgetBase::draw()</code>方法中或在<code>Offscreen</code>上下文中，绘制才有效：</p>
<h2 id="在组件上绘制"><a class="header" href="#在组件上绘制">在组件上绘制</a></h2>
<p>注意，我们在组件的draw方法中使用了<code>draw</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.draw(|w| {
        use draw::*;
        // 白色窗口
        draw_rect_fill(0, 0, w.w(), w.h(), enums::Color::White);
        // 画一个蓝色的圆
        set_draw_color(enums::Color::Blue.inactive());
        draw_pie(w.w() / 2 - 50, w.h() / 2 - 50, 100, 100, 0.0, 360.0);
        // 让文字旋转一定角度
        set_draw_color(enums::Color::Red);
        set_font(enums::Font::Courier, 16);
        draw_text_angled(45, &quot;Hello World&quot;, w.w() / 2, w.h() / 2);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145693473-defb2298-fc6b-4d2f-8a0c-3d4902b39dd3.jpg" alt="draw" /></p>
<p>我们用了整个窗口当绘制的画板，任何其他组件理论上都可以进行绘制。还有许多其他函数可以让你绘制直线、矩形、弧线、饼、循环、多边形，甚至图像。</p>
<h2 id="屏幕外事件的绘制"><a class="header" href="#屏幕外事件的绘制">屏幕外事件的绘制</a></h2>
<p>有时可能会需要通过绘制来响应一些事件，例如拖动鼠标时，在屏幕上绘制出鼠标的轨迹。在这种情况下，你可以使用<code>draw::Offscreen</code>来做到这一点。我们所用组件的<code>draw</code>方法只是复制屏幕外事件的内容，例如鼠标的坐标，而绘制是在组件的<code>handle</code>方法中进行的。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    draw::{
        draw_line, draw_point, draw_rect_fill, set_draw_color, set_line_style, LineStyle, Offscreen,
    },
    enums::{Color, Event, FrameType},
    frame::Frame,
    prelude::*,
    window::Window,
};
use std::cell::RefCell;
use std::rc::Rc;

const WIDTH: i32 = 800;
const HEIGHT: i32 = 600;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);

    let mut wind = Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;RustyPainter&quot;);
    let mut frame = Frame::default()
        .with_size(WIDTH - 10, HEIGHT - 10)
        .center_of(&amp;wind);
    frame.set_color(Color::White);
    frame.set_frame(FrameType::DownBox);

    wind.end();
    wind.show();

    // 用白色填充
    let offs = Offscreen::new(frame.width(), frame.height()).unwrap();
    #[cfg(not(target_os = &quot;macos&quot;))]
    {
        offs.begin();
        draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
        offs.end();
    }

    let offs = Rc::from(RefCell::from(offs));

    frame.draw({
        let offs = offs.clone();
        move |_| {
            let mut offs = offs.borrow_mut();
            if offs.is_valid() {
                offs.rescale();
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
            } else {
                offs.begin();
                draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
                offs.end();
            }
        }
    });

    frame.handle({
        let mut x = 0;
        let mut y = 0;
        move |f, ev| {
            // println!(&quot;{}&quot;, ev);
            // println!(&quot;coords {:?}&quot;, app::event_coords());
            // println!(&quot;get mouse {:?}&quot;, app::get_mouse());
            let offs = offs.borrow_mut();
            match ev {
                Event::Push =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    x = coords.0;
                    y = coords.1;
                    draw_point(x, y);
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                Event::Drag =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    draw_line(x, y, coords.0, coords.1);
                    x = coords.0;
                    y = coords.1;
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                _ =&gt; false,
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>注意，这里我们用<code>offs.begin()</code>开始了<code>OffScreen</code>上下文，用<code>offs.end()</code>表示上下文结束。只有在上下文内，我们才能调用<code>Offscreen</code>绘图函数：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146173813-67038a94-7739-480e-a181-29498aac842a.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义风格-styling"><a class="header" href="#自定义风格-styling">自定义风格 Styling</a></h1>
<p>FLTK提供了自定义程序风格的很多方法（不然实在有点丑）。我们可以设置颜色，不同的字体，自定义绘制组件等等。自定义风格用到了所有这些。我们可以使用<code>WidgetExt</code>中定义的方法为每个组件单独设置风格，也可以使用<code>app</code>模块中的函数为程序全局设置风格。</p>
<h2 id="widgetext"><a class="header" href="#widgetext">WidgetExt</a></h2>
<p><code>WidgetExt Trait</code>的大多数方法与修改边框、标签、组件颜色、文本颜色、字体和文本大小这些自定义的功能有关。
对相应的属性，都提供了<code>setter</code>和<code>getter</code>方法，可以在[WidgetExt]（https://docs.rs/fltk/*/fltk/prelude/trait.WidgetExt.html）找到。</p>
<p>看看这个示例：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    enums::{Align, Color, Font, FrameType},
    prelude::*,
    *,
};

const BLUE: Color = Color::from_hex(0x42A5F5);
const SEL_BLUE: Color = Color::from_hex(0x2196F3);
const GRAY: Color = Color::from_hex(0x757575);
const WIDTH: i32 = 600;
const HEIGHT: i32 = 400;

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;Flutter-like!&quot;);
    let mut bar =
        frame::Frame::new(0, 0, WIDTH, 60, &quot;  FLTK App!&quot;).with_align(Align::Left | Align::Inside);
    let mut text = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;win)
        .with_label(&quot;You have pushed the button this many times:&quot;);
    let mut count = frame::Frame::default()
        .size_of(&amp;text)
        .below_of(&amp;text, 0)
        .with_label(&quot;0&quot;);
    let mut but = button::Button::new(WIDTH - 100, HEIGHT - 100, 60, 60, &quot;@+6plus&quot;);
    win.end();
    win.make_resizable(true);
    win.show();

    // 设置风格
    app::background(255, 255, 255);
    app::set_visible_focus(false);

    bar.set_frame(FrameType::FlatBox);
    bar.set_label_size(22);
    bar.set_label_color(Color::White);
    bar.set_color(BLUE);
    bar.draw(|b| {
        draw::set_draw_rgb_color(211, 211, 211);
        draw::draw_rectf(0, b.height(), b.width(), 3);
    });

    text.set_label_size(18);
    text.set_label_font(Font::Times);

    count.set_label_size(36);
    count.set_label_color(GRAY);

    but.set_color(BLUE);
    but.set_selection_color(SEL_BLUE);
    but.set_label_color(Color::White);
    but.set_frame(FrameType::OFlatFrame);
    // 风格应用结束

    but.set_callback(move |_| {
        let label = (count.label().parse::&lt;i32&gt;().unwrap() + 1).to_string();
        count.set_label(&amp;label);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/flutter_like.jpg" alt="counter" /></p>
<p>理论上所有组件都支持在其中显示图像，参见 图像 章节。</p>
<h2 id="global-styling"><a class="header" href="#global-styling">Global styling</a></h2>
<p>全局风格化方法可以在 <code>app</code> mod中找到。先看看如何改变程序的主题：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, enums::*, *};
let app = app::App::default().with_scheme(app::Scheme::Plastic);
<span class="boring">}
</span></code></pre></pre>
<p>FLTK本身提供四个主题：</p>
<ul>
<li>Base</li>
<li>Gtk</li>
<li>Gleam</li>
<li>Plastic</li>
</ul>
<p>这个例子设置了程序的颜色、默认字体、默认边框和是否在组件上显示焦点：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::Button, enums, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    app::set_background_color(170, 189, 206);
    app::set_background2_color(255, 255, 255);
    app::set_foreground_color(0, 0, 0);
    app::set_selection_color(255, 160,  63);
    app::set_inactive_color(130, 149, 166);
    app::set_font(enums::Font::Times);
    
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727821-5923fcd4-3a57-4a15-b36f-574b3e5321ea.png" alt="image" /></p>
<h3 id="custom-drawing"><a class="header" href="#custom-drawing">Custom Drawing</a></h3>
<p>FLTK还提供了绘图基本图形（drawing primitives），这可以大大简化为组件自定义外观的步骤。我们使用接收一个闭包参数的<code>draw()</code>方法完成绘制。让我们来绘制一个自己的按钮，虽然FLTK已经提供了<code>ShadowFrame</code>框架类型，为了演示我们自己再做一个：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, enums::*, *};

fn main() {
    let app = app::App::default();
    app::set_color(255, 255, 255); // 白色
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);

    let mut but = button::Button::default()
        .with_pos(160, 210)
        .with_size(80, 40)
        .with_label(&quot;Button1&quot;);

    but.draw2(|b| {
        draw::set_draw_color(Color::Gray0);
        draw::draw_rectf(b.x() + 2, b.y() + 2, b.width(), b.height());
        draw::set_draw_color(Color::from_u32(0xF5F5DC));
        draw::draw_rectf(b.x(), b.y(), b.width(), b.height());
        draw::set_draw_color(Color::Black);
        draw::draw_text2(
            &amp;b.label(),
            b.x(),
            b.y(),
            b.width(),
            b.height(),
            Align::Center,
        );
    });

    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100938232-62956a80-3505-11eb-888f-ffe655e7aadc.jpg" alt="draw" /></p>
<p><code>draw()</code>方法也支持在组件内部的绘制，你可以在下一节看到。</p>
<h2 id="fltk-theme"><a class="header" href="#fltk-theme">fltk-theme</a></h2>
<p>这是一个<a href="https://github.com/fltk-rs/fltk-theme">FLTK主题crate</a>，它提供了好几个预定义的主题，只需要加载就可以使用。</p>
<p>这里有很多好看的FLTK主题，或许可以挽留一下被界面劝退的你：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use fltk_theme::{widget_themes, WidgetTheme, ThemeType};

fn main() {
    let a = app::App::default();
    let widget_theme = WidgetTheme::new(ThemeType::Aero);
    widget_theme.apply();
    let mut win = window::Window::default().with_size(400, 300);
    let mut btn = button::Button::new(160, 200, 80, 30, &quot;Hello&quot;);
    btn.set_frame(widget_themes::OS_DEFAULT_BUTTON_UP_BOX);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-theme/raw/main/screenshots/aqua_classic.jpg" alt="aqua-classic" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动画-animations"><a class="header" href="#动画-animations">动画 Animations</a></h1>
<p>可以通过这几种机制在FLTK-rs中制作动画效果：</p>
<ul>
<li>利用事件循环 Event loop</li>
<li>使用线程 Spawning threads</li>
<li>超时 Timeouts</li>
</ul>
<h2 id="利用事件循环"><a class="header" href="#利用事件循环">利用事件循环</a></h2>
<p>fltk提供了<code>app::wait()</code>和<code>app::check()</code>，允许使用一个阻塞操作更新UI：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // 我们的按钮占据了窗口的左侧
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // 绘制已经完成
        }
        while btn.w() != 0 {
            btn.set_size(btn.w() - 2, btn.h());
            app::sleep(0.016);
            btn.parent().unwrap().redraw();
            app::wait(); // 或 app::check();
        }
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="使用线程"><a class="header" href="#使用线程">使用线程</a></h2>
<p>使用线程可以让我们不会阻塞主/ui线程：</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // 我们的按钮占据了窗口的左侧
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // 绘制已经完成
        }
        std::thread::spawn({
            let mut btn = btn.clone();
            move || {
                while btn.w() != 0 {
                    btn.set_size(btn.w() - 2, btn.h());
                    app::sleep(0.016);
                    app::awake(); // 唤醒UI线程进行绘制
                    btn.parent().unwrap().redraw();
                }
            }
        });
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="超时"><a class="header" href="#超时">超时</a></h2>
<p>fltk为重复性操作提供了<code>timeout</code>功能。使用<code>timeout</code>会像循环一样持续性执行一段代码，我们可以添加条件让它持续重复，或者删除<code>timeout</code>让它停止。</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn move_button(mut btn: button::Button, handle: app::TimeoutHandle) {
    btn.set_size(btn.w() - 2, btn.h());
    btn.parent().unwrap().redraw();
    if btn.w() == 20 {
        app::remove_timeout3(handle);
    } else {
        app::repeat_timeout3(0.016, handle);
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    let mut btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut btn);
    btn.clear_visible_focus();
    win.end();
    win.show();

    btn.set_callback(|b| {
        let btn = b.clone();
        app::add_timeout3(0.016, move |handle| {
            let btn = btn.clone();
            move_button(btn, handle)
        });
    });

    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<p>这段代码在用户点击时添加<code>timeout</code>，当按钮宽度到达预定值时，删除<code>timeout</code>使其停止重复。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h1>
<p>FLTK提供了一些开箱即用的无障碍功能：</p>
<ul>
<li>在ui元素之间和内部的键盘导航。</li>
<li>键盘快捷键。</li>
<li>键盘可替代的鼠标操作。</li>
<li>IME 支持。</li>
<li>为组件和自定义组件设置按键事件。</li>
</ul>
<p>屏幕阅读器的支持集成在另一个 crate 中:</p>
<ul>
<li><a href="https://github.com/fltk-rs/fltk-accesskit">fltk-accesskit</a></li>
</ul>
<p>这个例子使用了 <code>fltk-accesskit</code> 编写了一个无障碍程序的示例：</p>
<p>例子:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![windows_subsystem = &quot;windows&quot;]
use fltk::{prelude::*, *};
use fltk_accesskit::{AccessibilityContext, AccessibleApp};

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Oxy);
    let mut w = window::Window::default()
        .with_size(400, 300)
        .with_label(&quot;Hello fltk-accesskit&quot;);
    let col = group::Flex::default()
        .with_size(200, 100)
        .center_of_parent()
        .column();
    let inp = input::Input::default().with_id(&quot;inp&quot;).with_label(&quot;Enter name:&quot;);
    let mut btn = button::Button::default().with_label(&quot;Greet&quot;);
    let out = output::Output::default().with_id(&quot;out&quot;);
    col.end();
    w.end();
    w.make_resizable(true);
    w.show();

    btn.set_callback(btn_callback);

    let ac = AccessibilityContext::new(
        w,
        vec![Box::new(inp), Box::new(btn), Box::new(out)],
    );

    a.run_with_accessibility(ac).unwrap();
}

fn btn_callback(_btn: &amp;mut button::Button) {
    let inp: input::Input = app::widget_from_id(&quot;inp&quot;).unwrap();
    let mut out: output::Output = app::widget_from_id(&quot;out&quot;).unwrap();
    let name = inp.value();
    if name.is_empty() {
        return;
    }
    out.set_value(&amp;format!(&quot;Hello {}&quot;, name));
}
</code></pre></pre>
<p><code>Accessible Trait</code> 是为一些特定的组件实现的。
这个例子中，你需要实例化一个<code>fltk_accesskit::AccessibilityContext</code>，它需要你将根组件（主窗口），以及会被屏幕阅读器识别的组件作为参数。
最后你需要使用特殊的 <code>run_with_accessibility</code> 来运行 App结构。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="build-issues"><a class="header" href="#build-issues">Build issues</a></h2>
<h3 id="why-does-the-build-fails-when-i-follow-one-of-the-tutorials"><a class="header" href="#why-does-the-build-fails-when-i-follow-one-of-the-tutorials">Why does the build fails when I follow one of the tutorials?</a></h3>
<p>The first tutorial uses the fltk-bundled feature flag, which is only supported for certain platforms since these are built using the Github Actions CI, namely:</p>
<ul>
<li>Windows 10 x64 (msvc and gnu).</li>
<li>MacOS 12 x64 and aarch64.</li>
<li>Ubuntu 20.04 or later, x64 and aarch64.</li>
</ul>
<p>If you're not running one of the aforementioned platforms, you'll have to remove the fltk-bundled feature flag in your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.3&quot;
</code></pre>
<p>Furthermore, the fltk-bundled flag assumes you have curl and tar installed (for Windows, they're available in the Native Tools Command Prompt).</p>
<h3 id="build-fails-on-windows-why-cant-cmake-find-my-toolchain"><a class="header" href="#build-fails-on-windows-why-cant-cmake-find-my-toolchain">Build fails on windows, why can't CMake find my toolchain?</a></h3>
<p>If you're building using the MSVC toolchain, make sure you run your build (at least your initial build) using the Native Tools Command Prompt, which should appear once you start typing &quot;native&quot; in the start menu, choose the version corresponding to your installed Rust toolchain (x86 or x64). The Native Tools Command Prompt has all the environment variables set correctly for native development. <a href="https://github.com/alexcrichton/cmake-rs">cmake-rs</a> which the bindings use might not be able to find the Visual Studio 2022 generator, in which case, you can try to use the fltk-bundled feature, or use ninja via the use-ninja feature. This requires installing <a href="https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages">Ninja</a> which can be installed with Chocolatey, Scoop or manually.</p>
<p>If you're building for the GNU toolchain, make sure that Make is also installed, which usually comes installed in mingw64 toolchain.</p>
<h3 id="build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do"><a class="header" href="#build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do">Build fails on MacOS 11 with an Apple M1 chip, what can I do?</a></h3>
<p>If you're getting &quot;file too small to be an archive&quot; error, you might be hitting this <a href="https://github.com/rust-lang/cargo/issues/8875">issues</a> or this <a href="https://github.com/rust-lang/rust/issues/50220">issue</a>. MacOS's native C/C++ toolchain shouldn't have this issue, and can be installed by running <code>xcode-select --install</code> or by installing XCode. Make sure the corresponding Rust toolchain (aarch64-apple-darwin) is installed as well. You can uninstall other Rust apple-darwin toolchains or use cargo-lipo instead if you need universal/fat binaries.</p>
<h3 id="why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows"><a class="header" href="#why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows">Why do I get a Link error while using the mingw toolchain on windows?</a></h3>
<p>If the linking fails because of this <a href="https://github.com/rust-lang/rust/issues/47048">issue</a> with older toolchains, it should work by using the fltk-shared feature (an issue with older compilers). Which would also generate a dynamic library which would need to be deployed with your application.</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.3&quot;, features = [&quot;fltk-shared&quot;] }
</code></pre>
<h3 id="why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls"><a class="header" href="#why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls">Why does my msys2 mingw built fltk app using, fltk-bundled, isn't self-contained and requires several dlls?</a></h3>
<p>If you have installed libgdiplus via pacman, it would require those dependencies on other systems. If you're using the windows sdk-provided libgdiplus, it shouldn't require extra dlls. You can either uninstall libgdiplus that was installed via pacman, or or you can build using the feature flag: <code>no-gdiplus</code>.</p>
<h3 id="why-do-i-get-link-errors-when-i-use-the-system-fltk-feature"><a class="header" href="#why-do-i-get-link-errors-when-i-use-the-system-fltk-feature">Why do I get link errors when I use the system-fltk feature?</a></h3>
<p>This crate targets FLTK 1.4, while currently most distros distribute an older version of FLTK (1.3.5). You can try to install FLTK (C++) by building from source.</p>
<h3 id="build-fails-on-arch-linux-because-of-pango-or-cairo"><a class="header" href="#build-fails-on-arch-linux-because-of-pango-or-cairo">Build fails on Arch linux because of pango or cairo?</a></h3>
<p>Pango changed its include paths which caused build failures across many projects. There are 2 solutions:</p>
<ul>
<li>Use the no-pango feature. Downsides: loss of rtl and cjk language support.</li>
<li>Set the CFLAGS and CXXFLAGS to correct the global include paths.</li>
</ul>
<pre><code>export CFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
export CXXFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
</code></pre>
<h3 id="how-do-i-force-cmake-to-use-a-certain-c-compiler"><a class="header" href="#how-do-i-force-cmake-to-use-a-certain-c-compiler">How do I force CMake to use a certain C++ compiler?</a></h3>
<p>FLTK works with all 3 major compilers. If you would like to change the C++ compiler that's chosen by default by CMake, you can change the CXX environment variable before running the build:</p>
<pre><code>export CXX=/usr/bin/clang++
cargo run
</code></pre>
<p>CMake caches the C++ compiler variable after it's first run, so if the above failed because of a previous run, you would have to run <code>cargo clean</code> or you can manually delete the CMakeCache.txt file in the build directory.</p>
<h3 id="can-i-accelerate-the-build-speed"><a class="header" href="#can-i-accelerate-the-build-speed">Can I accelerate the build speed?</a></h3>
<p>You can use the &quot;use-ninja&quot; feature flag if you have ninja installed. </p>
<h3 id="can-i-cache-a-previous-build-of-the-fltk-library"><a class="header" href="#can-i-cache-a-previous-build-of-the-fltk-library">Can I cache a previous build of the FLTK library?</a></h3>
<p>You can use the fltk-bundled feature and use either the CFLTK_BUNDLE_DIR or CFLTK_BUNDLE_URL to point to the location of your cached cfltk and fltk libraries.</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<h3 id="how-do-i-deploy-my-application"><a class="header" href="#how-do-i-deploy-my-application">How do I deploy my application?</a></h3>
<p>Rust, by default, statically links your application. FLTK is built also for static linking. That means that the resulting executable can be directly deployed without the need to deploy other files along with it. If you want to create a WIN32 application, Mac OS Bundle or Linux AppImage, please check the question just below!</p>
<h3 id="why-do-i-get-a-console-window-whenever-i-start-my-gui-app"><a class="header" href="#why-do-i-get-a-console-window-whenever-i-start-my-gui-app">Why do I get a console window whenever I start my GUI app?</a></h3>
<p>This is the default behavior of the toolchain, and is helpful for debugging purposes. It can be turned off easily by adding <code>#![windows_subsystem = &quot;windows&quot;]</code> at the beginning of your main.rs file if you're on windows. 
If you would like to keep the console window on debug builds, but not on release builds, you can use <code>#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]</code> instead.</p>
<p>For Mac OS and Linux, this is done by a post-build process to create a Mac OS Bundle or Linux AppImage respectively.</p>
<p>See <a href="https://github.com/burtonageo/cargo-bundle">cargo-bundle</a> for an automated tool for creating Mac OS app bundles. </p>
<p>See <a href="https://docs.appimage.org/packaging-guide/overview.html#converting-existing-binary-packages">here</a> for directions on creating an AppImage for Linux.</p>
<h3 id="why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected"><a class="header" href="#why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected">Why is the size of my resulting executable larger than I had expected?</a></h3>
<p>FLTK is known for it's small applications. Make sure you're building in release, and make sure symbols are stripped using the strip command in Unix-like systems. On Windows it's unnecessary since symbols would end up in the pdb file (which shouldn't be deployed).</p>
<p>If you need an even smaller size, try using opt-level=&quot;z&quot;:</p>
<pre><code class="language-toml">[profile.release]
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Newer versions of cargo (&gt;1.46) support automatically stripping binaries in the post-build phase:</p>
<pre><code class="language-toml">cargo-features = [&quot;strip&quot;]

[profile.release]
strip = true
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Furthermore, you can build Rust's stdlib optimized for size (it comes optimized for speed by default). More info on that <a href="https://github.com/johnthagen/min-sized-rust">here</a></p>
<h3 id="can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm"><a class="header" href="#can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm">Can I cross-compile my application to a mobile platform or WASM?</a></h3>
<p>FLTK currently doesn't support WASM nor iOS. It has experimental support for Android (YMMV). It is focused on desktop applications.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<h3 id="can-i-use-this-crate-in-a-commercial-application"><a class="header" href="#can-i-use-this-crate-in-a-commercial-application">Can I use this crate in a commercial application?</a></h3>
<p>Yes. This crate has an MIT license which requires acknowledgment. FLTK (the C++ library) is licensed under the LGPL license with an exception allowing static linking for commercial/closed-source use. You can find the full terms of both licenses here:</p>
<ul>
<li><a href="https://github.com/fltk/fltk/blob/master/COPYING">COPYING</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/blob/master/LICENSE">LICENSE</a></li>
</ul>
<h2 id="alignment"><a class="header" href="#alignment">Alignment</a></h2>
<h3 id="why-cant-i-align-input-or-output-text-to-the-right"><a class="header" href="#why-cant-i-align-input-or-output-text-to-the-right">Why can't I align input or output text to the right?</a></h3>
<p>FLTK has some known issues with text alignment.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<h3 id="do-you-plan-on-supporting-multithreading-or-asyncawait"><a class="header" href="#do-you-plan-on-supporting-multithreading-or-asyncawait">Do you plan on supporting multithreading or async/await?</a></h3>
<p>FLTK supports multithreaded and concurrent applications. See the examples dir and the <a href="https://github.com/fltk-rs/demos">fltk-rs demos repo</a> for examples on usage with threads, messages, async_std and tokio (web-todo examples).</p>
<h3 id="should-i-explicitly-call-applock-and-appunlock"><a class="header" href="#should-i-explicitly-call-applock-and-appunlock">Should I explicitly call app::lock() and app::unlock()?</a></h3>
<p>fltk-rs surrounds all mutating calls to widgets with a lock on the C++ wrapper side. Normally you wouldn't have to call app::lock() and app::unlock(). 
This depends however on the support of recursive mutexes in your system. 
If you notice haning in multithreaded applications, you might have to initialize threads (like xlib threads) by calling app::lock() once in your main thread. 
In that case, you can wrap widgets in an Arc<Mutex> or surround widget-mutating functions/methods with an app::lock and app::unlock. 
But that should rarely be required.</p>
<h2 id="windowing"><a class="header" href="#windowing">Windowing</a></h2>
<h3 id="why-does-fltk-exit-when-i-hit-the-escape-key"><a class="header" href="#why-does-fltk-exit-when-i-hit-the-escape-key">Why does FLTK exit when I hit the escape key?</a></h3>
<p>This is the default behavior in FLTK. You can easily override it by setting a callback for your main window:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    wind.set_callback(|_| {
        if fltk::app::event() == fltk::enums::Event::Close {
            app::quit(); // Which would close using the close button. You can also assign other keys to close the application
        }
    });
<span class="boring">}
</span></code></pre></pre>
<h2 id="panicscrashes"><a class="header" href="#panicscrashes">Panics/Crashes</a></h2>
<h3 id="my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it"><a class="header" href="#my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it">My app panics when I try to handle events, how can I fix it?</a></h3>
<p>This is due to a debug_assert which checks that the involved widget and the window are capable of handling events. Although most events would be handled correctly, some events require that the aforementioned conditions be met. Thus it is advisable to place your event handling code after the main drawing is done, i.e after calling your main window's show() method. Another point is that event handling and drawing should be done in the main thread. Panics accross FFI boundaries are undefined behavior, as such, the wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<h2 id="memory-and-unsafety"><a class="header" href="#memory-and-unsafety">Memory and unsafety</a></h2>
<h3 id="how-memory-safe-is-fltk-rs"><a class="header" href="#how-memory-safe-is-fltk-rs">How memory-safe is fltk-rs?</a></h3>
<p>The callback mechanism consists of a closure as a void pointer with a shim which dereferences the void pointer into a function pointer and calls the function. This is technically undefined behavior, however most implementations permit it and it's the method used by most wrappers to handle callbacks across FFI boundaries. <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/function-pointers.html#representation">link</a></p>
<p>As stated before, panics accross FFI boundaries are undefined behavior, as such, the C++ wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<p>FLTK manages it's own memory. Any widget is automatically owned by a parent which does the book-keeping as well and deletion, this is the enclosing widget implementing GroupExt such as windws etc. This is done in the C++ FLTK library itself. Any constructed widget calls the current() method which detects the enclosing group widget, and calls its add() method rending ownership to the group widget. Upon destruction of the group widget, all owned widgets are freed. Also all widgets are wrapped in a mutex for all mutating methods, and their lifetimes are tracked using an Fl_Widget_Tracker, That means widgets have interior mutability as if wrapped in an Arc&lt;Mutex<widget>&gt; and have a tracking pointer to detect deletion. Cloning a widget performs a memcpy of the underlying pointer and allows for interior mutability; it does not create a new widget.
Images are reference-counted. All mutating methods are wrapped in locks.
This locking might lead to some performance degradation as compared to the original FLTK library, it does allow for multithreaded applications, and is necessary in an FLTK (C++) application if it also required threading.</p>
<p>Overriding drawing methods will box data to be sent to the C++ library, so the data should optimally be limited to widgets or plain old data types to avoid unnecessary leaks if a custom drawn widget might be deleted during the lifetime of the program.</p>
<h3 id="can-i-get-memory-leaks-with-fltk-rs"><a class="header" href="#can-i-get-memory-leaks-with-fltk-rs">Can I get memory leaks with fltk-rs?</a></h3>
<p>Non-parented widgets that can no longer be accessed are a memory leak. Otherwise, as mentioned in the previous section all parented widgets lifetimes' are managed by the parent.
An example of a leaking widget:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    win.end();
    win.show();

    {
        button::Button::default(); // this leaks since it's not parented by the window, and has no handle in main
    }
}
</code></pre></pre>
<p>A more subtle cause of leaks, is removing a widget from a group, then the scope ends without it being added to another group or deleted:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    {
        button::Button::default(); // This doesn't leak since the parent is the window
    }
    win.end();
    win.show();

    {
        win.remove_by_index(0); // the button leaks here since it's removed and we no longer have access to it
    }
}
</code></pre></pre>
<h3 id="why-is-fltk-rs-using-so-much-unsafe-code"><a class="header" href="#why-is-fltk-rs-using-so-much-unsafe-code">Why is fltk-rs using so much unsafe code?</a></h3>
<p>Interfacing with C++ or C code can't be reasoned about by the Rust compiler, so the unsafe keyword is needed.</p>
<h3 id="is-fltk-rs-panicexception-safe"><a class="header" href="#is-fltk-rs-panicexception-safe">Is fltk-rs panic/exception-safe?</a></h3>
<p>FLTK (C++) doesn't throw exceptions, neither do the C wrapper (cfltk) nor the fltk-sys crate. The higher level fltk crate, which wraps fltk-sys, is not exception-safe since it uses asserts internally after various operations to ensure memory-safety. An example is a widget constructor which checks that the returned pointer (from the C++ side) is not null from allocation failure. It also asserts all widget reads/writes are happening on valid (not deleted) widgets.
Also any function sending a string across FFI is checked for interal null bytes. For such functions, the developer can perform a sanity check on passed strings to make sure they're valid UTF-8 strings, or check that a widget was not deleted prior to accessing a widget. That said, all functions passed as callbacks to be handled by the C++ side are exception-safe.</p>
<h3 id="are-there-any-environment-variables-which-can-affect-the-build-or-behavior"><a class="header" href="#are-there-any-environment-variables-which-can-affect-the-build-or-behavior">Are there any environment variables which can affect the build or behavior?</a></h3>
<ul>
<li><code>CFLTK_TOOLCHAIN=&lt;path&gt;</code> allows passing the path to a CMake file acting as a CMAKE_TOOLCHAIN_FILE, this allows passing extra info to cmake if needed.</li>
<li><code>CFLTK_WAYLAND_ONLY=&lt;1 or 0&gt;</code> allows building for wayland only without directly linking X11 libs nor relying on their headers for the build process. This only works with the <code>use-wayland</code> feature flag.</li>
<li><code>CFLTK_BUNDLE_DIR=&lt;path&gt;</code> allows passing a path of prebuilt cfltk and fltk static libs, useful for when a customized build of fltk is needed, or for targetting other arches when building with the <code>fltk-bundled</code> flag.</li>
<li><code>CFLTK_BUNDLE_URL=&lt;url&gt;</code> similar to above but allows passing a url which will directs the build script to download from the passed url.</li>
<li><code>FLTK_BACKEND=&lt;x11 or wayland&gt;</code> allows choosing the backend of your hybrid X11/wayland FLTK app. This only works for apps built with <code>use-wayland</code> feature flag. </li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Please refer to the <a href="https://github.com/fltk-rs/fltk-rs/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> page for further information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
